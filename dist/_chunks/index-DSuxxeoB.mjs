import * as C from "react";
import ze, { useRef as ue, useEffect as Ce, useMemo as So, useCallback as rt, createContext as Ua, createElement as B, useContext as wh, forwardRef as O, Children as vo, isValidElement as Ou, cloneElement as mg, Fragment as xh, useState as De, useLayoutEffect as yh, useReducer as Yw, useImperativeHandle as VT } from "react";
import { useTheme as V, styled as W, ThemeProvider as HT, css as Ie, createGlobalStyle as PT, keyframes as tn } from "styled-components";
import { jsxs as ae, Fragment as Gs, jsx as m } from "react/jsx-runtime";
import * as Ys from "react-dom";
import WT, { flushSync as jw, createPortal as Xw } from "react-dom";
const N0 = (t, e = "") => Object.keys(t).reduce((n, r) => {
  const i = e.length ? `${e}.` : "";
  return typeof t[r] == "object" && t[r] !== null && !Array.isArray(t[r]) ? Object.assign(n, N0(t[r], i + r)) : n[i + r] = t[r], n;
}, {}), Hv = (t, e) => {
  if (!e)
    throw new TypeError("pluginId can't be empty");
  return Object.keys(t).reduce((n, r) => (n[`${e}.${r}`] = t[r], n), {});
};
function Ot(t) {
  const e = ue(t);
  return Ce(() => {
    e.current = t;
  }), So(
    () => (...n) => {
      var r;
      return (r = e.current) === null || r === void 0 ? void 0 : r.call(e, ...n);
    },
    []
  );
}
function Vd(t, e) {
  return t - e * Math.floor(t / e);
}
const Zw = 1721426;
function Mc(t, e, n, r) {
  e = vg(t, e);
  let i = e - 1, o = -2;
  return n <= 2 ? o = 0 : pu(e) && (o = -1), Zw - 1 + 365 * i + Math.floor(i / 4) - Math.floor(i / 100) + Math.floor(i / 400) + Math.floor((367 * n - 362) / 12 + o + r);
}
function pu(t) {
  return t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0);
}
function vg(t, e) {
  return t === "BC" ? 1 - e : e;
}
function zT(t) {
  let e = "AD";
  return t <= 0 && (e = "BC", t = 1 - t), [
    e,
    t
  ];
}
const UT = {
  standard: [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ],
  leapyear: [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ]
};
class Es {
  fromJulianDay(e) {
    let n = e, r = n - Zw, i = Math.floor(r / 146097), o = Vd(r, 146097), s = Math.floor(o / 36524), a = Vd(o, 36524), c = Math.floor(a / 1461), h = Vd(a, 1461), f = Math.floor(h / 365), d = i * 400 + s * 100 + c * 4 + f + (s !== 4 && f !== 4 ? 1 : 0), [p, v] = zT(d), w = n - Mc(p, v, 1, 1), b = 2;
    n < Mc(p, v, 3, 1) ? b = 0 : pu(v) && (b = 1);
    let y = Math.floor(((w + b) * 12 + 373) / 367), $ = n - Mc(p, v, y, 1) + 1;
    return new Ka(p, v, y, $);
  }
  toJulianDay(e) {
    return Mc(e.era, e.year, e.month, e.day);
  }
  getDaysInMonth(e) {
    return UT[pu(e.year) ? "leapyear" : "standard"][e.month - 1];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getMonthsInYear(e) {
    return 12;
  }
  getDaysInYear(e) {
    return pu(e.year) ? 366 : 365;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getYearsInEra(e) {
    return 9999;
  }
  getEras() {
    return [
      "BC",
      "AD"
    ];
  }
  isInverseEra(e) {
    return e.era === "BC";
  }
  balanceDate(e) {
    e.year <= 0 && (e.era = e.era === "BC" ? "AD" : "BC", e.year = 1 - e.year);
  }
  constructor() {
    this.identifier = "gregory";
  }
}
const KT = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BY: 1,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  HR: 1,
  HU: 1,
  IE: 1,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JO: 6,
  KG: 1,
  KW: 6,
  KZ: 1,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MK: 1,
  MN: 1,
  MQ: 1,
  MV: 5,
  MY: 1,
  NL: 1,
  NO: 1,
  NZ: 1,
  OM: 6,
  PL: 1,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SD: 6,
  SE: 1,
  SI: 1,
  SK: 1,
  SM: 1,
  SY: 6,
  TJ: 1,
  TM: 1,
  TR: 1,
  UA: 1,
  UY: 1,
  UZ: 1,
  VA: 1,
  VN: 1,
  XK: 1
};
function Qw(t, e) {
  return e = or(e, t.calendar), t.era === e.era && t.year === e.year && t.month === e.month && t.day === e.day;
}
function Jw(t, e) {
  let n = t.calendar.toJulianDay(t), r = Math.ceil(n + 1 - ZT(e)) % 7;
  return r < 0 && (r += 7), r;
}
function qT(t) {
  return si(Date.now(), t);
}
function bg(t) {
  return o3(qT(t));
}
function e3(t, e) {
  return t.calendar.toJulianDay(t) - e.calendar.toJulianDay(e);
}
function GT(t, e) {
  return Pv(t) - Pv(e);
}
function Pv(t) {
  return t.hour * 36e5 + t.minute * 6e4 + t.second * 1e3 + t.millisecond;
}
let Hd = null;
function Os() {
  return Hd == null && (Hd = new Intl.DateTimeFormat().resolvedOptions().timeZone), Hd;
}
function YT(t) {
  return t.subtract({
    days: t.day - 1
  });
}
function jT(t) {
  return t.add({
    days: t.calendar.getDaysInMonth(t) - t.day
  });
}
function t3(t, e) {
  let n = Jw(t, e);
  return t.subtract({
    days: n
  });
}
const Wv = /* @__PURE__ */ new Map();
function XT(t) {
  if (Intl.Locale) {
    let n = Wv.get(t);
    return n || (n = new Intl.Locale(t).maximize().region, n && Wv.set(t, n)), n;
  }
  let e = t.split("-")[1];
  return e === "u" ? void 0 : e;
}
function ZT(t) {
  let e = XT(t);
  return e && KT[e] || 0;
}
function F0(t, e) {
  return t && e ? t.compare(e) <= 0 ? t : e : t || e;
}
function V0(t, e) {
  return t && e ? t.compare(e) >= 0 ? t : e : t || e;
}
function Ds(t) {
  t = or(t, new Es());
  let e = vg(t.era, t.year);
  return n3(e, t.month, t.day, t.hour, t.minute, t.second, t.millisecond);
}
function n3(t, e, n, r, i, o, s) {
  let a = /* @__PURE__ */ new Date();
  return a.setUTCHours(r, i, o, s), a.setUTCFullYear(t, e - 1, n), a.getTime();
}
function H0(t, e) {
  if (e === "UTC") return 0;
  if (t > 0 && e === Os()) return new Date(t).getTimezoneOffset() * -6e4;
  let { year: n, month: r, day: i, hour: o, minute: s, second: a } = r3(t, e);
  return n3(n, r, i, o, s, a, 0) - Math.floor(t / 1e3) * 1e3;
}
const zv = /* @__PURE__ */ new Map();
function r3(t, e) {
  let n = zv.get(e);
  n || (n = new Intl.DateTimeFormat("en-US", {
    timeZone: e,
    hour12: !1,
    era: "short",
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  }), zv.set(e, n));
  let r = n.formatToParts(new Date(t)), i = {};
  for (let o of r) o.type !== "literal" && (i[o.type] = o.value);
  return {
    // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
    year: i.era === "BC" || i.era === "B" ? -i.year + 1 : +i.year,
    month: +i.month,
    day: +i.day,
    hour: i.hour === "24" ? 0 : +i.hour,
    minute: +i.minute,
    second: +i.second
  };
}
const Uv = 864e5;
function QT(t, e, n, r) {
  return (n === r ? [
    n
  ] : [
    n,
    r
  ]).filter((o) => JT(t, e, o));
}
function JT(t, e, n) {
  let r = r3(n, e);
  return t.year === r.year && t.month === r.month && t.day === r.day && t.hour === r.hour && t.minute === r.minute && t.second === r.second;
}
function ii(t, e, n = "compatible") {
  let r = Ao(t);
  if (e === "UTC") return Ds(r);
  if (e === Os() && n === "compatible") {
    r = or(r, new Es());
    let c = /* @__PURE__ */ new Date(), h = vg(r.era, r.year);
    return c.setFullYear(h, r.month - 1, r.day), c.setHours(r.hour, r.minute, r.second, r.millisecond), c.getTime();
  }
  let i = Ds(r), o = H0(i - Uv, e), s = H0(i + Uv, e), a = QT(r, e, i - o, i - s);
  if (a.length === 1) return a[0];
  if (a.length > 1) switch (n) {
    case "compatible":
    case "earlier":
      return a[0];
    case "later":
      return a[a.length - 1];
    case "reject":
      throw new RangeError("Multiple possible absolute times found");
  }
  switch (n) {
    case "earlier":
      return Math.min(i - o, i - s);
    case "compatible":
    case "later":
      return Math.max(i - o, i - s);
    case "reject":
      throw new RangeError("No such absolute time found");
  }
}
function i3(t, e, n = "compatible") {
  return new Date(ii(t, e, n));
}
function si(t, e) {
  let n = H0(t, e), r = new Date(t + n), i = r.getUTCFullYear(), o = r.getUTCMonth() + 1, s = r.getUTCDate(), a = r.getUTCHours(), c = r.getUTCMinutes(), h = r.getUTCSeconds(), f = r.getUTCMilliseconds();
  return new Is(i, o, s, e, n, a, c, h, f);
}
function o3(t) {
  return new Ka(t.calendar, t.era, t.year, t.month, t.day);
}
function Ao(t, e) {
  let n = 0, r = 0, i = 0, o = 0;
  if ("timeZone" in t) ({ hour: n, minute: r, second: i, millisecond: o } = t);
  else if ("hour" in t && !e) return t;
  return e && ({ hour: n, minute: r, second: i, millisecond: o } = e), new Iu(t.calendar, t.era, t.year, t.month, t.day, n, r, i, o);
}
function or(t, e) {
  if (t.calendar.identifier === e.identifier) return t;
  let n = e.fromJulianDay(t.calendar.toJulianDay(t)), r = t.copy();
  return r.calendar = e, r.era = n.era, r.year = n.year, r.month = n.month, r.day = n.day, ko(r), r;
}
function eR(t, e, n) {
  if (t instanceof Is)
    return t.timeZone === e ? t : s3(t, e);
  let r = ii(t, e, n);
  return si(r, e);
}
function tR(t) {
  let e = Ds(t) - t.offset;
  return new Date(e);
}
function s3(t, e) {
  let n = Ds(t) - t.offset;
  return or(si(n, e), t.calendar);
}
const Ca = 36e5;
function Ch(t, e) {
  let n = t.copy(), r = "hour" in n ? oR(n, e) : 0;
  P0(n, e.years || 0), n.calendar.balanceYearMonth && n.calendar.balanceYearMonth(n, t), n.month += e.months || 0, W0(n), a3(n), n.day += (e.weeks || 0) * 7, n.day += e.days || 0, n.day += r, nR(n), n.calendar.balanceDate && n.calendar.balanceDate(n), n.year < 1 && (n.year = 1, n.month = 1, n.day = 1);
  let i = n.calendar.getYearsInEra(n);
  if (n.year > i) {
    var o, s;
    let c = (o = (s = n.calendar).isInverseEra) === null || o === void 0 ? void 0 : o.call(s, n);
    n.year = i, n.month = c ? 1 : n.calendar.getMonthsInYear(n), n.day = c ? 1 : n.calendar.getDaysInMonth(n);
  }
  n.month < 1 && (n.month = 1, n.day = 1);
  let a = n.calendar.getMonthsInYear(n);
  return n.month > a && (n.month = a, n.day = n.calendar.getDaysInMonth(n)), n.day = Math.max(1, Math.min(n.calendar.getDaysInMonth(n), n.day)), n;
}
function P0(t, e) {
  var n, r;
  !((n = (r = t.calendar).isInverseEra) === null || n === void 0) && n.call(r, t) && (e = -e), t.year += e;
}
function W0(t) {
  for (; t.month < 1; )
    P0(t, -1), t.month += t.calendar.getMonthsInYear(t);
  let e = 0;
  for (; t.month > (e = t.calendar.getMonthsInYear(t)); )
    t.month -= e, P0(t, 1);
}
function nR(t) {
  for (; t.day < 1; )
    t.month--, W0(t), t.day += t.calendar.getDaysInMonth(t);
  for (; t.day > t.calendar.getDaysInMonth(t); )
    t.day -= t.calendar.getDaysInMonth(t), t.month++, W0(t);
}
function a3(t) {
  t.month = Math.max(1, Math.min(t.calendar.getMonthsInYear(t), t.month)), t.day = Math.max(1, Math.min(t.calendar.getDaysInMonth(t), t.day));
}
function ko(t) {
  t.calendar.constrainDate && t.calendar.constrainDate(t), t.year = Math.max(1, Math.min(t.calendar.getYearsInEra(t), t.year)), a3(t);
}
function l3(t) {
  let e = {};
  for (let n in t) typeof t[n] == "number" && (e[n] = -t[n]);
  return e;
}
function c3(t, e) {
  return Ch(t, l3(e));
}
function wg(t, e) {
  let n = t.copy();
  return e.era != null && (n.era = e.era), e.year != null && (n.year = e.year), e.month != null && (n.month = e.month), e.day != null && (n.day = e.day), ko(n), n;
}
function Du(t, e) {
  let n = t.copy();
  return e.hour != null && (n.hour = e.hour), e.minute != null && (n.minute = e.minute), e.second != null && (n.second = e.second), e.millisecond != null && (n.millisecond = e.millisecond), iR(n), n;
}
function rR(t) {
  t.second += Math.floor(t.millisecond / 1e3), t.millisecond = Tc(t.millisecond, 1e3), t.minute += Math.floor(t.second / 60), t.second = Tc(t.second, 60), t.hour += Math.floor(t.minute / 60), t.minute = Tc(t.minute, 60);
  let e = Math.floor(t.hour / 24);
  return t.hour = Tc(t.hour, 24), e;
}
function iR(t) {
  t.millisecond = Math.max(0, Math.min(t.millisecond, 1e3)), t.second = Math.max(0, Math.min(t.second, 59)), t.minute = Math.max(0, Math.min(t.minute, 59)), t.hour = Math.max(0, Math.min(t.hour, 23));
}
function Tc(t, e) {
  let n = t % e;
  return n < 0 && (n += e), n;
}
function oR(t, e) {
  return t.hour += e.hours || 0, t.minute += e.minutes || 0, t.second += e.seconds || 0, t.millisecond += e.milliseconds || 0, rR(t);
}
function xg(t, e, n, r) {
  let i = t.copy();
  switch (e) {
    case "era": {
      let a = t.calendar.getEras(), c = a.indexOf(t.era);
      if (c < 0) throw new Error("Invalid era: " + t.era);
      c = ai(c, n, 0, a.length - 1, r?.round), i.era = a[c], ko(i);
      break;
    }
    case "year":
      var o, s;
      !((o = (s = i.calendar).isInverseEra) === null || o === void 0) && o.call(s, i) && (n = -n), i.year = ai(t.year, n, -1 / 0, 9999, r?.round), i.year === -1 / 0 && (i.year = 1), i.calendar.balanceYearMonth && i.calendar.balanceYearMonth(i, t);
      break;
    case "month":
      i.month = ai(t.month, n, 1, t.calendar.getMonthsInYear(t), r?.round);
      break;
    case "day":
      i.day = ai(t.day, n, 1, t.calendar.getDaysInMonth(t), r?.round);
      break;
    default:
      throw new Error("Unsupported field " + e);
  }
  return t.calendar.balanceDate && t.calendar.balanceDate(i), ko(i), i;
}
function u3(t, e, n, r) {
  let i = t.copy();
  switch (e) {
    case "hour": {
      let o = t.hour, s = 0, a = 23;
      if (r?.hourCycle === 12) {
        let c = o >= 12;
        s = c ? 12 : 0, a = c ? 23 : 11;
      }
      i.hour = ai(o, n, s, a, r?.round);
      break;
    }
    case "minute":
      i.minute = ai(t.minute, n, 0, 59, r?.round);
      break;
    case "second":
      i.second = ai(t.second, n, 0, 59, r?.round);
      break;
    case "millisecond":
      i.millisecond = ai(t.millisecond, n, 0, 999, r?.round);
      break;
    default:
      throw new Error("Unsupported field " + e);
  }
  return i;
}
function ai(t, e, n, r, i = !1) {
  if (i) {
    t += Math.sign(e), t < n && (t = r);
    let o = Math.abs(e);
    e > 0 ? t = Math.ceil(t / o) * o : t = Math.floor(t / o) * o, t > r && (t = n);
  } else
    t += e, t < n ? t = r - (n - t - 1) : t > r && (t = n + (t - r - 1));
  return t;
}
function h3(t, e) {
  let n;
  if (e.years != null && e.years !== 0 || e.months != null && e.months !== 0 || e.weeks != null && e.weeks !== 0 || e.days != null && e.days !== 0) {
    let i = Ch(Ao(t), {
      years: e.years,
      months: e.months,
      weeks: e.weeks,
      days: e.days
    });
    n = ii(i, t.timeZone);
  } else
    n = Ds(t) - t.offset;
  n += e.milliseconds || 0, n += (e.seconds || 0) * 1e3, n += (e.minutes || 0) * 6e4, n += (e.hours || 0) * 36e5;
  let r = si(n, t.timeZone);
  return or(r, t.calendar);
}
function sR(t, e) {
  return h3(t, l3(e));
}
function aR(t, e, n, r) {
  switch (e) {
    case "hour": {
      let i = 0, o = 23;
      if (r?.hourCycle === 12) {
        let w = t.hour >= 12;
        i = w ? 12 : 0, o = w ? 23 : 11;
      }
      let s = Ao(t), a = or(Du(s, {
        hour: i
      }), new Es()), c = [
        ii(a, t.timeZone, "earlier"),
        ii(a, t.timeZone, "later")
      ].filter((w) => si(w, t.timeZone).day === a.day)[0], h = or(Du(s, {
        hour: o
      }), new Es()), f = [
        ii(h, t.timeZone, "earlier"),
        ii(h, t.timeZone, "later")
      ].filter((w) => si(w, t.timeZone).day === h.day).pop(), d = Ds(t) - t.offset, p = Math.floor(d / Ca), v = d % Ca;
      return d = ai(p, n, Math.floor(c / Ca), Math.floor(f / Ca), r?.round) * Ca + v, or(si(d, t.timeZone), t.calendar);
    }
    case "minute":
    case "second":
    case "millisecond":
      return u3(t, e, n, r);
    case "era":
    case "year":
    case "month":
    case "day": {
      let i = xg(Ao(t), e, n, r), o = ii(i, t.timeZone);
      return or(si(o, t.timeZone), t.calendar);
    }
    default:
      throw new Error("Unsupported field " + e);
  }
}
function lR(t, e, n) {
  let r = Ao(t), i = Du(wg(r, e), e);
  if (i.compare(r) === 0) return t;
  let o = ii(i, t.timeZone, n);
  return or(si(o, t.timeZone), t.calendar);
}
const cR = /^(\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?(?:(?:([+-]\d{2})(?::?(\d{2}))?)|Z)$/;
function f3(t, e) {
  let n = t.match(cR);
  if (!n) throw new Error("Invalid ISO 8601 date time string: " + t);
  let r = new Is(ei(n[1], 1, 9999), ei(n[2], 1, 12), 1, e, 0, n[4] ? ei(n[4], 0, 23) : 0, n[5] ? ei(n[5], 0, 59) : 0, n[6] ? ei(n[6], 0, 59) : 0, n[7] ? ei(n[7], 0, 1 / 0) * 1e3 : 0);
  r.day = ei(n[3], 0, r.calendar.getDaysInMonth(r));
  var i;
  return n[8] && (r.offset = ei(n[8], -23, 23) * 36e5 + ei((i = n[9]) !== null && i !== void 0 ? i : "0", 0, 59) * 6e4), s3(r, e);
}
function uR(t) {
  return f3(t, Os());
}
function ei(t, e, n) {
  let r = Number(t);
  if (r < e || r > n) throw new RangeError(`Value out of range: ${e} <= ${r} <= ${n}`);
  return r;
}
function hR(t) {
  return `${String(t.hour).padStart(2, "0")}:${String(t.minute).padStart(2, "0")}:${String(t.second).padStart(2, "0")}${t.millisecond ? String(t.millisecond / 1e3).slice(1) : ""}`;
}
function d3(t) {
  let e = or(t, new Es());
  return `${String(e.year).padStart(4, "0")}-${String(e.month).padStart(2, "0")}-${String(e.day).padStart(2, "0")}`;
}
function g3(t) {
  return `${d3(t)}T${hR(t)}`;
}
function fR(t) {
  let e = Math.sign(t) < 0 ? "-" : "+";
  t = Math.abs(t);
  let n = Math.floor(t / 36e5), r = t % 36e5 / 6e4;
  return `${e}${String(n).padStart(2, "0")}:${String(r).padStart(2, "0")}`;
}
function dR(t) {
  return `${g3(t)}${fR(t.offset)}[${t.timeZone}]`;
}
function gR(t, e) {
  if (e.has(t))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function yg(t, e, n) {
  gR(t, e), e.set(t, n);
}
function Cg(t) {
  let e = typeof t[0] == "object" ? t.shift() : new Es(), n;
  if (typeof t[0] == "string") n = t.shift();
  else {
    let s = e.getEras();
    n = s[s.length - 1];
  }
  let r = t.shift(), i = t.shift(), o = t.shift();
  return [
    e,
    n,
    r,
    i,
    o
  ];
}
var pR = /* @__PURE__ */ new WeakMap();
class Ka {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new Ka(this.calendar, this.era, this.year, this.month, this.day) : new Ka(this.calendar, this.year, this.month, this.day);
  }
  /** Returns a new `CalendarDate` with the given duration added to it. */
  add(e) {
    return Ch(this, e);
  }
  /** Returns a new `CalendarDate` with the given duration subtracted from it. */
  subtract(e) {
    return c3(this, e);
  }
  /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(e) {
    return wg(this, e);
  }
  /**
  * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(e, n, r) {
    return xg(this, e, n, r);
  }
  /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */
  toDate(e) {
    return i3(this, e);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return d3(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(e) {
    return e3(this, e);
  }
  constructor(...e) {
    yg(this, pR, {
      writable: !0,
      value: void 0
    });
    let [n, r, i, o, s] = Cg(e);
    this.calendar = n, this.era = r, this.year = i, this.month = o, this.day = s, ko(this);
  }
}
var mR = /* @__PURE__ */ new WeakMap();
class Iu {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new Iu(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond) : new Iu(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `CalendarDateTime` with the given duration added to it. */
  add(e) {
    return Ch(this, e);
  }
  /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */
  subtract(e) {
    return c3(this, e);
  }
  /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(e) {
    return wg(Du(this, e), e);
  }
  /**
  * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(e, n, r) {
    switch (e) {
      case "era":
      case "year":
      case "month":
      case "day":
        return xg(this, e, n, r);
      default:
        return u3(this, e, n, r);
    }
  }
  /** Converts the date to a native JavaScript Date object in the given time zone. */
  toDate(e, n) {
    return i3(this, e, n);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return g3(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(e) {
    let n = e3(this, e);
    return n === 0 ? GT(this, Ao(e)) : n;
  }
  constructor(...e) {
    yg(this, mR, {
      writable: !0,
      value: void 0
    });
    let [n, r, i, o, s] = Cg(e);
    this.calendar = n, this.era = r, this.year = i, this.month = o, this.day = s, this.hour = e.shift() || 0, this.minute = e.shift() || 0, this.second = e.shift() || 0, this.millisecond = e.shift() || 0, ko(this);
  }
}
var vR = /* @__PURE__ */ new WeakMap();
class Is {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new Is(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond) : new Is(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `ZonedDateTime` with the given duration added to it. */
  add(e) {
    return h3(this, e);
  }
  /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */
  subtract(e) {
    return sR(this, e);
  }
  /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(e, n) {
    return lR(this, e, n);
  }
  /**
  * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(e, n, r) {
    return aR(this, e, n, r);
  }
  /** Converts the date to a native JavaScript Date object. */
  toDate() {
    return tR(this);
  }
  /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */
  toString() {
    return dR(this);
  }
  /** Converts the date to an ISO 8601 formatted string in UTC. */
  toAbsoluteString() {
    return this.toDate().toISOString();
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(e) {
    return this.toDate().getTime() - eR(e, this.timeZone).toDate().getTime();
  }
  constructor(...e) {
    yg(this, vR, {
      writable: !0,
      value: void 0
    });
    let [n, r, i, o, s] = Cg(e), a = e.shift(), c = e.shift();
    this.calendar = n, this.era = r, this.year = i, this.month = o, this.day = s, this.timeZone = a, this.offset = c, this.hour = e.shift() || 0, this.minute = e.shift() || 0, this.second = e.shift() || 0, this.millisecond = e.shift() || 0, ko(this);
  }
}
let Pd = /* @__PURE__ */ new Map();
class bR {
  /** Formats a date as a string according to the locale and format options passed to the constructor. */
  format(e) {
    return this.formatter.format(e);
  }
  /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */
  formatToParts(e) {
    return this.formatter.formatToParts(e);
  }
  /** Formats a date range as a string. */
  formatRange(e, n) {
    if (typeof this.formatter.formatRange == "function")
      return this.formatter.formatRange(e, n);
    if (n < e) throw new RangeError("End date must be >= start date");
    return `${this.formatter.format(e)} – ${this.formatter.format(n)}`;
  }
  /** Formats a date range as an array of parts. */
  formatRangeToParts(e, n) {
    if (typeof this.formatter.formatRangeToParts == "function")
      return this.formatter.formatRangeToParts(e, n);
    if (n < e) throw new RangeError("End date must be >= start date");
    let r = this.formatter.formatToParts(e), i = this.formatter.formatToParts(n);
    return [
      ...r.map((o) => ({
        ...o,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...i.map((o) => ({
        ...o,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let e = this.formatter.resolvedOptions();
    return yR() && (this.resolvedHourCycle || (this.resolvedHourCycle = CR(e.locale, this.options)), e.hourCycle = this.resolvedHourCycle, e.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12"), e.calendar === "ethiopic-amete-alem" && (e.calendar = "ethioaa"), e;
  }
  constructor(e, n = {}) {
    this.formatter = p3(e, n), this.options = n;
  }
}
const wR = {
  true: {
    // Only Japanese uses the h11 style for 12 hour time. All others use h12.
    ja: "h11"
  },
  false: {}
};
function p3(t, e = {}) {
  if (typeof e.hour12 == "boolean" && xR()) {
    e = {
      ...e
    };
    let i = wR[String(e.hour12)][t.split("-")[0]], o = e.hour12 ? "h12" : "h23";
    e.hourCycle = i ?? o, delete e.hour12;
  }
  let n = t + (e ? Object.entries(e).sort((i, o) => i[0] < o[0] ? -1 : 1).join() : "");
  if (Pd.has(n)) return Pd.get(n);
  let r = new Intl.DateTimeFormat(t, e);
  return Pd.set(n, r), r;
}
let Wd = null;
function xR() {
  return Wd == null && (Wd = new Intl.DateTimeFormat("en-US", {
    hour: "numeric",
    hour12: !1
  }).format(new Date(2020, 2, 3, 0)) === "24"), Wd;
}
let zd = null;
function yR() {
  return zd == null && (zd = new Intl.DateTimeFormat("fr", {
    hour: "numeric",
    hour12: !1
  }).resolvedOptions().hourCycle === "h12"), zd;
}
function CR(t, e) {
  if (!e.timeStyle && !e.hour) return;
  t = t.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, ""), t += (t.includes("-u-") ? "" : "-u") + "-nu-latn";
  let n = p3(t, {
    ...e,
    timeZone: void 0
    // use local timezone
  }), r = parseInt(n.formatToParts(new Date(2020, 2, 3, 0)).find((o) => o.type === "hour").value, 10), i = parseInt(n.formatToParts(new Date(2020, 2, 3, 23)).find((o) => o.type === "hour").value, 10);
  if (r === 0 && i === 23) return "h23";
  if (r === 24 && i === 23) return "h24";
  if (r === 0 && i === 11) return "h11";
  if (r === 12 && i === 11) return "h12";
  throw new Error("Unexpected hour cycle result");
}
function G() {
  return G = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, G.apply(null, arguments);
}
function oe(t, e, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (t?.(i), n === !1 || !i.defaultPrevented) return e?.(i);
  };
}
function $R(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e);
}
function $h(...t) {
  return (e) => t.forEach(
    (n) => $R(n, e)
  );
}
function ke(...t) {
  return rt($h(...t), t);
}
function $g(t, e) {
  const n = /* @__PURE__ */ Ua(e);
  function r(o) {
    const { children: s, ...a } = o, c = So(
      () => a,
      Object.values(a)
    );
    return /* @__PURE__ */ B(n.Provider, {
      value: c
    }, s);
  }
  function i(o) {
    const s = wh(n);
    if (s) return s;
    if (e !== void 0) return e;
    throw new Error(`\`${o}\` must be used within \`${t}\``);
  }
  return r.displayName = t + "Provider", [
    r,
    i
  ];
}
function Tt(t, e = []) {
  let n = [];
  function r(o, s) {
    const a = /* @__PURE__ */ Ua(s), c = n.length;
    n = [
      ...n,
      s
    ];
    function h(d) {
      const { scope: p, children: v, ...w } = d, b = p?.[t][c] || a, y = So(
        () => w,
        Object.values(w)
      );
      return /* @__PURE__ */ B(b.Provider, {
        value: y
      }, v);
    }
    function f(d, p) {
      const v = p?.[t][c] || a, w = wh(v);
      if (w) return w;
      if (s !== void 0) return s;
      throw new Error(`\`${d}\` must be used within \`${o}\``);
    }
    return h.displayName = o + "Provider", [
      h,
      f
    ];
  }
  const i = () => {
    const o = n.map((s) => /* @__PURE__ */ Ua(s));
    return function(a) {
      const c = a?.[t] || o;
      return So(
        () => ({
          [`__scope${t}`]: {
            ...a,
            [t]: c
          }
        }),
        [
          a,
          c
        ]
      );
    };
  };
  return i.scopeName = t, [
    r,
    SR(i, ...e)
  ];
}
function SR(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const r = t.map(
      (i) => ({
        useScope: i(),
        scopeName: i.scopeName
      })
    );
    return function(o) {
      const s = r.reduce((a, { useScope: c, scopeName: h }) => {
        const d = c(o)[`__scope${h}`];
        return {
          ...a,
          ...d
        };
      }, {});
      return So(
        () => ({
          [`__scope${e.scopeName}`]: s
        }),
        [
          s
        ]
      );
    };
  };
  return n.scopeName = e.scopeName, n;
}
const Dr = /* @__PURE__ */ O((t, e) => {
  const { children: n, ...r } = t, i = vo.toArray(n), o = i.find(AR);
  if (o) {
    const s = o.props.children, a = i.map((c) => c === o ? vo.count(s) > 1 ? vo.only(null) : /* @__PURE__ */ Ou(s) ? s.props.children : null : c);
    return /* @__PURE__ */ B(z0, G({}, r, {
      ref: e
    }), /* @__PURE__ */ Ou(s) ? /* @__PURE__ */ mg(s, void 0, a) : null);
  }
  return /* @__PURE__ */ B(z0, G({}, r, {
    ref: e
  }), n);
});
Dr.displayName = "Slot";
const z0 = /* @__PURE__ */ O((t, e) => {
  const { children: n, ...r } = t;
  return /* @__PURE__ */ Ou(n) ? /* @__PURE__ */ mg(n, {
    ...kR(r, n.props),
    ref: e ? $h(e, n.ref) : n.ref
  }) : vo.count(n) > 1 ? vo.only(null) : null;
});
z0.displayName = "SlotClone";
const Sg = ({ children: t }) => /* @__PURE__ */ B(xh, null, t);
function AR(t) {
  return /* @__PURE__ */ Ou(t) && t.type === Sg;
}
function kR(t, e) {
  const n = {
    ...e
  };
  for (const r in e) {
    const i = t[r], o = e[r];
    /^on[A-Z]/.test(r) ? i && o ? n[r] = (...a) => {
      o(...a), i(...a);
    } : i && (n[r] = i) : r === "style" ? n[r] = {
      ...i,
      ...o
    } : r === "className" && (n[r] = [
      i,
      o
    ].filter(Boolean).join(" "));
  }
  return {
    ...t,
    ...n
  };
}
const MR = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], we = MR.reduce((t, e) => {
  const n = /* @__PURE__ */ O((r, i) => {
    const { asChild: o, ...s } = r, a = o ? Dr : e;
    return Ce(() => {
      window[Symbol.for("radix-ui")] = !0;
    }, []), /* @__PURE__ */ B(a, G({}, s, {
      ref: i
    }));
  });
  return n.displayName = `Primitive.${e}`, {
    ...t,
    [e]: n
  };
}, {});
function m3(t, e) {
  t && jw(
    () => t.dispatchEvent(e)
  );
}
function TR(t, e = globalThis?.document) {
  const n = Ot(t);
  Ce(() => {
    const r = (i) => {
      i.key === "Escape" && n(i);
    };
    return e.addEventListener("keydown", r), () => e.removeEventListener("keydown", r);
  }, [
    n,
    e
  ]);
}
const U0 = "dismissableLayer.update", RR = "dismissableLayer.pointerDownOutside", ER = "dismissableLayer.focusOutside";
let Kv;
const OR = /* @__PURE__ */ Ua({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), No = /* @__PURE__ */ O((t, e) => {
  var n;
  const { disableOutsidePointerEvents: r = !1, onEscapeKeyDown: i, onPointerDownOutside: o, onFocusOutside: s, onInteractOutside: a, onDismiss: c, ...h } = t, f = wh(OR), [d, p] = De(null), v = (n = d?.ownerDocument) !== null && n !== void 0 ? n : globalThis?.document, [, w] = De({}), b = ke(
    e,
    (P) => p(P)
  ), y = Array.from(f.layers), [$] = [
    ...f.layersWithOutsidePointerEventsDisabled
  ].slice(-1), A = y.indexOf($), k = d ? y.indexOf(d) : -1, T = f.layersWithOutsidePointerEventsDisabled.size > 0, R = k >= A, _ = DR((P) => {
    const H = P.target, z = [
      ...f.branches
    ].some(
      (j) => j.contains(H)
    );
    !R || z || (o?.(P), a?.(P), P.defaultPrevented || c?.());
  }, v), D = IR((P) => {
    const H = P.target;
    [
      ...f.branches
    ].some(
      (j) => j.contains(H)
    ) || (s?.(P), a?.(P), P.defaultPrevented || c?.());
  }, v);
  return TR((P) => {
    k === f.layers.size - 1 && (i?.(P), !P.defaultPrevented && c && (P.preventDefault(), c()));
  }, v), Ce(() => {
    if (d)
      return r && (f.layersWithOutsidePointerEventsDisabled.size === 0 && (Kv = v.body.style.pointerEvents, v.body.style.pointerEvents = "none"), f.layersWithOutsidePointerEventsDisabled.add(d)), f.layers.add(d), qv(), () => {
        r && f.layersWithOutsidePointerEventsDisabled.size === 1 && (v.body.style.pointerEvents = Kv);
      };
  }, [
    d,
    v,
    r,
    f
  ]), Ce(() => () => {
    d && (f.layers.delete(d), f.layersWithOutsidePointerEventsDisabled.delete(d), qv());
  }, [
    d,
    f
  ]), Ce(() => {
    const P = () => w({});
    return document.addEventListener(U0, P), () => document.removeEventListener(U0, P);
  }, []), /* @__PURE__ */ B(we.div, G({}, h, {
    ref: b,
    style: {
      pointerEvents: T ? R ? "auto" : "none" : void 0,
      ...t.style
    },
    onFocusCapture: oe(t.onFocusCapture, D.onFocusCapture),
    onBlurCapture: oe(t.onBlurCapture, D.onBlurCapture),
    onPointerDownCapture: oe(t.onPointerDownCapture, _.onPointerDownCapture)
  }));
});
function DR(t, e = globalThis?.document) {
  const n = Ot(t), r = ue(!1), i = ue(() => {
  });
  return Ce(() => {
    const o = (a) => {
      if (a.target && !r.current) {
        let h = function() {
          v3(RR, n, c, {
            discrete: !0
          });
        };
        const c = {
          originalEvent: a
        };
        a.pointerType === "touch" ? (e.removeEventListener("click", i.current), i.current = h, e.addEventListener("click", i.current, {
          once: !0
        })) : h();
      } else
        e.removeEventListener("click", i.current);
      r.current = !1;
    }, s = window.setTimeout(() => {
      e.addEventListener("pointerdown", o);
    }, 0);
    return () => {
      window.clearTimeout(s), e.removeEventListener("pointerdown", o), e.removeEventListener("click", i.current);
    };
  }, [
    e,
    n
  ]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function IR(t, e = globalThis?.document) {
  const n = Ot(t), r = ue(!1);
  return Ce(() => {
    const i = (o) => {
      o.target && !r.current && v3(ER, n, {
        originalEvent: o
      }, {
        discrete: !1
      });
    };
    return e.addEventListener("focusin", i), () => e.removeEventListener("focusin", i);
  }, [
    e,
    n
  ]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function qv() {
  const t = new CustomEvent(U0);
  document.dispatchEvent(t);
}
function v3(t, e, n, { discrete: r }) {
  const i = n.originalEvent.target, o = new CustomEvent(t, {
    bubbles: !1,
    cancelable: !0,
    detail: n
  });
  e && i.addEventListener(t, e, {
    once: !0
  }), r ? m3(i, o) : i.dispatchEvent(o);
}
const _R = No, xt = globalThis?.document ? yh : () => {
}, LR = C.useId || (() => {
});
let BR = 0;
function Ut(t) {
  const [e, n] = C.useState(LR());
  return xt(() => {
    n(
      (r) => r ?? String(BR++)
    );
  }, [
    t
  ]), e ? `radix-${e}` : "";
}
const NR = ["top", "right", "bottom", "left"], Hi = Math.min, Bn = Math.max, _u = Math.round, Rc = Math.floor, Rr = (t) => ({
  x: t,
  y: t
}), FR = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, VR = {
  start: "end",
  end: "start"
};
function K0(t, e, n) {
  return Bn(t, Hi(e, n));
}
function hi(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function fi(t) {
  return t.split("-")[0];
}
function js(t) {
  return t.split("-")[1];
}
function Ag(t) {
  return t === "x" ? "y" : "x";
}
function kg(t) {
  return t === "y" ? "height" : "width";
}
function li(t) {
  return ["top", "bottom"].includes(fi(t)) ? "y" : "x";
}
function Mg(t) {
  return Ag(li(t));
}
function HR(t, e, n) {
  n === void 0 && (n = !1);
  const r = js(t), i = Mg(t), o = kg(i);
  let s = i === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[o] > e.floating[o] && (s = Lu(s)), [s, Lu(s)];
}
function PR(t) {
  const e = Lu(t);
  return [q0(t), e, q0(e)];
}
function q0(t) {
  return t.replace(/start|end/g, (e) => VR[e]);
}
function WR(t, e, n) {
  const r = ["left", "right"], i = ["right", "left"], o = ["top", "bottom"], s = ["bottom", "top"];
  switch (t) {
    case "top":
    case "bottom":
      return n ? e ? i : r : e ? r : i;
    case "left":
    case "right":
      return e ? o : s;
    default:
      return [];
  }
}
function zR(t, e, n, r) {
  const i = js(t);
  let o = WR(fi(t), n === "start", r);
  return i && (o = o.map((s) => s + "-" + i), e && (o = o.concat(o.map(q0)))), o;
}
function Lu(t) {
  return t.replace(/left|right|bottom|top/g, (e) => FR[e]);
}
function UR(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function b3(t) {
  return typeof t != "number" ? UR(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function Bu(t) {
  const {
    x: e,
    y: n,
    width: r,
    height: i
  } = t;
  return {
    width: r,
    height: i,
    top: n,
    left: e,
    right: e + r,
    bottom: n + i,
    x: e,
    y: n
  };
}
function Gv(t, e, n) {
  let {
    reference: r,
    floating: i
  } = t;
  const o = li(e), s = Mg(e), a = kg(s), c = fi(e), h = o === "y", f = r.x + r.width / 2 - i.width / 2, d = r.y + r.height / 2 - i.height / 2, p = r[a] / 2 - i[a] / 2;
  let v;
  switch (c) {
    case "top":
      v = {
        x: f,
        y: r.y - i.height
      };
      break;
    case "bottom":
      v = {
        x: f,
        y: r.y + r.height
      };
      break;
    case "right":
      v = {
        x: r.x + r.width,
        y: d
      };
      break;
    case "left":
      v = {
        x: r.x - i.width,
        y: d
      };
      break;
    default:
      v = {
        x: r.x,
        y: r.y
      };
  }
  switch (js(e)) {
    case "start":
      v[s] -= p * (n && h ? -1 : 1);
      break;
    case "end":
      v[s] += p * (n && h ? -1 : 1);
      break;
  }
  return v;
}
const KR = async (t, e, n) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: o = [],
    platform: s
  } = n, a = o.filter(Boolean), c = await (s.isRTL == null ? void 0 : s.isRTL(e));
  let h = await s.getElementRects({
    reference: t,
    floating: e,
    strategy: i
  }), {
    x: f,
    y: d
  } = Gv(h, r, c), p = r, v = {}, w = 0;
  for (let b = 0; b < a.length; b++) {
    const {
      name: y,
      fn: $
    } = a[b], {
      x: A,
      y: k,
      data: T,
      reset: R
    } = await $({
      x: f,
      y: d,
      initialPlacement: r,
      placement: p,
      strategy: i,
      middlewareData: v,
      rects: h,
      platform: s,
      elements: {
        reference: t,
        floating: e
      }
    });
    f = A ?? f, d = k ?? d, v = {
      ...v,
      [y]: {
        ...v[y],
        ...T
      }
    }, R && w <= 50 && (w++, typeof R == "object" && (R.placement && (p = R.placement), R.rects && (h = R.rects === !0 ? await s.getElementRects({
      reference: t,
      floating: e,
      strategy: i
    }) : R.rects), {
      x: f,
      y: d
    } = Gv(h, p, c)), b = -1);
  }
  return {
    x: f,
    y: d,
    placement: p,
    strategy: i,
    middlewareData: v
  };
};
async function qa(t, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: r,
    y: i,
    platform: o,
    rects: s,
    elements: a,
    strategy: c
  } = t, {
    boundary: h = "clippingAncestors",
    rootBoundary: f = "viewport",
    elementContext: d = "floating",
    altBoundary: p = !1,
    padding: v = 0
  } = hi(e, t), w = b3(v), y = a[p ? d === "floating" ? "reference" : "floating" : d], $ = Bu(await o.getClippingRect({
    element: (n = await (o.isElement == null ? void 0 : o.isElement(y))) == null || n ? y : y.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)),
    boundary: h,
    rootBoundary: f,
    strategy: c
  })), A = d === "floating" ? {
    x: r,
    y: i,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, k = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)), T = await (o.isElement == null ? void 0 : o.isElement(k)) ? await (o.getScale == null ? void 0 : o.getScale(k)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, R = Bu(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: A,
    offsetParent: k,
    strategy: c
  }) : A);
  return {
    top: ($.top - R.top + w.top) / T.y,
    bottom: (R.bottom - $.bottom + w.bottom) / T.y,
    left: ($.left - R.left + w.left) / T.x,
    right: (R.right - $.right + w.right) / T.x
  };
}
const qR = (t) => ({
  name: "arrow",
  options: t,
  async fn(e) {
    const {
      x: n,
      y: r,
      placement: i,
      rects: o,
      platform: s,
      elements: a,
      middlewareData: c
    } = e, {
      element: h,
      padding: f = 0
    } = hi(t, e) || {};
    if (h == null)
      return {};
    const d = b3(f), p = {
      x: n,
      y: r
    }, v = Mg(i), w = kg(v), b = await s.getDimensions(h), y = v === "y", $ = y ? "top" : "left", A = y ? "bottom" : "right", k = y ? "clientHeight" : "clientWidth", T = o.reference[w] + o.reference[v] - p[v] - o.floating[w], R = p[v] - o.reference[v], _ = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(h));
    let D = _ ? _[k] : 0;
    (!D || !await (s.isElement == null ? void 0 : s.isElement(_))) && (D = a.floating[k] || o.floating[w]);
    const P = T / 2 - R / 2, H = D / 2 - b[w] / 2 - 1, z = Hi(d[$], H), j = Hi(d[A], H), K = z, te = D - b[w] - j, ee = D / 2 - b[w] / 2 + P, re = K0(K, ee, te), de = !c.arrow && js(i) != null && ee !== re && o.reference[w] / 2 - (ee < K ? z : j) - b[w] / 2 < 0, ie = de ? ee < K ? ee - K : ee - te : 0;
    return {
      [v]: p[v] + ie,
      data: {
        [v]: re,
        centerOffset: ee - re - ie,
        ...de && {
          alignmentOffset: ie
        }
      },
      reset: de
    };
  }
}), GR = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var n, r;
      const {
        placement: i,
        middlewareData: o,
        rects: s,
        initialPlacement: a,
        platform: c,
        elements: h
      } = e, {
        mainAxis: f = !0,
        crossAxis: d = !0,
        fallbackPlacements: p,
        fallbackStrategy: v = "bestFit",
        fallbackAxisSideDirection: w = "none",
        flipAlignment: b = !0,
        ...y
      } = hi(t, e);
      if ((n = o.arrow) != null && n.alignmentOffset)
        return {};
      const $ = fi(i), A = li(a), k = fi(a) === a, T = await (c.isRTL == null ? void 0 : c.isRTL(h.floating)), R = p || (k || !b ? [Lu(a)] : PR(a)), _ = w !== "none";
      !p && _ && R.push(...zR(a, b, w, T));
      const D = [a, ...R], P = await qa(e, y), H = [];
      let z = ((r = o.flip) == null ? void 0 : r.overflows) || [];
      if (f && H.push(P[$]), d) {
        const re = HR(i, s, T);
        H.push(P[re[0]], P[re[1]]);
      }
      if (z = [...z, {
        placement: i,
        overflows: H
      }], !H.every((re) => re <= 0)) {
        var j, K;
        const re = (((j = o.flip) == null ? void 0 : j.index) || 0) + 1, de = D[re];
        if (de) {
          var te;
          const se = d === "alignment" ? A !== li(de) : !1, X = ((te = z[0]) == null ? void 0 : te.overflows[0]) > 0;
          if (!se || X)
            return {
              data: {
                index: re,
                overflows: z
              },
              reset: {
                placement: de
              }
            };
        }
        let ie = (K = z.filter((se) => se.overflows[0] <= 0).sort((se, X) => se.overflows[1] - X.overflows[1])[0]) == null ? void 0 : K.placement;
        if (!ie)
          switch (v) {
            case "bestFit": {
              var ee;
              const se = (ee = z.filter((X) => {
                if (_) {
                  const ce = li(X.placement);
                  return ce === A || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  ce === "y";
                }
                return !0;
              }).map((X) => [X.placement, X.overflows.filter((ce) => ce > 0).reduce((ce, be) => ce + be, 0)]).sort((X, ce) => X[1] - ce[1])[0]) == null ? void 0 : ee[0];
              se && (ie = se);
              break;
            }
            case "initialPlacement":
              ie = a;
              break;
          }
        if (i !== ie)
          return {
            reset: {
              placement: ie
            }
          };
      }
      return {};
    }
  };
};
function Yv(t, e) {
  return {
    top: t.top - e.height,
    right: t.right - e.width,
    bottom: t.bottom - e.height,
    left: t.left - e.width
  };
}
function jv(t) {
  return NR.some((e) => t[e] >= 0);
}
const YR = function(t) {
  return t === void 0 && (t = {}), {
    name: "hide",
    options: t,
    async fn(e) {
      const {
        rects: n
      } = e, {
        strategy: r = "referenceHidden",
        ...i
      } = hi(t, e);
      switch (r) {
        case "referenceHidden": {
          const o = await qa(e, {
            ...i,
            elementContext: "reference"
          }), s = Yv(o, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: jv(s)
            }
          };
        }
        case "escaped": {
          const o = await qa(e, {
            ...i,
            altBoundary: !0
          }), s = Yv(o, n.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: jv(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function jR(t, e) {
  const {
    placement: n,
    platform: r,
    elements: i
  } = t, o = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), s = fi(n), a = js(n), c = li(n) === "y", h = ["left", "top"].includes(s) ? -1 : 1, f = o && c ? -1 : 1, d = hi(e, t);
  let {
    mainAxis: p,
    crossAxis: v,
    alignmentAxis: w
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: d.mainAxis || 0,
    crossAxis: d.crossAxis || 0,
    alignmentAxis: d.alignmentAxis
  };
  return a && typeof w == "number" && (v = a === "end" ? w * -1 : w), c ? {
    x: v * f,
    y: p * h
  } : {
    x: p * h,
    y: v * f
  };
}
const XR = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var n, r;
      const {
        x: i,
        y: o,
        placement: s,
        middlewareData: a
      } = e, c = await jR(e, t);
      return s === ((n = a.offset) == null ? void 0 : n.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : {
        x: i + c.x,
        y: o + c.y,
        data: {
          ...c,
          placement: s
        }
      };
    }
  };
}, ZR = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: n,
        y: r,
        placement: i
      } = e, {
        mainAxis: o = !0,
        crossAxis: s = !1,
        limiter: a = {
          fn: (y) => {
            let {
              x: $,
              y: A
            } = y;
            return {
              x: $,
              y: A
            };
          }
        },
        ...c
      } = hi(t, e), h = {
        x: n,
        y: r
      }, f = await qa(e, c), d = li(fi(i)), p = Ag(d);
      let v = h[p], w = h[d];
      if (o) {
        const y = p === "y" ? "top" : "left", $ = p === "y" ? "bottom" : "right", A = v + f[y], k = v - f[$];
        v = K0(A, v, k);
      }
      if (s) {
        const y = d === "y" ? "top" : "left", $ = d === "y" ? "bottom" : "right", A = w + f[y], k = w - f[$];
        w = K0(A, w, k);
      }
      const b = a.fn({
        ...e,
        [p]: v,
        [d]: w
      });
      return {
        ...b,
        data: {
          x: b.x - n,
          y: b.y - r,
          enabled: {
            [p]: o,
            [d]: s
          }
        }
      };
    }
  };
}, QR = function(t) {
  return t === void 0 && (t = {}), {
    options: t,
    fn(e) {
      const {
        x: n,
        y: r,
        placement: i,
        rects: o,
        middlewareData: s
      } = e, {
        offset: a = 0,
        mainAxis: c = !0,
        crossAxis: h = !0
      } = hi(t, e), f = {
        x: n,
        y: r
      }, d = li(i), p = Ag(d);
      let v = f[p], w = f[d];
      const b = hi(a, e), y = typeof b == "number" ? {
        mainAxis: b,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...b
      };
      if (c) {
        const k = p === "y" ? "height" : "width", T = o.reference[p] - o.floating[k] + y.mainAxis, R = o.reference[p] + o.reference[k] - y.mainAxis;
        v < T ? v = T : v > R && (v = R);
      }
      if (h) {
        var $, A;
        const k = p === "y" ? "width" : "height", T = ["top", "left"].includes(fi(i)), R = o.reference[d] - o.floating[k] + (T && (($ = s.offset) == null ? void 0 : $[d]) || 0) + (T ? 0 : y.crossAxis), _ = o.reference[d] + o.reference[k] + (T ? 0 : ((A = s.offset) == null ? void 0 : A[d]) || 0) - (T ? y.crossAxis : 0);
        w < R ? w = R : w > _ && (w = _);
      }
      return {
        [p]: v,
        [d]: w
      };
    }
  };
}, JR = function(t) {
  return t === void 0 && (t = {}), {
    name: "size",
    options: t,
    async fn(e) {
      var n, r;
      const {
        placement: i,
        rects: o,
        platform: s,
        elements: a
      } = e, {
        apply: c = () => {
        },
        ...h
      } = hi(t, e), f = await qa(e, h), d = fi(i), p = js(i), v = li(i) === "y", {
        width: w,
        height: b
      } = o.floating;
      let y, $;
      d === "top" || d === "bottom" ? (y = d, $ = p === (await (s.isRTL == null ? void 0 : s.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : ($ = d, y = p === "end" ? "top" : "bottom");
      const A = b - f.top - f.bottom, k = w - f.left - f.right, T = Hi(b - f[y], A), R = Hi(w - f[$], k), _ = !e.middlewareData.shift;
      let D = T, P = R;
      if ((n = e.middlewareData.shift) != null && n.enabled.x && (P = k), (r = e.middlewareData.shift) != null && r.enabled.y && (D = A), _ && !p) {
        const z = Bn(f.left, 0), j = Bn(f.right, 0), K = Bn(f.top, 0), te = Bn(f.bottom, 0);
        v ? P = w - 2 * (z !== 0 || j !== 0 ? z + j : Bn(f.left, f.right)) : D = b - 2 * (K !== 0 || te !== 0 ? K + te : Bn(f.top, f.bottom));
      }
      await c({
        ...e,
        availableWidth: P,
        availableHeight: D
      });
      const H = await s.getDimensions(a.floating);
      return w !== H.width || b !== H.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Sh() {
  return typeof window < "u";
}
function Xs(t) {
  return w3(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function Fn(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function Lr(t) {
  var e;
  return (e = (w3(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function w3(t) {
  return Sh() ? t instanceof Node || t instanceof Fn(t).Node : !1;
}
function cr(t) {
  return Sh() ? t instanceof Element || t instanceof Fn(t).Element : !1;
}
function Ir(t) {
  return Sh() ? t instanceof HTMLElement || t instanceof Fn(t).HTMLElement : !1;
}
function Xv(t) {
  return !Sh() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof Fn(t).ShadowRoot;
}
function pl(t) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: r,
    display: i
  } = ur(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !["inline", "contents"].includes(i);
}
function eE(t) {
  return ["table", "td", "th"].includes(Xs(t));
}
function Ah(t) {
  return [":popover-open", ":modal"].some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
function Tg(t) {
  const e = Rg(), n = cr(t) ? ur(t) : t;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function tE(t) {
  let e = Pi(t);
  for (; Ir(e) && !_s(e); ) {
    if (Tg(e))
      return e;
    if (Ah(e))
      return null;
    e = Pi(e);
  }
  return null;
}
function Rg() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function _s(t) {
  return ["html", "body", "#document"].includes(Xs(t));
}
function ur(t) {
  return Fn(t).getComputedStyle(t);
}
function kh(t) {
  return cr(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.scrollX,
    scrollTop: t.scrollY
  };
}
function Pi(t) {
  if (Xs(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    Xv(t) && t.host || // Fallback.
    Lr(t)
  );
  return Xv(e) ? e.host : e;
}
function x3(t) {
  const e = Pi(t);
  return _s(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : Ir(e) && pl(e) ? e : x3(e);
}
function Ga(t, e, n) {
  var r;
  e === void 0 && (e = []), n === void 0 && (n = !0);
  const i = x3(t), o = i === ((r = t.ownerDocument) == null ? void 0 : r.body), s = Fn(i);
  if (o) {
    const a = G0(s);
    return e.concat(s, s.visualViewport || [], pl(i) ? i : [], a && n ? Ga(a) : []);
  }
  return e.concat(i, Ga(i, [], n));
}
function G0(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
function y3(t) {
  const e = ur(t);
  let n = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const i = Ir(t), o = i ? t.offsetWidth : n, s = i ? t.offsetHeight : r, a = _u(n) !== o || _u(r) !== s;
  return a && (n = o, r = s), {
    width: n,
    height: r,
    $: a
  };
}
function Eg(t) {
  return cr(t) ? t : t.contextElement;
}
function Cs(t) {
  const e = Eg(t);
  if (!Ir(e))
    return Rr(1);
  const n = e.getBoundingClientRect(), {
    width: r,
    height: i,
    $: o
  } = y3(e);
  let s = (o ? _u(n.width) : n.width) / r, a = (o ? _u(n.height) : n.height) / i;
  return (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: s,
    y: a
  };
}
const nE = /* @__PURE__ */ Rr(0);
function C3(t) {
  const e = Fn(t);
  return !Rg() || !e.visualViewport ? nE : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function rE(t, e, n) {
  return e === void 0 && (e = !1), !n || e && n !== Fn(t) ? !1 : e;
}
function Mo(t, e, n, r) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const i = t.getBoundingClientRect(), o = Eg(t);
  let s = Rr(1);
  e && (r ? cr(r) && (s = Cs(r)) : s = Cs(t));
  const a = rE(o, n, r) ? C3(o) : Rr(0);
  let c = (i.left + a.x) / s.x, h = (i.top + a.y) / s.y, f = i.width / s.x, d = i.height / s.y;
  if (o) {
    const p = Fn(o), v = r && cr(r) ? Fn(r) : r;
    let w = p, b = G0(w);
    for (; b && r && v !== w; ) {
      const y = Cs(b), $ = b.getBoundingClientRect(), A = ur(b), k = $.left + (b.clientLeft + parseFloat(A.paddingLeft)) * y.x, T = $.top + (b.clientTop + parseFloat(A.paddingTop)) * y.y;
      c *= y.x, h *= y.y, f *= y.x, d *= y.y, c += k, h += T, w = Fn(b), b = G0(w);
    }
  }
  return Bu({
    width: f,
    height: d,
    x: c,
    y: h
  });
}
function Og(t, e) {
  const n = kh(t).scrollLeft;
  return e ? e.left + n : Mo(Lr(t)).left + n;
}
function $3(t, e, n) {
  n === void 0 && (n = !1);
  const r = t.getBoundingClientRect(), i = r.left + e.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    Og(t, r)
  )), o = r.top + e.scrollTop;
  return {
    x: i,
    y: o
  };
}
function iE(t) {
  let {
    elements: e,
    rect: n,
    offsetParent: r,
    strategy: i
  } = t;
  const o = i === "fixed", s = Lr(r), a = e ? Ah(e.floating) : !1;
  if (r === s || a && o)
    return n;
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  }, h = Rr(1);
  const f = Rr(0), d = Ir(r);
  if ((d || !d && !o) && ((Xs(r) !== "body" || pl(s)) && (c = kh(r)), Ir(r))) {
    const v = Mo(r);
    h = Cs(r), f.x = v.x + r.clientLeft, f.y = v.y + r.clientTop;
  }
  const p = s && !d && !o ? $3(s, c, !0) : Rr(0);
  return {
    width: n.width * h.x,
    height: n.height * h.y,
    x: n.x * h.x - c.scrollLeft * h.x + f.x + p.x,
    y: n.y * h.y - c.scrollTop * h.y + f.y + p.y
  };
}
function oE(t) {
  return Array.from(t.getClientRects());
}
function sE(t) {
  const e = Lr(t), n = kh(t), r = t.ownerDocument.body, i = Bn(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), o = Bn(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + Og(t);
  const a = -n.scrollTop;
  return ur(r).direction === "rtl" && (s += Bn(e.clientWidth, r.clientWidth) - i), {
    width: i,
    height: o,
    x: s,
    y: a
  };
}
function aE(t, e) {
  const n = Fn(t), r = Lr(t), i = n.visualViewport;
  let o = r.clientWidth, s = r.clientHeight, a = 0, c = 0;
  if (i) {
    o = i.width, s = i.height;
    const h = Rg();
    (!h || h && e === "fixed") && (a = i.offsetLeft, c = i.offsetTop);
  }
  return {
    width: o,
    height: s,
    x: a,
    y: c
  };
}
function lE(t, e) {
  const n = Mo(t, !0, e === "fixed"), r = n.top + t.clientTop, i = n.left + t.clientLeft, o = Ir(t) ? Cs(t) : Rr(1), s = t.clientWidth * o.x, a = t.clientHeight * o.y, c = i * o.x, h = r * o.y;
  return {
    width: s,
    height: a,
    x: c,
    y: h
  };
}
function Zv(t, e, n) {
  let r;
  if (e === "viewport")
    r = aE(t, n);
  else if (e === "document")
    r = sE(Lr(t));
  else if (cr(e))
    r = lE(e, n);
  else {
    const i = C3(t);
    r = {
      x: e.x - i.x,
      y: e.y - i.y,
      width: e.width,
      height: e.height
    };
  }
  return Bu(r);
}
function S3(t, e) {
  const n = Pi(t);
  return n === e || !cr(n) || _s(n) ? !1 : ur(n).position === "fixed" || S3(n, e);
}
function cE(t, e) {
  const n = e.get(t);
  if (n)
    return n;
  let r = Ga(t, [], !1).filter((a) => cr(a) && Xs(a) !== "body"), i = null;
  const o = ur(t).position === "fixed";
  let s = o ? Pi(t) : t;
  for (; cr(s) && !_s(s); ) {
    const a = ur(s), c = Tg(s);
    !c && a.position === "fixed" && (i = null), (o ? !c && !i : !c && a.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || pl(s) && !c && S3(t, s)) ? r = r.filter((f) => f !== s) : i = a, s = Pi(s);
  }
  return e.set(t, r), r;
}
function uE(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: r,
    strategy: i
  } = t;
  const s = [...n === "clippingAncestors" ? Ah(e) ? [] : cE(e, this._c) : [].concat(n), r], a = s[0], c = s.reduce((h, f) => {
    const d = Zv(e, f, i);
    return h.top = Bn(d.top, h.top), h.right = Hi(d.right, h.right), h.bottom = Hi(d.bottom, h.bottom), h.left = Bn(d.left, h.left), h;
  }, Zv(e, a, i));
  return {
    width: c.right - c.left,
    height: c.bottom - c.top,
    x: c.left,
    y: c.top
  };
}
function hE(t) {
  const {
    width: e,
    height: n
  } = y3(t);
  return {
    width: e,
    height: n
  };
}
function fE(t, e, n) {
  const r = Ir(e), i = Lr(e), o = n === "fixed", s = Mo(t, !0, o, e);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const c = Rr(0);
  function h() {
    c.x = Og(i);
  }
  if (r || !r && !o)
    if ((Xs(e) !== "body" || pl(i)) && (a = kh(e)), r) {
      const v = Mo(e, !0, o, e);
      c.x = v.x + e.clientLeft, c.y = v.y + e.clientTop;
    } else i && h();
  o && !r && i && h();
  const f = i && !r && !o ? $3(i, a) : Rr(0), d = s.left + a.scrollLeft - c.x - f.x, p = s.top + a.scrollTop - c.y - f.y;
  return {
    x: d,
    y: p,
    width: s.width,
    height: s.height
  };
}
function Ud(t) {
  return ur(t).position === "static";
}
function Qv(t, e) {
  if (!Ir(t) || ur(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let n = t.offsetParent;
  return Lr(t) === n && (n = n.ownerDocument.body), n;
}
function A3(t, e) {
  const n = Fn(t);
  if (Ah(t))
    return n;
  if (!Ir(t)) {
    let i = Pi(t);
    for (; i && !_s(i); ) {
      if (cr(i) && !Ud(i))
        return i;
      i = Pi(i);
    }
    return n;
  }
  let r = Qv(t, e);
  for (; r && eE(r) && Ud(r); )
    r = Qv(r, e);
  return r && _s(r) && Ud(r) && !Tg(r) ? n : r || tE(t) || n;
}
const dE = async function(t) {
  const e = this.getOffsetParent || A3, n = this.getDimensions, r = await n(t.floating);
  return {
    reference: fE(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function gE(t) {
  return ur(t).direction === "rtl";
}
const pE = {
  convertOffsetParentRelativeRectToViewportRelativeRect: iE,
  getDocumentElement: Lr,
  getClippingRect: uE,
  getOffsetParent: A3,
  getElementRects: dE,
  getClientRects: oE,
  getDimensions: hE,
  getScale: Cs,
  isElement: cr,
  isRTL: gE
};
function k3(t, e) {
  return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height;
}
function mE(t, e) {
  let n = null, r;
  const i = Lr(t);
  function o() {
    var a;
    clearTimeout(r), (a = n) == null || a.disconnect(), n = null;
  }
  function s(a, c) {
    a === void 0 && (a = !1), c === void 0 && (c = 1), o();
    const h = t.getBoundingClientRect(), {
      left: f,
      top: d,
      width: p,
      height: v
    } = h;
    if (a || e(), !p || !v)
      return;
    const w = Rc(d), b = Rc(i.clientWidth - (f + p)), y = Rc(i.clientHeight - (d + v)), $ = Rc(f), k = {
      rootMargin: -w + "px " + -b + "px " + -y + "px " + -$ + "px",
      threshold: Bn(0, Hi(1, c)) || 1
    };
    let T = !0;
    function R(_) {
      const D = _[0].intersectionRatio;
      if (D !== c) {
        if (!T)
          return s();
        D ? s(!1, D) : r = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      D === 1 && !k3(h, t.getBoundingClientRect()) && s(), T = !1;
    }
    try {
      n = new IntersectionObserver(R, {
        ...k,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(R, k);
    }
    n.observe(t);
  }
  return s(!0), o;
}
function M3(t, e, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: o = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: c = !1
  } = r, h = Eg(t), f = i || o ? [...h ? Ga(h) : [], ...Ga(e)] : [];
  f.forEach(($) => {
    i && $.addEventListener("scroll", n, {
      passive: !0
    }), o && $.addEventListener("resize", n);
  });
  const d = h && a ? mE(h, n) : null;
  let p = -1, v = null;
  s && (v = new ResizeObserver(($) => {
    let [A] = $;
    A && A.target === h && v && (v.unobserve(e), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var k;
      (k = v) == null || k.observe(e);
    })), n();
  }), h && !c && v.observe(h), v.observe(e));
  let w, b = c ? Mo(t) : null;
  c && y();
  function y() {
    const $ = Mo(t);
    b && !k3(b, $) && n(), b = $, w = requestAnimationFrame(y);
  }
  return n(), () => {
    var $;
    f.forEach((A) => {
      i && A.removeEventListener("scroll", n), o && A.removeEventListener("resize", n);
    }), d?.(), ($ = v) == null || $.disconnect(), v = null, c && cancelAnimationFrame(w);
  };
}
const T3 = XR, R3 = ZR, E3 = GR, vE = JR, bE = YR, Jv = qR, wE = QR, O3 = (t, e, n) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: pE,
    ...n
  }, o = {
    ...i.platform,
    _c: r
  };
  return KR(t, e, {
    ...i,
    platform: o
  });
};
var mu = typeof document < "u" ? yh : Ce;
function Nu(t, e) {
  if (t === e)
    return !0;
  if (typeof t != typeof e)
    return !1;
  if (typeof t == "function" && t.toString() === e.toString())
    return !0;
  let n, r, i;
  if (t && e && typeof t == "object") {
    if (Array.isArray(t)) {
      if (n = t.length, n !== e.length) return !1;
      for (r = n; r-- !== 0; )
        if (!Nu(t[r], e[r]))
          return !1;
      return !0;
    }
    if (i = Object.keys(t), n = i.length, n !== Object.keys(e).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(e, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const o = i[r];
      if (!(o === "_owner" && t.$$typeof) && !Nu(t[o], e[o]))
        return !1;
    }
    return !0;
  }
  return t !== t && e !== e;
}
function D3(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function e5(t, e) {
  const n = D3(t);
  return Math.round(e * n) / n;
}
function Kd(t) {
  const e = C.useRef(t);
  return mu(() => {
    e.current = t;
  }), e;
}
function xE(t) {
  t === void 0 && (t = {});
  const {
    placement: e = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: i,
    elements: {
      reference: o,
      floating: s
    } = {},
    transform: a = !0,
    whileElementsMounted: c,
    open: h
  } = t, [f, d] = C.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: e,
    middlewareData: {},
    isPositioned: !1
  }), [p, v] = C.useState(r);
  Nu(p, r) || v(r);
  const [w, b] = C.useState(null), [y, $] = C.useState(null), A = C.useCallback((se) => {
    se !== _.current && (_.current = se, b(se));
  }, []), k = C.useCallback((se) => {
    se !== D.current && (D.current = se, $(se));
  }, []), T = o || w, R = s || y, _ = C.useRef(null), D = C.useRef(null), P = C.useRef(f), H = c != null, z = Kd(c), j = Kd(i), K = Kd(h), te = C.useCallback(() => {
    if (!_.current || !D.current)
      return;
    const se = {
      placement: e,
      strategy: n,
      middleware: p
    };
    j.current && (se.platform = j.current), O3(_.current, D.current, se).then((X) => {
      const ce = {
        ...X,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: K.current !== !1
      };
      ee.current && !Nu(P.current, ce) && (P.current = ce, Ys.flushSync(() => {
        d(ce);
      }));
    });
  }, [p, e, n, j, K]);
  mu(() => {
    h === !1 && P.current.isPositioned && (P.current.isPositioned = !1, d((se) => ({
      ...se,
      isPositioned: !1
    })));
  }, [h]);
  const ee = C.useRef(!1);
  mu(() => (ee.current = !0, () => {
    ee.current = !1;
  }), []), mu(() => {
    if (T && (_.current = T), R && (D.current = R), T && R) {
      if (z.current)
        return z.current(T, R, te);
      te();
    }
  }, [T, R, te, z, H]);
  const re = C.useMemo(() => ({
    reference: _,
    floating: D,
    setReference: A,
    setFloating: k
  }), [A, k]), de = C.useMemo(() => ({
    reference: T,
    floating: R
  }), [T, R]), ie = C.useMemo(() => {
    const se = {
      position: n,
      left: 0,
      top: 0
    };
    if (!de.floating)
      return se;
    const X = e5(de.floating, f.x), ce = e5(de.floating, f.y);
    return a ? {
      ...se,
      transform: "translate(" + X + "px, " + ce + "px)",
      ...D3(de.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: X,
      top: ce
    };
  }, [n, a, de.floating, f.x, f.y]);
  return C.useMemo(() => ({
    ...f,
    update: te,
    refs: re,
    elements: de,
    floatingStyles: ie
  }), [f, te, re, de, ie]);
}
const yE = (t) => {
  function e(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: t,
    fn(n) {
      const {
        element: r,
        padding: i
      } = typeof t == "function" ? t(n) : t;
      return r && e(r) ? r.current != null ? Jv({
        element: r.current,
        padding: i
      }).fn(n) : {} : r ? Jv({
        element: r,
        padding: i
      }).fn(n) : {};
    }
  };
}, CE = (t, e) => ({
  ...T3(t),
  options: [t, e]
}), $E = (t, e) => ({
  ...R3(t),
  options: [t, e]
}), SE = (t, e) => ({
  ...wE(t),
  options: [t, e]
}), AE = (t, e) => ({
  ...E3(t),
  options: [t, e]
}), kE = (t, e) => ({
  ...vE(t),
  options: [t, e]
}), ME = (t, e) => ({
  ...bE(t),
  options: [t, e]
}), TE = (t, e) => ({
  ...yE(t),
  options: [t, e]
}), RE = /* @__PURE__ */ O((t, e) => {
  const { children: n, width: r = 10, height: i = 5, ...o } = t;
  return /* @__PURE__ */ B(we.svg, G({}, o, {
    ref: e,
    width: r,
    height: i,
    viewBox: "0 0 30 10",
    preserveAspectRatio: "none"
  }), t.asChild ? n : /* @__PURE__ */ B("polygon", {
    points: "0,0 30,0 15,10"
  }));
}), EE = RE;
function Mh(t) {
  const [e, n] = De(void 0);
  return xt(() => {
    if (t) {
      n({
        width: t.offsetWidth,
        height: t.offsetHeight
      });
      const r = new ResizeObserver((i) => {
        if (!Array.isArray(i) || !i.length) return;
        const o = i[0];
        let s, a;
        if ("borderBoxSize" in o) {
          const c = o.borderBoxSize, h = Array.isArray(c) ? c[0] : c;
          s = h.inlineSize, a = h.blockSize;
        } else
          s = t.offsetWidth, a = t.offsetHeight;
        n({
          width: s,
          height: a
        });
      });
      return r.observe(t, {
        box: "border-box"
      }), () => r.unobserve(t);
    } else
      n(void 0);
  }, [
    t
  ]), e;
}
const I3 = "Popper", [_3, Yi] = Tt(I3), [OE, L3] = _3(I3), DE = (t) => {
  const { __scopePopper: e, children: n } = t, [r, i] = De(null);
  return /* @__PURE__ */ B(OE, {
    scope: e,
    anchor: r,
    onAnchorChange: i
  }, n);
}, IE = "PopperAnchor", _E = /* @__PURE__ */ O((t, e) => {
  const { __scopePopper: n, virtualRef: r, ...i } = t, o = L3(IE, n), s = ue(null), a = ke(e, s);
  return Ce(() => {
    o.onAnchorChange(r?.current || s.current);
  }), r ? null : /* @__PURE__ */ B(we.div, G({}, i, {
    ref: a
  }));
}), B3 = "PopperContent", [LE, BE] = _3(B3), NE = /* @__PURE__ */ O((t, e) => {
  var n, r, i, o, s, a, c, h;
  const { __scopePopper: f, side: d = "bottom", sideOffset: p = 0, align: v = "center", alignOffset: w = 0, arrowPadding: b = 0, avoidCollisions: y = !0, collisionBoundary: $ = [], collisionPadding: A = 0, sticky: k = "partial", hideWhenDetached: T = !1, updatePositionStrategy: R = "optimized", onPlaced: _, ...D } = t, P = L3(B3, f), [H, z] = De(null), j = ke(
    e,
    (Qe) => z(Qe)
  ), [K, te] = De(null), ee = Mh(K), re = (n = ee?.width) !== null && n !== void 0 ? n : 0, de = (r = ee?.height) !== null && r !== void 0 ? r : 0, ie = d + (v !== "center" ? "-" + v : ""), se = typeof A == "number" ? A : {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...A
  }, X = Array.isArray($) ? $ : [
    $
  ], ce = X.length > 0, be = {
    padding: se,
    boundary: X.filter(PE),
    // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
    altBoundary: ce
  }, { refs: Le, floatingStyles: Ae, placement: qe, isPositioned: He, middlewareData: Ze } = xE({
    // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
    strategy: "fixed",
    placement: ie,
    whileElementsMounted: (...Qe) => M3(...Qe, {
      animationFrame: R === "always"
    }),
    elements: {
      reference: P.anchor
    },
    middleware: [
      CE({
        mainAxis: p + de,
        alignmentAxis: w
      }),
      y && $E({
        mainAxis: !0,
        crossAxis: !1,
        limiter: k === "partial" ? SE() : void 0,
        ...be
      }),
      y && AE({
        ...be
      }),
      kE({
        ...be,
        apply: ({ elements: Qe, rects: an, availableWidth: Ct, availableHeight: Uo }) => {
          const { width: Ko, height: Pr } = an.reference, It = Qe.floating.style;
          It.setProperty("--radix-popper-available-width", `${Ct}px`), It.setProperty("--radix-popper-available-height", `${Uo}px`), It.setProperty("--radix-popper-anchor-width", `${Ko}px`), It.setProperty("--radix-popper-anchor-height", `${Pr}px`);
        }
      }),
      K && TE({
        element: K,
        padding: b
      }),
      WE({
        arrowWidth: re,
        arrowHeight: de
      }),
      T && ME({
        strategy: "referenceHidden",
        ...be
      })
    ]
  }), [xe, Ve] = N3(qe), Oe = Ot(_);
  xt(() => {
    He && Oe?.();
  }, [
    He,
    Oe
  ]);
  const Ue = (i = Ze.arrow) === null || i === void 0 ? void 0 : i.x, Ee = (o = Ze.arrow) === null || o === void 0 ? void 0 : o.y, je = ((s = Ze.arrow) === null || s === void 0 ? void 0 : s.centerOffset) !== 0, [Rt, at] = De();
  return xt(() => {
    H && at(window.getComputedStyle(H).zIndex);
  }, [
    H
  ]), /* @__PURE__ */ B("div", {
    ref: Le.setFloating,
    "data-radix-popper-content-wrapper": "",
    style: {
      ...Ae,
      transform: He ? Ae.transform : "translate(0, -200%)",
      // keep off the page when measuring
      minWidth: "max-content",
      zIndex: Rt,
      "--radix-popper-transform-origin": [
        (a = Ze.transformOrigin) === null || a === void 0 ? void 0 : a.x,
        (c = Ze.transformOrigin) === null || c === void 0 ? void 0 : c.y
      ].join(" ")
    },
    dir: t.dir
  }, /* @__PURE__ */ B(LE, {
    scope: f,
    placedSide: xe,
    onArrowChange: te,
    arrowX: Ue,
    arrowY: Ee,
    shouldHideArrow: je
  }, /* @__PURE__ */ B(we.div, G({
    "data-side": xe,
    "data-align": Ve
  }, D, {
    ref: j,
    style: {
      ...D.style,
      // if the PopperContent hasn't been placed yet (not all measurements done)
      // we prevent animations so that users's animation don't kick in too early referring wrong sides
      animation: He ? void 0 : "none",
      // hide the content if using the hide middleware and should be hidden
      opacity: (h = Ze.hide) !== null && h !== void 0 && h.referenceHidden ? 0 : void 0
    }
  }))));
}), FE = "PopperArrow", VE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, HE = /* @__PURE__ */ O(function(e, n) {
  const { __scopePopper: r, ...i } = e, o = BE(FE, r), s = VE[o.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ B("span", {
      ref: o.onArrowChange,
      style: {
        position: "absolute",
        left: o.arrowX,
        top: o.arrowY,
        [s]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0"
        }[o.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: "rotate(180deg)",
          left: "translateY(50%) rotate(-90deg) translateX(50%)"
        }[o.placedSide],
        visibility: o.shouldHideArrow ? "hidden" : void 0
      }
    }, /* @__PURE__ */ B(EE, G({}, i, {
      ref: n,
      style: {
        ...i.style,
        // ensures the element can be measured correctly (mostly for if SVG)
        display: "block"
      }
    })))
  );
});
function PE(t) {
  return t !== null;
}
const WE = (t) => ({
  name: "transformOrigin",
  options: t,
  fn(e) {
    var n, r, i, o, s;
    const { placement: a, rects: c, middlewareData: h } = e, d = ((n = h.arrow) === null || n === void 0 ? void 0 : n.centerOffset) !== 0, p = d ? 0 : t.arrowWidth, v = d ? 0 : t.arrowHeight, [w, b] = N3(a), y = {
      start: "0%",
      center: "50%",
      end: "100%"
    }[b], $ = ((r = (i = h.arrow) === null || i === void 0 ? void 0 : i.x) !== null && r !== void 0 ? r : 0) + p / 2, A = ((o = (s = h.arrow) === null || s === void 0 ? void 0 : s.y) !== null && o !== void 0 ? o : 0) + v / 2;
    let k = "", T = "";
    return w === "bottom" ? (k = d ? y : `${$}px`, T = `${-v}px`) : w === "top" ? (k = d ? y : `${$}px`, T = `${c.floating.height + v}px`) : w === "right" ? (k = `${-v}px`, T = d ? y : `${A}px`) : w === "left" && (k = `${c.floating.width + v}px`, T = d ? y : `${A}px`), {
      data: {
        x: k,
        y: T
      }
    };
  }
});
function N3(t) {
  const [e, n = "center"] = t.split("-");
  return [
    e,
    n
  ];
}
const ml = DE, vl = _E, bl = NE, zE = HE, Zs = /* @__PURE__ */ O((t, e) => {
  var n;
  const { container: r = globalThis == null || (n = globalThis.document) === null || n === void 0 ? void 0 : n.body, ...i } = t;
  return r ? /* @__PURE__ */ WT.createPortal(/* @__PURE__ */ B(we.div, G({}, i, {
    ref: e
  })), r) : null;
});
function UE(t, e) {
  return Yw((n, r) => {
    const i = e[n][r];
    return i ?? n;
  }, t);
}
const Vt = (t) => {
  const { present: e, children: n } = t, r = KE(e), i = typeof n == "function" ? n({
    present: r.isPresent
  }) : vo.only(n), o = ke(r.ref, i.ref);
  return typeof n == "function" || r.isPresent ? /* @__PURE__ */ mg(i, {
    ref: o
  }) : null;
};
Vt.displayName = "Presence";
function KE(t) {
  const [e, n] = De(), r = ue({}), i = ue(t), o = ue("none"), s = t ? "mounted" : "unmounted", [a, c] = UE(s, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return Ce(() => {
    const h = Ec(r.current);
    o.current = a === "mounted" ? h : "none";
  }, [
    a
  ]), xt(() => {
    const h = r.current, f = i.current;
    if (f !== t) {
      const p = o.current, v = Ec(h);
      t ? c("MOUNT") : v === "none" || h?.display === "none" ? c("UNMOUNT") : c(f && p !== v ? "ANIMATION_OUT" : "UNMOUNT"), i.current = t;
    }
  }, [
    t,
    c
  ]), xt(() => {
    if (e) {
      const h = (d) => {
        const v = Ec(r.current).includes(d.animationName);
        d.target === e && v && jw(
          () => c("ANIMATION_END")
        );
      }, f = (d) => {
        d.target === e && (o.current = Ec(r.current));
      };
      return e.addEventListener("animationstart", f), e.addEventListener("animationcancel", h), e.addEventListener("animationend", h), () => {
        e.removeEventListener("animationstart", f), e.removeEventListener("animationcancel", h), e.removeEventListener("animationend", h);
      };
    } else
      c("ANIMATION_END");
  }, [
    e,
    c
  ]), {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(a),
    ref: rt((h) => {
      h && (r.current = getComputedStyle(h)), n(h);
    }, [])
  };
}
function Ec(t) {
  return t?.animationName || "none";
}
function zt({ prop: t, defaultProp: e, onChange: n = () => {
} }) {
  const [r, i] = qE({
    defaultProp: e,
    onChange: n
  }), o = t !== void 0, s = o ? t : r, a = Ot(n), c = rt((h) => {
    if (o) {
      const d = typeof h == "function" ? h(t) : h;
      d !== t && a(d);
    } else i(h);
  }, [
    o,
    t,
    i,
    a
  ]);
  return [
    s,
    c
  ];
}
function qE({ defaultProp: t, onChange: e }) {
  const n = De(t), [r] = n, i = ue(r), o = Ot(e);
  return Ce(() => {
    i.current !== r && (o(r), i.current = r);
  }, [
    r,
    i,
    o
  ]), n;
}
const F3 = /* @__PURE__ */ O((t, e) => /* @__PURE__ */ B(we.span, G({}, t, {
  ref: e,
  style: {
    // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
    position: "absolute",
    border: 0,
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal",
    ...t.style
  }
}))), GE = F3, [Th, Jee] = Tt("Tooltip", [
  Yi
]), Dg = Yi(), YE = "TooltipProvider", jE = 700, Y0 = "tooltip.open", [XE, Ig] = Th(YE), ZE = (t) => {
  const { __scopeTooltip: e, delayDuration: n = jE, skipDelayDuration: r = 300, disableHoverableContent: i = !1, children: o } = t, [s, a] = De(!0), c = ue(!1), h = ue(0);
  return Ce(() => {
    const f = h.current;
    return () => window.clearTimeout(f);
  }, []), /* @__PURE__ */ B(XE, {
    scope: e,
    isOpenDelayed: s,
    delayDuration: n,
    onOpen: rt(() => {
      window.clearTimeout(h.current), a(!1);
    }, []),
    onClose: rt(() => {
      window.clearTimeout(h.current), h.current = window.setTimeout(
        () => a(!0),
        r
      );
    }, [
      r
    ]),
    isPointerInTransitRef: c,
    onPointerInTransitChange: rt((f) => {
      c.current = f;
    }, []),
    disableHoverableContent: i
  }, o);
}, _g = "Tooltip", [QE, wl] = Th(_g), JE = (t) => {
  const { __scopeTooltip: e, children: n, open: r, defaultOpen: i = !1, onOpenChange: o, disableHoverableContent: s, delayDuration: a } = t, c = Ig(_g, t.__scopeTooltip), h = Dg(e), [f, d] = De(null), p = Ut(), v = ue(0), w = s ?? c.disableHoverableContent, b = a ?? c.delayDuration, y = ue(!1), [$ = !1, A] = zt({
    prop: r,
    defaultProp: i,
    onChange: (D) => {
      D ? (c.onOpen(), document.dispatchEvent(new CustomEvent(Y0))) : c.onClose(), o?.(D);
    }
  }), k = So(() => $ ? y.current ? "delayed-open" : "instant-open" : "closed", [
    $
  ]), T = rt(() => {
    window.clearTimeout(v.current), y.current = !1, A(!0);
  }, [
    A
  ]), R = rt(() => {
    window.clearTimeout(v.current), A(!1);
  }, [
    A
  ]), _ = rt(() => {
    window.clearTimeout(v.current), v.current = window.setTimeout(() => {
      y.current = !0, A(!0);
    }, b);
  }, [
    b,
    A
  ]);
  return Ce(() => () => window.clearTimeout(v.current), []), /* @__PURE__ */ B(ml, h, /* @__PURE__ */ B(QE, {
    scope: e,
    contentId: p,
    open: $,
    stateAttribute: k,
    trigger: f,
    onTriggerChange: d,
    onTriggerEnter: rt(() => {
      c.isOpenDelayed ? _() : T();
    }, [
      c.isOpenDelayed,
      _,
      T
    ]),
    onTriggerLeave: rt(() => {
      w ? R() : window.clearTimeout(v.current);
    }, [
      R,
      w
    ]),
    onOpen: T,
    onClose: R,
    disableHoverableContent: w
  }, n));
}, t5 = "TooltipTrigger", eO = /* @__PURE__ */ O((t, e) => {
  const { __scopeTooltip: n, ...r } = t, i = wl(t5, n), o = Ig(t5, n), s = Dg(n), a = ue(null), c = ke(e, a, i.onTriggerChange), h = ue(!1), f = ue(!1), d = rt(
    () => h.current = !1,
    []
  );
  return Ce(() => () => document.removeEventListener("pointerup", d), [
    d
  ]), /* @__PURE__ */ B(vl, G({
    asChild: !0
  }, s), /* @__PURE__ */ B(we.button, G({
    // We purposefully avoid adding `type=button` here because tooltip triggers are also
    // commonly anchors and the anchor `type` attribute signifies MIME type.
    "aria-describedby": i.open ? i.contentId : void 0,
    "data-state": i.stateAttribute
  }, r, {
    ref: c,
    onPointerMove: oe(t.onPointerMove, (p) => {
      p.pointerType !== "touch" && !f.current && !o.isPointerInTransitRef.current && (i.onTriggerEnter(), f.current = !0);
    }),
    onPointerLeave: oe(t.onPointerLeave, () => {
      i.onTriggerLeave(), f.current = !1;
    }),
    onPointerDown: oe(t.onPointerDown, () => {
      h.current = !0, document.addEventListener("pointerup", d, {
        once: !0
      });
    }),
    onFocus: oe(t.onFocus, () => {
      h.current || i.onOpen();
    }),
    onBlur: oe(t.onBlur, i.onClose),
    onClick: oe(t.onClick, i.onClose)
  })));
}), V3 = "TooltipPortal", [tO, nO] = Th(V3, {
  forceMount: void 0
}), rO = (t) => {
  const { __scopeTooltip: e, forceMount: n, children: r, container: i } = t, o = wl(V3, e);
  return /* @__PURE__ */ B(tO, {
    scope: e,
    forceMount: n
  }, /* @__PURE__ */ B(Vt, {
    present: n || o.open
  }, /* @__PURE__ */ B(Zs, {
    asChild: !0,
    container: i
  }, r)));
}, Ya = "TooltipContent", iO = /* @__PURE__ */ O((t, e) => {
  const n = nO(Ya, t.__scopeTooltip), { forceMount: r = n.forceMount, side: i = "top", ...o } = t, s = wl(Ya, t.__scopeTooltip);
  return /* @__PURE__ */ B(Vt, {
    present: r || s.open
  }, s.disableHoverableContent ? /* @__PURE__ */ B(H3, G({
    side: i
  }, o, {
    ref: e
  })) : /* @__PURE__ */ B(oO, G({
    side: i
  }, o, {
    ref: e
  })));
}), oO = /* @__PURE__ */ O((t, e) => {
  const n = wl(Ya, t.__scopeTooltip), r = Ig(Ya, t.__scopeTooltip), i = ue(null), o = ke(e, i), [s, a] = De(null), { trigger: c, onClose: h } = n, f = i.current, { onPointerInTransitChange: d } = r, p = rt(() => {
    a(null), d(!1);
  }, [
    d
  ]), v = rt((w, b) => {
    const y = w.currentTarget, $ = {
      x: w.clientX,
      y: w.clientY
    }, A = aO($, y.getBoundingClientRect()), k = lO($, A), T = cO(b.getBoundingClientRect()), R = hO([
      ...k,
      ...T
    ]);
    a(R), d(!0);
  }, [
    d
  ]);
  return Ce(() => () => p(), [
    p
  ]), Ce(() => {
    if (c && f) {
      const w = (y) => v(y, f), b = (y) => v(y, c);
      return c.addEventListener("pointerleave", w), f.addEventListener("pointerleave", b), () => {
        c.removeEventListener("pointerleave", w), f.removeEventListener("pointerleave", b);
      };
    }
  }, [
    c,
    f,
    v,
    p
  ]), Ce(() => {
    if (s) {
      const w = (b) => {
        const y = b.target, $ = {
          x: b.clientX,
          y: b.clientY
        }, A = c?.contains(y) || f?.contains(y), k = !uO($, s);
        A ? p() : k && (p(), h());
      };
      return document.addEventListener("pointermove", w), () => document.removeEventListener("pointermove", w);
    }
  }, [
    c,
    f,
    s,
    h,
    p
  ]), /* @__PURE__ */ B(H3, G({}, t, {
    ref: o
  }));
}), [sO, ete] = Th(_g, {
  isInside: !1
}), H3 = /* @__PURE__ */ O((t, e) => {
  const { __scopeTooltip: n, children: r, "aria-label": i, onEscapeKeyDown: o, onPointerDownOutside: s, ...a } = t, c = wl(Ya, n), h = Dg(n), { onClose: f } = c;
  return Ce(() => (document.addEventListener(Y0, f), () => document.removeEventListener(Y0, f)), [
    f
  ]), Ce(() => {
    if (c.trigger) {
      const d = (p) => {
        const v = p.target;
        v != null && v.contains(c.trigger) && f();
      };
      return window.addEventListener("scroll", d, {
        capture: !0
      }), () => window.removeEventListener("scroll", d, {
        capture: !0
      });
    }
  }, [
    c.trigger,
    f
  ]), /* @__PURE__ */ B(No, {
    asChild: !0,
    disableOutsidePointerEvents: !1,
    onEscapeKeyDown: o,
    onPointerDownOutside: s,
    onFocusOutside: (d) => d.preventDefault(),
    onDismiss: f
  }, /* @__PURE__ */ B(bl, G({
    "data-state": c.stateAttribute
  }, h, a, {
    ref: e,
    style: {
      ...a.style,
      "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
      "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
      "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }), /* @__PURE__ */ B(Sg, null, r), /* @__PURE__ */ B(sO, {
    scope: n,
    isInside: !0
  }, /* @__PURE__ */ B(GE, {
    id: c.contentId,
    role: "tooltip"
  }, i || r))));
});
function aO(t, e) {
  const n = Math.abs(e.top - t.y), r = Math.abs(e.bottom - t.y), i = Math.abs(e.right - t.x), o = Math.abs(e.left - t.x);
  switch (Math.min(n, r, i, o)) {
    case o:
      return "left";
    case i:
      return "right";
    case n:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function lO(t, e, n = 5) {
  const r = [];
  switch (e) {
    case "top":
      r.push({
        x: t.x - n,
        y: t.y + n
      }, {
        x: t.x + n,
        y: t.y + n
      });
      break;
    case "bottom":
      r.push({
        x: t.x - n,
        y: t.y - n
      }, {
        x: t.x + n,
        y: t.y - n
      });
      break;
    case "left":
      r.push({
        x: t.x + n,
        y: t.y - n
      }, {
        x: t.x + n,
        y: t.y + n
      });
      break;
    case "right":
      r.push({
        x: t.x - n,
        y: t.y - n
      }, {
        x: t.x - n,
        y: t.y + n
      });
      break;
  }
  return r;
}
function cO(t) {
  const { top: e, right: n, bottom: r, left: i } = t;
  return [
    {
      x: i,
      y: e
    },
    {
      x: n,
      y: e
    },
    {
      x: n,
      y: r
    },
    {
      x: i,
      y: r
    }
  ];
}
function uO(t, e) {
  const { x: n, y: r } = t;
  let i = !1;
  for (let o = 0, s = e.length - 1; o < e.length; s = o++) {
    const a = e[o].x, c = e[o].y, h = e[s].x, f = e[s].y;
    c > r != f > r && n < (h - a) * (r - c) / (f - c) + a && (i = !i);
  }
  return i;
}
function hO(t) {
  const e = t.slice();
  return e.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), fO(e);
}
function fO(t) {
  if (t.length <= 1) return t.slice();
  const e = [];
  for (let r = 0; r < t.length; r++) {
    const i = t[r];
    for (; e.length >= 2; ) {
      const o = e[e.length - 1], s = e[e.length - 2];
      if ((o.x - s.x) * (i.y - s.y) >= (o.y - s.y) * (i.x - s.x)) e.pop();
      else break;
    }
    e.push(i);
  }
  e.pop();
  const n = [];
  for (let r = t.length - 1; r >= 0; r--) {
    const i = t[r];
    for (; n.length >= 2; ) {
      const o = n[n.length - 1], s = n[n.length - 2];
      if ((o.x - s.x) * (i.y - s.y) >= (o.y - s.y) * (i.x - s.x)) n.pop();
      else break;
    }
    n.push(i);
  }
  return n.pop(), e.length === 1 && n.length === 1 && e[0].x === n[0].x && e[0].y === n[0].y ? e : e.concat(n);
}
const dO = ZE, P3 = JE, W3 = eO, z3 = rO, U3 = iO;
let qd = 0;
function Qs() {
  Ce(() => {
    var t, e;
    const n = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", (t = n[0]) !== null && t !== void 0 ? t : n5()), document.body.insertAdjacentElement("beforeend", (e = n[1]) !== null && e !== void 0 ? e : n5()), qd++, () => {
      qd === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(
        (r) => r.remove()
      ), qd--;
    };
  }, []);
}
function n5() {
  const t = document.createElement("span");
  return t.setAttribute("data-radix-focus-guard", ""), t.tabIndex = 0, t.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", t;
}
const Gd = "focusScope.autoFocusOnMount", Yd = "focusScope.autoFocusOnUnmount", r5 = {
  bubbles: !1,
  cancelable: !0
}, Js = /* @__PURE__ */ O((t, e) => {
  const { loop: n = !1, trapped: r = !1, onMountAutoFocus: i, onUnmountAutoFocus: o, ...s } = t, [a, c] = De(null), h = Ot(i), f = Ot(o), d = ue(null), p = ke(
    e,
    (b) => c(b)
  ), v = ue({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  Ce(() => {
    if (r) {
      let b = function(k) {
        if (v.paused || !a) return;
        const T = k.target;
        a.contains(T) ? d.current = T : Oi(d.current, {
          select: !0
        });
      }, y = function(k) {
        if (v.paused || !a) return;
        const T = k.relatedTarget;
        T !== null && (a.contains(T) || Oi(d.current, {
          select: !0
        }));
      }, $ = function(k) {
        if (document.activeElement === document.body)
          for (const R of k) R.removedNodes.length > 0 && Oi(a);
      };
      document.addEventListener("focusin", b), document.addEventListener("focusout", y);
      const A = new MutationObserver($);
      return a && A.observe(a, {
        childList: !0,
        subtree: !0
      }), () => {
        document.removeEventListener("focusin", b), document.removeEventListener("focusout", y), A.disconnect();
      };
    }
  }, [
    r,
    a,
    v.paused
  ]), Ce(() => {
    if (a) {
      o5.add(v);
      const b = document.activeElement;
      if (!a.contains(b)) {
        const $ = new CustomEvent(Gd, r5);
        a.addEventListener(Gd, h), a.dispatchEvent($), $.defaultPrevented || (gO(wO(K3(a)), {
          select: !0
        }), document.activeElement === b && Oi(a));
      }
      return () => {
        a.removeEventListener(Gd, h), setTimeout(() => {
          const $ = new CustomEvent(Yd, r5);
          a.addEventListener(Yd, f), a.dispatchEvent($), $.defaultPrevented || Oi(b ?? document.body, {
            select: !0
          }), a.removeEventListener(Yd, f), o5.remove(v);
        }, 0);
      };
    }
  }, [
    a,
    h,
    f,
    v
  ]);
  const w = rt((b) => {
    if (!n && !r || v.paused) return;
    const y = b.key === "Tab" && !b.altKey && !b.ctrlKey && !b.metaKey, $ = document.activeElement;
    if (y && $) {
      const A = b.currentTarget, [k, T] = pO(A);
      k && T ? !b.shiftKey && $ === T ? (b.preventDefault(), n && Oi(k, {
        select: !0
      })) : b.shiftKey && $ === k && (b.preventDefault(), n && Oi(T, {
        select: !0
      })) : $ === A && b.preventDefault();
    }
  }, [
    n,
    r,
    v.paused
  ]);
  return /* @__PURE__ */ B(we.div, G({
    tabIndex: -1
  }, s, {
    ref: p,
    onKeyDown: w
  }));
});
function gO(t, { select: e = !1 } = {}) {
  const n = document.activeElement;
  for (const r of t)
    if (Oi(r, {
      select: e
    }), document.activeElement !== n) return;
}
function pO(t) {
  const e = K3(t), n = i5(e, t), r = i5(e.reverse(), t);
  return [
    n,
    r
  ];
}
function K3(t) {
  const e = [], n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) e.push(n.currentNode);
  return e;
}
function i5(t, e) {
  for (const n of t)
    if (!mO(n, {
      upTo: e
    })) return n;
}
function mO(t, { upTo: e }) {
  if (getComputedStyle(t).visibility === "hidden") return !0;
  for (; t; ) {
    if (e !== void 0 && t === e) return !1;
    if (getComputedStyle(t).display === "none") return !0;
    t = t.parentElement;
  }
  return !1;
}
function vO(t) {
  return t instanceof HTMLInputElement && "select" in t;
}
function Oi(t, { select: e = !1 } = {}) {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({
      preventScroll: !0
    }), t !== n && vO(t) && e && t.select();
  }
}
const o5 = bO();
function bO() {
  let t = [];
  return {
    add(e) {
      const n = t[0];
      e !== n && n?.pause(), t = s5(t, e), t.unshift(e);
    },
    remove(e) {
      var n;
      t = s5(t, e), (n = t[0]) === null || n === void 0 || n.resume();
    }
  };
}
function s5(t, e) {
  const n = [
    ...t
  ], r = n.indexOf(e);
  return r !== -1 && n.splice(r, 1), n;
}
function wO(t) {
  return t.filter(
    (e) => e.tagName !== "A"
  );
}
var xO = function(t) {
  if (typeof document > "u")
    return null;
  var e = Array.isArray(t) ? t[0] : t;
  return e.ownerDocument.body;
}, ss = /* @__PURE__ */ new WeakMap(), Oc = /* @__PURE__ */ new WeakMap(), Dc = {}, jd = 0, q3 = function(t) {
  return t && (t.host || q3(t.parentNode));
}, yO = function(t, e) {
  return e.map(function(n) {
    if (t.contains(n))
      return n;
    var r = q3(n);
    return r && t.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", t, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, CO = function(t, e, n, r) {
  var i = yO(e, Array.isArray(t) ? t : [t]);
  Dc[n] || (Dc[n] = /* @__PURE__ */ new WeakMap());
  var o = Dc[n], s = [], a = /* @__PURE__ */ new Set(), c = new Set(i), h = function(d) {
    !d || a.has(d) || (a.add(d), h(d.parentNode));
  };
  i.forEach(h);
  var f = function(d) {
    !d || c.has(d) || Array.prototype.forEach.call(d.children, function(p) {
      if (a.has(p))
        f(p);
      else
        try {
          var v = p.getAttribute(r), w = v !== null && v !== "false", b = (ss.get(p) || 0) + 1, y = (o.get(p) || 0) + 1;
          ss.set(p, b), o.set(p, y), s.push(p), b === 1 && w && Oc.set(p, !0), y === 1 && p.setAttribute(n, "true"), w || p.setAttribute(r, "true");
        } catch ($) {
          console.error("aria-hidden: cannot operate on ", p, $);
        }
    });
  };
  return f(e), a.clear(), jd++, function() {
    s.forEach(function(d) {
      var p = ss.get(d) - 1, v = o.get(d) - 1;
      ss.set(d, p), o.set(d, v), p || (Oc.has(d) || d.removeAttribute(r), Oc.delete(d)), v || d.removeAttribute(n);
    }), jd--, jd || (ss = /* @__PURE__ */ new WeakMap(), ss = /* @__PURE__ */ new WeakMap(), Oc = /* @__PURE__ */ new WeakMap(), Dc = {});
  };
}, G3 = function(t, e, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(t) ? t : [t]), i = xO(t);
  return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live]"))), CO(r, i, n, "aria-hidden")) : function() {
    return null;
  };
}, lt = function() {
  return lt = Object.assign || function(e) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, lt.apply(this, arguments);
};
function xl(t, e) {
  var n = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
  return n;
}
function Rh(t, e, n) {
  if (n || arguments.length === 2) for (var r = 0, i = e.length, o; r < i; r++)
    (o || !(r in e)) && (o || (o = Array.prototype.slice.call(e, 0, r)), o[r] = e[r]);
  return t.concat(o || Array.prototype.slice.call(e));
}
var bo = "right-scroll-bar-position", wo = "width-before-scroll-bar", $O = "with-scroll-bars-hidden", SO = "--removed-body-scroll-bar-size";
function Xd(t, e) {
  return typeof t == "function" ? t(e) : t && (t.current = e), t;
}
function AO(t, e) {
  var n = De(function() {
    return {
      // value
      value: t,
      // last callback
      callback: e,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var i = n.value;
          i !== r && (n.value = r, n.callback(r, i));
        }
      }
    };
  })[0];
  return n.callback = e, n.facade;
}
var kO = typeof window < "u" ? C.useLayoutEffect : C.useEffect, a5 = /* @__PURE__ */ new WeakMap();
function Eh(t, e) {
  var n = AO(null, function(r) {
    return t.forEach(function(i) {
      return Xd(i, r);
    });
  });
  return kO(function() {
    var r = a5.get(n);
    if (r) {
      var i = new Set(r), o = new Set(t), s = n.current;
      i.forEach(function(a) {
        o.has(a) || Xd(a, null);
      }), o.forEach(function(a) {
        i.has(a) || Xd(a, s);
      });
    }
    a5.set(n, t);
  }, [t]), n;
}
function MO(t) {
  return t;
}
function TO(t, e) {
  e === void 0 && (e = MO);
  var n = [], r = !1, i = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : t;
    },
    useMedium: function(o) {
      var s = e(o, r);
      return n.push(s), function() {
        n = n.filter(function(a) {
          return a !== s;
        });
      };
    },
    assignSyncMedium: function(o) {
      for (r = !0; n.length; ) {
        var s = n;
        n = [], s.forEach(o);
      }
      n = {
        push: function(a) {
          return o(a);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(o) {
      r = !0;
      var s = [];
      if (n.length) {
        var a = n;
        n = [], a.forEach(o), s = n;
      }
      var c = function() {
        var f = s;
        s = [], f.forEach(o);
      }, h = function() {
        return Promise.resolve().then(c);
      };
      h(), n = {
        push: function(f) {
          s.push(f), h();
        },
        filter: function(f) {
          return s = s.filter(f), n;
        }
      };
    }
  };
  return i;
}
function Oh(t) {
  t === void 0 && (t = {});
  var e = TO(null);
  return e.options = lt({ async: !0, ssr: !1 }, t), e;
}
var Y3 = function(t) {
  var e = t.sideCar, n = xl(t, ["sideCar"]);
  if (!e)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = e.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return C.createElement(r, lt({}, n));
};
Y3.isSideCarExport = !0;
function Dh(t, e) {
  return t.useMedium(e), Y3;
}
var j3 = Oh(), Zd = function() {
}, Ih = C.forwardRef(function(t, e) {
  var n = C.useRef(null), r = C.useState({
    onScrollCapture: Zd,
    onWheelCapture: Zd,
    onTouchMoveCapture: Zd
  }), i = r[0], o = r[1], s = t.forwardProps, a = t.children, c = t.className, h = t.removeScrollBar, f = t.enabled, d = t.shards, p = t.sideCar, v = t.noIsolation, w = t.inert, b = t.allowPinchZoom, y = t.as, $ = y === void 0 ? "div" : y, A = t.gapMode, k = xl(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), T = p, R = Eh([n, e]), _ = lt(lt({}, k), i);
  return C.createElement(
    C.Fragment,
    null,
    f && C.createElement(T, { sideCar: j3, removeScrollBar: h, shards: d, noIsolation: v, inert: w, setCallbacks: o, allowPinchZoom: !!b, lockRef: n, gapMode: A }),
    s ? C.cloneElement(C.Children.only(a), lt(lt({}, _), { ref: R })) : C.createElement($, lt({}, _, { className: c, ref: R }), a)
  );
});
Ih.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
Ih.classNames = {
  fullWidth: wo,
  zeroRight: bo
};
var RO = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function EO() {
  if (!document)
    return null;
  var t = document.createElement("style");
  t.type = "text/css";
  var e = RO();
  return e && t.setAttribute("nonce", e), t;
}
function OO(t, e) {
  t.styleSheet ? t.styleSheet.cssText = e : t.appendChild(document.createTextNode(e));
}
function DO(t) {
  var e = document.head || document.getElementsByTagName("head")[0];
  e.appendChild(t);
}
var IO = function() {
  var t = 0, e = null;
  return {
    add: function(n) {
      t == 0 && (e = EO()) && (OO(e, n), DO(e)), t++;
    },
    remove: function() {
      t--, !t && e && (e.parentNode && e.parentNode.removeChild(e), e = null);
    }
  };
}, _O = function() {
  var t = IO();
  return function(e, n) {
    C.useEffect(function() {
      return t.add(e), function() {
        t.remove();
      };
    }, [e && n]);
  };
}, yl = function() {
  var t = _O(), e = function(n) {
    var r = n.styles, i = n.dynamic;
    return t(r, i), null;
  };
  return e;
}, LO = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, Qd = function(t) {
  return parseInt(t || "", 10) || 0;
}, BO = function(t) {
  var e = window.getComputedStyle(document.body), n = e[t === "padding" ? "paddingLeft" : "marginLeft"], r = e[t === "padding" ? "paddingTop" : "marginTop"], i = e[t === "padding" ? "paddingRight" : "marginRight"];
  return [Qd(n), Qd(r), Qd(i)];
}, NO = function(t) {
  if (t === void 0 && (t = "margin"), typeof window > "u")
    return LO;
  var e = BO(t), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: e[0],
    top: e[1],
    right: e[2],
    gap: Math.max(0, r - n + e[2] - e[0])
  };
}, FO = yl(), $s = "data-scroll-locked", VO = function(t, e, n, r) {
  var i = t.left, o = t.top, s = t.right, a = t.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat($O, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(a, "px ").concat(r, `;
  }
  body[`).concat($s, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    e && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(o, `px;
    padding-right: `).concat(s, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(a, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(bo, ` {
    right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(wo, ` {
    margin-right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(bo, " .").concat(bo, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(wo, " .").concat(wo, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat($s, `] {
    `).concat(SO, ": ").concat(a, `px;
  }
`);
}, l5 = function() {
  var t = parseInt(document.body.getAttribute($s) || "0", 10);
  return isFinite(t) ? t : 0;
}, HO = function() {
  C.useEffect(function() {
    return document.body.setAttribute($s, (l5() + 1).toString()), function() {
      var t = l5() - 1;
      t <= 0 ? document.body.removeAttribute($s) : document.body.setAttribute($s, t.toString());
    };
  }, []);
}, _h = function(t) {
  var e = t.noRelative, n = t.noImportant, r = t.gapMode, i = r === void 0 ? "margin" : r;
  HO();
  var o = C.useMemo(function() {
    return NO(i);
  }, [i]);
  return C.createElement(FO, { styles: VO(o, !e, i, n ? "" : "!important") });
}, j0 = !1;
if (typeof window < "u")
  try {
    var Ic = Object.defineProperty({}, "passive", {
      get: function() {
        return j0 = !0, !0;
      }
    });
    window.addEventListener("test", Ic, Ic), window.removeEventListener("test", Ic, Ic);
  } catch {
    j0 = !1;
  }
var as = j0 ? { passive: !1 } : !1, PO = function(t) {
  return t.tagName === "TEXTAREA";
}, X3 = function(t, e) {
  if (!(t instanceof Element))
    return !1;
  var n = window.getComputedStyle(t);
  return (
    // not-not-scrollable
    n[e] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !PO(t) && n[e] === "visible")
  );
}, WO = function(t) {
  return X3(t, "overflowY");
}, zO = function(t) {
  return X3(t, "overflowX");
}, c5 = function(t, e) {
  var n = e.ownerDocument, r = e;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var i = Z3(t, r);
    if (i) {
      var o = Q3(t, r), s = o[1], a = o[2];
      if (s > a)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, UO = function(t) {
  var e = t.scrollTop, n = t.scrollHeight, r = t.clientHeight;
  return [
    e,
    n,
    r
  ];
}, KO = function(t) {
  var e = t.scrollLeft, n = t.scrollWidth, r = t.clientWidth;
  return [
    e,
    n,
    r
  ];
}, Z3 = function(t, e) {
  return t === "v" ? WO(e) : zO(e);
}, Q3 = function(t, e) {
  return t === "v" ? UO(e) : KO(e);
}, qO = function(t, e) {
  return t === "h" && e === "rtl" ? -1 : 1;
}, GO = function(t, e, n, r, i) {
  var o = qO(t, window.getComputedStyle(e).direction), s = o * r, a = n.target, c = e.contains(a), h = !1, f = s > 0, d = 0, p = 0;
  do {
    var v = Q3(t, a), w = v[0], b = v[1], y = v[2], $ = b - y - o * w;
    (w || $) && Z3(t, a) && (d += $, p += w), a instanceof ShadowRoot ? a = a.host : a = a.parentNode;
  } while (
    // portaled content
    !c && a !== document.body || // self content
    c && (e.contains(a) || e === a)
  );
  return (f && Math.abs(d) < 1 || !f && Math.abs(p) < 1) && (h = !0), h;
}, _c = function(t) {
  return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0];
}, u5 = function(t) {
  return [t.deltaX, t.deltaY];
}, h5 = function(t) {
  return t && "current" in t ? t.current : t;
}, YO = function(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}, jO = function(t) {
  return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`);
}, XO = 0, ls = [];
function ZO(t) {
  var e = C.useRef([]), n = C.useRef([0, 0]), r = C.useRef(), i = C.useState(XO++)[0], o = C.useState(yl)[0], s = C.useRef(t);
  C.useEffect(function() {
    s.current = t;
  }, [t]), C.useEffect(function() {
    if (t.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var b = Rh([t.lockRef.current], (t.shards || []).map(h5), !0).filter(Boolean);
      return b.forEach(function(y) {
        return y.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), b.forEach(function(y) {
          return y.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [t.inert, t.lockRef.current, t.shards]);
  var a = C.useCallback(function(b, y) {
    if ("touches" in b && b.touches.length === 2)
      return !s.current.allowPinchZoom;
    var $ = _c(b), A = n.current, k = "deltaX" in b ? b.deltaX : A[0] - $[0], T = "deltaY" in b ? b.deltaY : A[1] - $[1], R, _ = b.target, D = Math.abs(k) > Math.abs(T) ? "h" : "v";
    if ("touches" in b && D === "h" && _.type === "range")
      return !1;
    var P = c5(D, _);
    if (!P)
      return !0;
    if (P ? R = D : (R = D === "v" ? "h" : "v", P = c5(D, _)), !P)
      return !1;
    if (!r.current && "changedTouches" in b && (k || T) && (r.current = R), !R)
      return !0;
    var H = r.current || R;
    return GO(H, y, b, H === "h" ? k : T);
  }, []), c = C.useCallback(function(b) {
    var y = b;
    if (!(!ls.length || ls[ls.length - 1] !== o)) {
      var $ = "deltaY" in y ? u5(y) : _c(y), A = e.current.filter(function(R) {
        return R.name === y.type && (R.target === y.target || y.target === R.shadowParent) && YO(R.delta, $);
      })[0];
      if (A && A.should) {
        y.cancelable && y.preventDefault();
        return;
      }
      if (!A) {
        var k = (s.current.shards || []).map(h5).filter(Boolean).filter(function(R) {
          return R.contains(y.target);
        }), T = k.length > 0 ? a(y, k[0]) : !s.current.noIsolation;
        T && y.cancelable && y.preventDefault();
      }
    }
  }, []), h = C.useCallback(function(b, y, $, A) {
    var k = { name: b, delta: y, target: $, should: A, shadowParent: QO($) };
    e.current.push(k), setTimeout(function() {
      e.current = e.current.filter(function(T) {
        return T !== k;
      });
    }, 1);
  }, []), f = C.useCallback(function(b) {
    n.current = _c(b), r.current = void 0;
  }, []), d = C.useCallback(function(b) {
    h(b.type, u5(b), b.target, a(b, t.lockRef.current));
  }, []), p = C.useCallback(function(b) {
    h(b.type, _c(b), b.target, a(b, t.lockRef.current));
  }, []);
  C.useEffect(function() {
    return ls.push(o), t.setCallbacks({
      onScrollCapture: d,
      onWheelCapture: d,
      onTouchMoveCapture: p
    }), document.addEventListener("wheel", c, as), document.addEventListener("touchmove", c, as), document.addEventListener("touchstart", f, as), function() {
      ls = ls.filter(function(b) {
        return b !== o;
      }), document.removeEventListener("wheel", c, as), document.removeEventListener("touchmove", c, as), document.removeEventListener("touchstart", f, as);
    };
  }, []);
  var v = t.removeScrollBar, w = t.inert;
  return C.createElement(
    C.Fragment,
    null,
    w ? C.createElement(o, { styles: jO(i) }) : null,
    v ? C.createElement(_h, { gapMode: t.gapMode }) : null
  );
}
function QO(t) {
  for (var e = null; t !== null; )
    t instanceof ShadowRoot && (e = t.host, t = t.host), t = t.parentNode;
  return e;
}
const JO = Dh(j3, ZO);
var Lh = C.forwardRef(function(t, e) {
  return C.createElement(Ih, lt({}, t, { ref: e, sideCar: JO }));
});
Lh.classNames = Ih.classNames;
function X0(t, [e, n]) {
  return Math.min(n, Math.max(e, t));
}
function Bh(t) {
  const e = t + "CollectionProvider", [n, r] = Tt(e), [i, o] = n(e, {
    collectionRef: {
      current: null
    },
    itemMap: /* @__PURE__ */ new Map()
  }), s = (v) => {
    const { scope: w, children: b } = v, y = ze.useRef(null), $ = ze.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ ze.createElement(i, {
      scope: w,
      itemMap: $,
      collectionRef: y
    }, b);
  }, a = t + "CollectionSlot", c = /* @__PURE__ */ ze.forwardRef((v, w) => {
    const { scope: b, children: y } = v, $ = o(a, b), A = ke(w, $.collectionRef);
    return /* @__PURE__ */ ze.createElement(Dr, {
      ref: A
    }, y);
  }), h = t + "CollectionItemSlot", f = "data-radix-collection-item", d = /* @__PURE__ */ ze.forwardRef((v, w) => {
    const { scope: b, children: y, ...$ } = v, A = ze.useRef(null), k = ke(w, A), T = o(h, b);
    return ze.useEffect(() => (T.itemMap.set(A, {
      ref: A,
      ...$
    }), () => void T.itemMap.delete(A))), /* @__PURE__ */ ze.createElement(Dr, {
      [f]: "",
      ref: k
    }, y);
  });
  function p(v) {
    const w = o(t + "CollectionConsumer", v);
    return ze.useCallback(() => {
      const y = w.collectionRef.current;
      if (!y) return [];
      const $ = Array.from(y.querySelectorAll(`[${f}]`));
      return Array.from(w.itemMap.values()).sort(
        (T, R) => $.indexOf(T.ref.current) - $.indexOf(R.ref.current)
      );
    }, [
      w.collectionRef,
      w.itemMap
    ]);
  }
  return [
    {
      Provider: s,
      Slot: c,
      ItemSlot: d
    },
    p,
    r
  ];
}
const eD = /* @__PURE__ */ Ua(void 0);
function Fo(t) {
  const e = wh(eD);
  return t || e || "ltr";
}
function Nh(t) {
  const e = ue({
    value: t,
    previous: t
  });
  return So(() => (e.current.value !== t && (e.current.previous = e.current.value, e.current.value = t), e.current.previous), [
    t
  ]);
}
function tD(t) {
  const e = `${t}CollectionProvider`, [n, r] = Tt(e), [i, o] = n(e, {
    collectionRef: { current: null },
    itemMap: /* @__PURE__ */ new Map(),
    listeners: /* @__PURE__ */ new Set()
  }), s = (v) => {
    const { scope: w, children: b } = v, y = C.useRef(null), $ = C.useRef(/* @__PURE__ */ new Map()).current, A = C.useRef(/* @__PURE__ */ new Set()).current;
    return /* @__PURE__ */ m(i, { scope: w, itemMap: $, collectionRef: y, listeners: A, children: b });
  };
  s.displayName = e;
  const a = `${t}CollectionSlot`, c = C.forwardRef((v, w) => {
    const { scope: b, children: y } = v, $ = o(a, b), A = ke(w, $.collectionRef);
    return /* @__PURE__ */ m(Dr, { ref: A, children: y });
  });
  c.displayName = a;
  const h = `${t}CollectionItemSlot`, f = "data-radix-collection-item", d = C.forwardRef((v, w) => {
    const { scope: b, children: y, ...$ } = v, A = C.useRef(null), k = ke(w, A), T = o(h, b);
    return C.useEffect(() => {
      const R = Array.from(T.itemMap.values());
      return T.itemMap.set(A, { ref: A, ...$ }), T.listeners.forEach((_) => _(Array.from(T.itemMap.values()), R)), () => {
        const _ = Array.from(T.itemMap.values());
        T.itemMap.delete(A), T.listeners.forEach((D) => D(Array.from(T.itemMap.values()), _));
      };
    }), /* @__PURE__ */ m(Dr, { [f]: "", ref: k, children: y });
  });
  d.displayName = h;
  function p(v) {
    const w = o(`${t}CollectionConsumer`, v), b = C.useCallback(() => {
      const $ = w.collectionRef.current;
      if (!$)
        return [];
      const A = Array.from($.querySelectorAll(`[${f}]`));
      return Array.from(w.itemMap.values()).sort(
        (R, _) => A.indexOf(R.ref.current) - A.indexOf(_.ref.current)
      );
    }, [w.collectionRef, w.itemMap]), y = C.useCallback(
      ($) => (w.listeners.add($), () => w.listeners.delete($)),
      [w.listeners]
    );
    return { getItems: b, subscribe: y };
  }
  return [
    { Provider: s, Slot: c, ItemSlot: d },
    p,
    r
  ];
}
const Jd = /* @__PURE__ */ new Map();
function nD(t, e) {
  const n = t + (e ? Object.entries(e).sort((i, o) => i[0] < o[0] ? -1 : 1).join() : "");
  if (Jd.has(n))
    return Jd.get(n);
  const r = new Intl.Collator(t, e);
  return Jd.set(n, r), r;
}
function Lg(t, e) {
  const n = nD(t, {
    usage: "search",
    ...e
  });
  return {
    startsWith(r, i) {
      return i.length === 0 ? !0 : (r = r.normalize("NFC"), i = i.normalize("NFC"), n.compare(r.slice(0, i.length), i) === 0);
    },
    endsWith(r, i) {
      return i.length === 0 ? !0 : (r = r.normalize("NFC"), i = i.normalize("NFC"), n.compare(r.slice(-i.length), i) === 0);
    },
    contains(r, i) {
      if (i.length === 0)
        return !0;
      r = r.normalize("NFC"), i = i.normalize("NFC");
      let o = 0;
      const s = i.length;
      for (; o + s <= r.length; o++) {
        const a = r.slice(o, o + s);
        if (n.compare(i, a) === 0)
          return !0;
      }
      return !1;
    }
  };
}
const J3 = (t) => {
  const e = C.useRef();
  return C.useEffect(() => {
    e.current = t;
  }), e.current;
}, rD = [" ", "Enter", "ArrowUp", "ArrowDown"], iD = ["Enter"], oD = (t) => !!(t.length === 1 && t.match(/\S| /)), ex = "Combobox", [Ls, Cl] = tD(ex), [sD, Br] = $g(ex), aD = ({ children: t }) => /* @__PURE__ */ m(ml, { children: /* @__PURE__ */ m(Ls.Provider, { scope: void 0, children: t }) }), lD = (t) => typeof t == "string" ? t === "none" ? {
  type: t,
  filter: void 0
} : {
  type: t,
  filter: "startsWith"
} : t, cD = (t) => {
  const {
    allowCustomValue: e = !1,
    autocomplete: n = "none",
    children: r,
    open: i,
    defaultOpen: o,
    onOpenChange: s,
    value: a,
    defaultValue: c,
    onValueChange: h,
    disabled: f,
    required: d = !1,
    locale: p = "en-EN",
    onTextValueChange: v,
    textValue: w,
    defaultTextValue: b,
    filterValue: y,
    defaultFilterValue: $,
    onFilterValueChange: A,
    isPrintableCharacter: k = oD,
    visible: T = !1
  } = t, [R, _] = C.useState(null), [D, P] = C.useState(null), [H, z] = C.useState(null), [j, K] = C.useState(null), [te = !1, ee] = zt({
    prop: i,
    defaultProp: o,
    onChange: s
  }), [re, de] = zt({
    prop: a,
    defaultProp: c,
    onChange: h
  }), [ie, se] = zt({
    prop: w,
    defaultProp: e && !b ? a : b,
    onChange: v
  }), [X, ce] = zt({
    prop: y,
    defaultProp: $,
    onChange: A
  }), be = Ut(), Le = C.useCallback(
    (qe, He) => {
      const Ze = He.map((Ee) => Ee.ref.current), [xe, ...Ve] = Ze, [Oe] = Ve.slice(-1), Ue = j ?? He.find((Ee) => Ee.value === re)?.ref.current;
      for (const Ee of qe) {
        if (Ee === Ue)
          return;
        if (Ee?.scrollIntoView({ block: "nearest" }), Ee === xe && D && (D.scrollTop = 0), Ee === Oe && D && (D.scrollTop = D.scrollHeight), K(Ee), n === "both") {
          const je = He.find((Rt) => Rt.ref.current === Ee);
          je && se(je.textValue);
        }
        if (Ee !== Ue)
          return;
      }
    },
    [n, se, D, j, re]
  ), Ae = lD(n);
  return C.useEffect(() => {
    n !== "both" && K(null);
  }, [ie, n]), C.useEffect(() => {
    if (H && R)
      return G3([H, R]);
  }, [H, R]), /* @__PURE__ */ m(aD, { children: /* @__PURE__ */ m(
    sD,
    {
      allowCustomValue: e,
      autocomplete: Ae,
      required: d,
      trigger: R,
      onTriggerChange: _,
      contentId: be,
      value: re,
      onValueChange: de,
      open: te,
      onOpenChange: ee,
      disabled: f,
      locale: p,
      focusFirst: Le,
      textValue: ie,
      onTextValueChange: se,
      onViewportChange: P,
      onContentChange: z,
      visuallyFocussedItem: j,
      filterValue: X,
      onFilterValueChange: ce,
      onVisuallyFocussedItemChange: K,
      isPrintableCharacter: k,
      visible: T,
      children: r
    }
  ) });
}, tx = "ComboboxTrigger", nx = C.forwardRef((t, e) => {
  const { ...n } = t, r = Br(tx), i = () => {
    r.disabled || r.onOpenChange(!0);
  };
  return /* @__PURE__ */ m(vl, { asChild: !0, children: /* @__PURE__ */ m(
    Js,
    {
      asChild: !0,
      trapped: r.open,
      onMountAutoFocus: (o) => {
        o.preventDefault();
      },
      onUnmountAutoFocus: (o) => {
        r.trigger?.focus({ preventScroll: !0 }), document.getSelection()?.empty(), o.preventDefault();
      },
      children: /* @__PURE__ */ m(
        "div",
        {
          ref: e,
          "data-disabled": r.disabled ? "" : void 0,
          ...n,
          onClick: oe(n.onClick, (o) => {
            if (r.disabled) {
              o.preventDefault();
              return;
            }
            r.trigger?.focus();
          }),
          onPointerDown: oe(n.onPointerDown, (o) => {
            if (r.disabled) {
              o.preventDefault();
              return;
            }
            const s = o.target;
            s.hasPointerCapture(o.pointerId) && s.releasePointerCapture(o.pointerId), (s.closest("button") ?? s.closest("div")) === o.currentTarget && o.button === 0 && o.ctrlKey === !1 && (i(), r.trigger?.focus());
          })
        }
      )
    }
  ) });
});
nx.displayName = tx;
const rx = "ComboboxInput", ix = C.forwardRef((t, e) => {
  const n = Br(rx), r = C.useRef(null), { getItems: i } = Cl(void 0), { startsWith: o } = Lg(n.locale, { sensitivity: "base" }), s = n.disabled, a = ke(r, e, n.onTriggerChange), c = () => {
    s || n.onOpenChange(!0);
  }, h = J3(n.filterValue);
  return xt(() => {
    const f = setTimeout(() => {
      if (n.textValue === "" || n.textValue === void 0 || n.filterValue === "" || n.filterValue === void 0)
        return;
      const d = i().find(
        (v) => v.type === "option" && o(v.textValue, n.textValue)
      ), p = SD(h ?? "", n.filterValue);
      d && !n.visuallyFocussedItem && p === n.filterValue.length && r.current?.setSelectionRange(n.filterValue.length, n.textValue.length);
    });
    return () => clearTimeout(f);
  }, [n.textValue, n.filterValue, o, n.visuallyFocussedItem, i, h]), /* @__PURE__ */ m(
    "input",
    {
      type: "text",
      role: "combobox",
      "aria-controls": n.contentId,
      "aria-expanded": n.open,
      "aria-required": n.required,
      "aria-autocomplete": n.autocomplete.type,
      "data-state": n.open ? "open" : "closed",
      "aria-disabled": s,
      "aria-activedescendant": n.visuallyFocussedItem?.id,
      disabled: s,
      "data-disabled": s ? "" : void 0,
      "data-placeholder": n.textValue === void 0 ? "" : void 0,
      value: n.textValue ?? "",
      ...t,
      ref: a,
      onKeyDown: oe(t.onKeyDown, (f) => {
        if (["ArrowUp", "ArrowDown", "Home", "End"].includes(f.key))
          n.open || c(), setTimeout(() => {
            let p = i().filter((v) => !v.disabled && v.isVisible).map((v) => v.ref.current);
            if (["ArrowUp", "End"].includes(f.key) && (p = p.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(f.key)) {
              const v = n.visuallyFocussedItem ?? i().find((w) => w.value === n.value)?.ref.current;
              if (v) {
                let w = p.indexOf(v);
                w === p.length - 1 && (w = -1), p = p.slice(w + 1);
              }
            }
            if (["ArrowDown"].includes(f.key) && n.autocomplete.type === "both" && p.length > 1) {
              const [v, ...w] = p, b = i().find((y) => y.ref.current === v).textValue;
              n.textValue === b && (p = w);
            }
            n.focusFirst(p, i());
          }), f.preventDefault();
        else if (["Tab"].includes(f.key) && n.open)
          f.preventDefault();
        else if (["Escape"].includes(f.key))
          n.open ? n.onOpenChange(!1) : (n.onValueChange(void 0), n.onTextValueChange("")), f.preventDefault();
        else if (iD.includes(f.key)) {
          if (n.visuallyFocussedItem) {
            const d = i().find((p) => p.ref.current === n.visuallyFocussedItem);
            d && (n.onValueChange(d.value), n.onTextValueChange(d.textValue), n.autocomplete.type === "both" && n.onFilterValueChange(d.textValue), d.ref.current?.click());
          } else {
            const d = i().find(
              (p) => p.type === "option" && !p.disabled && p.textValue === n.textValue
            );
            d && (n.onValueChange(d.value), n.onTextValueChange(d.textValue), n.autocomplete.type === "both" && n.onFilterValueChange(d.textValue), d.ref.current?.click());
          }
          n.onOpenChange(!1), f.preventDefault();
        } else
          n.onVisuallyFocussedItemChange(null);
      }),
      onChange: oe(t.onChange, (f) => {
        n.onTextValueChange(f.currentTarget.value), n.autocomplete.type === "both" && n.onFilterValueChange(f.currentTarget.value);
      }),
      onKeyUp: oe(t.onKeyUp, (f) => {
        if (!n.open && (n.isPrintableCharacter(f.key) || ["Backspace"].includes(f.key)) && c(), setTimeout(() => {
          if (n.autocomplete.type === "both" && n.isPrintableCharacter(f.key) && n.filterValue !== void 0) {
            const d = n.filterValue, p = i().find((v) => o(v.textValue, d));
            p && n.onTextValueChange(p.textValue);
          }
        }), n.autocomplete.type === "none" && n.isPrintableCharacter(f.key)) {
          const d = n.textValue ?? "", p = i().find((v) => o(v.textValue, d));
          p && (n.onVisuallyFocussedItemChange(p.ref.current), p.ref.current?.scrollIntoView());
        }
      }),
      onBlur: oe(t.onBlur, () => {
        if (n.open)
          return;
        n.onVisuallyFocussedItemChange(null);
        const [f] = i().filter(
          (p) => p.textValue === n.textValue && p.type === "option"
        );
        if (f) {
          n.onValueChange(f.value), n.autocomplete.type === "both" && n.onFilterValueChange(f.textValue);
          return;
        }
        if (n.allowCustomValue) {
          n.onValueChange(n.textValue), n.autocomplete.type === "both" && n.onFilterValueChange(n.textValue);
          return;
        }
        const [d] = i().filter((p) => p.value === n.value && p.type === "option");
        d && n.textValue !== "" ? (n.onTextValueChange(d.textValue), n.autocomplete.type === "both" && n.onFilterValueChange(d.textValue)) : (n.onValueChange(void 0), n.onTextValueChange(""));
      })
    }
  );
});
ix.displayName = "ComboboxTextInput";
const ox = C.forwardRef((t, e) => {
  const { children: n, ...r } = t, i = Br(rx), o = i.disabled, s = () => {
    o || (i.onOpenChange(!0), i.trigger?.focus());
  };
  return /* @__PURE__ */ m(
    we.button,
    {
      "aria-hidden": !0,
      type: "button",
      "aria-disabled": o,
      "aria-controls": i.contentId,
      "aria-expanded": i.open,
      disabled: o,
      "data-disabled": o ? "" : void 0,
      ...r,
      tabIndex: -1,
      ref: e,
      onClick: oe(r.onClick, () => {
        i.trigger?.focus();
      }),
      onPointerDown: oe(r.onPointerDown, (a) => {
        a.button === 0 && a.ctrlKey === !1 && (s(), a.preventDefault());
      }),
      onKeyDown: oe(r.onKeyDown, (a) => {
        rD.includes(a.key) && (s(), a.preventDefault());
      }),
      children: n || "▼"
    }
  );
});
ox.displayName = "ComboboxIcon";
const uD = "ComboboxPortal", sx = (t) => /* @__PURE__ */ m(Zs, { asChild: !0, ...t });
sx.displayName = uD;
const Bg = "ComboboxContent", ax = C.forwardRef((t, e) => {
  const n = Br(Bg), { getItems: r } = Cl(void 0), [i, o] = C.useState();
  if (xt(() => {
    o(new DocumentFragment());
  }, []), xt(() => {
    n.open && n.autocomplete.type === "none" && setTimeout(() => {
      r().find((a) => a.value === n.value)?.ref.current?.scrollIntoView({ block: "nearest" });
    });
  }, [r, n.autocomplete, n.value, n.open]), !n.open) {
    const s = i;
    return s ? Ys.createPortal(
      /* @__PURE__ */ m(Ls.Slot, { scope: void 0, children: /* @__PURE__ */ m("div", { children: t.children }) }),
      s
    ) : null;
  }
  return /* @__PURE__ */ m(lx, { ...t, ref: e });
});
ax.displayName = Bg;
const hD = 10, lx = C.forwardRef(
  (t, e) => {
    const { onEscapeKeyDown: n, onPointerDownOutside: r, ...i } = t, o = Br(Bg), s = ke(e, (c) => o.onContentChange(c)), { onOpenChange: a } = o;
    return Qs(), C.useEffect(() => {
      const c = () => {
        a(!1);
      };
      return window.addEventListener("blur", c), window.addEventListener("resize", c), () => {
        window.removeEventListener("blur", c), window.removeEventListener("resize", c);
      };
    }, [a]), /* @__PURE__ */ m(Lh, { allowPinchZoom: !0, children: /* @__PURE__ */ m(
      No,
      {
        asChild: !0,
        onEscapeKeyDown: n,
        onPointerDownOutside: r,
        onFocusOutside: (c) => {
          c.preventDefault();
        },
        onDismiss: () => {
          o.onOpenChange(!1), o.trigger?.focus({ preventScroll: !0 });
        },
        children: /* @__PURE__ */ m(
          cx,
          {
            role: "listbox",
            id: o.contentId,
            "data-state": o.open ? "open" : "closed",
            onContextMenu: (c) => c.preventDefault(),
            ...i,
            ref: s,
            style: {
              // flex layout so we can place the scroll buttons properly
              display: "flex",
              flexDirection: "column",
              // reset the outline by default as the content MAY get focused
              outline: "none",
              ...i.style
            }
          }
        )
      }
    ) });
  }
);
lx.displayName = "ComboboxContentImpl";
const cx = C.forwardRef(
  (t, e) => {
    const { align: n = "start", collisionPadding: r = hD, ...i } = t;
    return /* @__PURE__ */ m(
      bl,
      {
        ...i,
        ref: e,
        align: n,
        collisionPadding: r,
        style: {
          // Ensure border-box for floating-ui calculations
          boxSizing: "border-box",
          ...i.style,
          "--radix-combobox-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-combobox-content-available-width": "var(--radix-popper-available-width)",
          "--radix-combobox-content-available-height": "var(--radix-popper-available-height)",
          "--radix-combobox-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-combobox-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
cx.displayName = "ComboboxPopperPosition";
const ux = "ComboboxViewport", hx = C.forwardRef((t, e) => {
  const n = Br(ux), r = ke(e, n.onViewportChange);
  return /* @__PURE__ */ ae(Gs, { children: [
    /* @__PURE__ */ m(
      "style",
      {
        dangerouslySetInnerHTML: {
          __html: "[data-radix-combobox-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-combobox-viewport]::-webkit-scrollbar{display:none}"
        }
      }
    ),
    /* @__PURE__ */ m(Ls.Slot, { scope: void 0, children: /* @__PURE__ */ m(
      we.div,
      {
        "data-radix-combobox-viewport": "",
        role: "presentation",
        ...t,
        ref: r,
        style: {
          // we use position: 'relative' here on the `viewport` so that when we call
          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
          // (independent of the scrollUpButton).
          position: "relative",
          flex: 1,
          overflow: "auto",
          ...t.style
        }
      }
    ) })
  ] });
});
hx.displayName = ux;
const Fh = "ComboboxItem", [f5, Ng] = $g(Fh), Fg = C.forwardRef((t, e) => {
  const { value: n, disabled: r = !1, textValue: i, ...o } = t, [s, a] = C.useState();
  xt(() => {
    a(new DocumentFragment());
  }, []);
  const { onTextValueChange: c, textValue: h, ...f } = Br(Fh), d = Ut(), [p, v] = C.useState(i ?? ""), w = f.value === n, { startsWith: b, contains: y } = Lg(f.locale, { sensitivity: "base" }), $ = C.useCallback((A) => {
    v((k) => k || (A?.textContent ?? "").trim());
  }, []);
  return C.useEffect(() => {
    w && h === void 0 && p !== "" && c(p);
  }, [p, w, h, c]), f.autocomplete.type === "both" && p && f.filterValue && !b(p, f.filterValue) || f.autocomplete.type === "list" && f.autocomplete.filter === "startsWith" && p && h && !b(p, h) || f.autocomplete.type === "list" && f.autocomplete.filter === "contains" && p && h && !y(p, h) ? s ? Ys.createPortal(
    /* @__PURE__ */ m(
      f5,
      {
        textId: d,
        onTextValueChange: $,
        isSelected: w,
        textValue: p,
        children: /* @__PURE__ */ m(
          Ls.ItemSlot,
          {
            scope: void 0,
            value: n,
            textValue: p,
            disabled: r,
            type: "option",
            isVisible: !1,
            children: /* @__PURE__ */ m(Z0, { ref: e, value: n, disabled: r, ...o })
          }
        )
      }
    ),
    s
  ) : null : /* @__PURE__ */ m(
    f5,
    {
      textId: d,
      onTextValueChange: $,
      isSelected: w,
      textValue: p,
      children: /* @__PURE__ */ m(
        Ls.ItemSlot,
        {
          scope: void 0,
          value: n,
          textValue: p,
          disabled: r,
          type: "option",
          isVisible: !0,
          children: /* @__PURE__ */ m(Z0, { ref: e, value: n, disabled: r, ...o })
        }
      )
    }
  );
});
Fg.displayName = Fh;
const fx = "ComboboxItemImpl", Z0 = C.forwardRef((t, e) => {
  const { value: n, disabled: r = !1, ...i } = t, o = C.useRef(null), s = ke(e, o), { getItems: a } = Cl(void 0), { onTextValueChange: c, visuallyFocussedItem: h, ...f } = Br(Fh), { isSelected: d, textValue: p, textId: v } = Ng(fx), w = () => {
    r || (f.onValueChange(n), c(p), f.onOpenChange(!1), f.autocomplete.type === "both" && f.onFilterValueChange(p), f.trigger?.focus({ preventScroll: !0 }));
  }, b = C.useMemo(() => h === a().find(($) => $.ref.current === o.current)?.ref.current, [a, h]), y = Ut();
  return /* @__PURE__ */ m(
    we.div,
    {
      role: "option",
      "aria-labelledby": v,
      "data-highlighted": b ? "" : void 0,
      "aria-selected": d && b,
      "data-state": d ? "checked" : "unchecked",
      "aria-disabled": r || void 0,
      "data-disabled": r ? "" : void 0,
      tabIndex: r ? void 0 : -1,
      ...i,
      id: y,
      ref: s,
      onPointerUp: oe(i.onPointerUp, w)
    }
  );
});
Z0.displayName = fx;
const dx = "ComboboxItemText", gx = C.forwardRef((t, e) => {
  const { className: n, style: r, ...i } = t, o = Ng(dx), s = ke(e, o.onTextValueChange);
  return /* @__PURE__ */ m(we.span, { id: o.textId, ...i, ref: s });
});
gx.displayName = dx;
const px = "ComboboxItemIndicator", mx = C.forwardRef((t, e) => {
  const { isSelected: n } = Ng(px);
  return n ? /* @__PURE__ */ m(we.span, { "aria-hidden": !0, ...t, ref: e }) : null;
});
mx.displayName = px;
const Vg = "ComboboxNoValueFound", vx = C.forwardRef((t, e) => {
  const {
    textValue: n = "",
    filterValue: r = "",
    visible: i = !1,
    locale: o,
    autocomplete: s
  } = Br(Vg), [a, c] = C.useState([]), { subscribe: h } = Cl(void 0), { startsWith: f, contains: d } = Lg(o, { sensitivity: "base" });
  return C.useEffect(() => {
    const p = h((v) => {
      if (i) {
        const w = v.filter((b) => b.type !== "create");
        c(w);
      } else
        c(v);
    });
    return () => {
      p();
    };
  }, [i, h]), s.type === "none" && a.length > 0 || s.type === "list" && s.filter === "startsWith" && a.some((p) => f(p.textValue, n)) || s.type === "both" && a.some((p) => f(p.textValue, r)) || s.type === "list" && s.filter === "contains" && a.some((p) => d(p.textValue, n)) ? null : /* @__PURE__ */ m(we.div, { ...t, ref: e });
});
vx.displayName = Vg;
const bx = C.forwardRef((t, e) => {
  const { disabled: n = !1, ...r } = t, i = Br(Vg), { textValue: o, visuallyFocussedItem: s } = i, { getItems: a, subscribe: c } = Cl(void 0), h = C.useRef(null), [f, d] = C.useState(!1), p = ke(e, h), v = C.useMemo(() => s === a().find((y) => y.ref.current === h.current)?.ref.current, [a, s]), w = Ut(), b = () => {
    !n && o && (i.onValueChange(o), i.onTextValueChange(o), i.onOpenChange(!1), i.autocomplete.type === "both" && i.onFilterValueChange(o), i.trigger?.focus({ preventScroll: !0 }));
  };
  return xt(() => {
    const y = c(($) => {
      d(!$.some((A) => A.textValue === o && A.type !== "create"));
    });
    return a().length === 0 && d(!0), () => {
      y();
    };
  }, [o, c, a]), (!o || !f) && !i.visible ? null : /* @__PURE__ */ m(
    Ls.ItemSlot,
    {
      scope: void 0,
      value: o ?? "",
      textValue: o ?? "",
      disabled: n,
      isVisible: !0,
      type: "create",
      children: /* @__PURE__ */ m(
        we.div,
        {
          role: "option",
          tabIndex: n ? void 0 : -1,
          "aria-disabled": n || void 0,
          "data-disabled": n ? "" : void 0,
          "data-highlighted": v ? "" : void 0,
          ...r,
          id: w,
          ref: p,
          onPointerUp: oe(r.onPointerUp, b)
        }
      )
    }
  );
});
bx.displayName = "ComboboxCreateItem";
const fD = cD, dD = nx, gD = ix, pD = ox, mD = sx, vD = ax, bD = hx, wD = Fg, xD = gx, yD = mx, CD = vx, $D = bx;
function SD(t, e) {
  const n = Math.min(t.length, e.length);
  for (let r = 0; r < n; r++)
    if (t[r] !== e[r])
      return r;
  return n;
}
const sr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ComboboxItem: Fg,
  Content: vD,
  CreateItem: $D,
  Icon: pD,
  Item: wD,
  ItemIndicator: yD,
  ItemText: xD,
  NoValueFound: CD,
  Portal: mD,
  Root: fD,
  TextInput: gD,
  Trigger: dD,
  Viewport: bD
}, Symbol.toStringTag, { value: "Module" }));
function Hg(t) {
  const e = C.useRef(t);
  return C.useEffect(() => {
    e.current = t;
  }), C.useMemo(() => (...n) => e.current?.(...n), []);
}
const AD = [" ", "Enter", "ArrowUp", "ArrowDown"], kD = [" ", "Enter"], $l = "Select", [Vh, Sl, MD] = Bh($l), [ea, TD] = Tt($l, [
  MD,
  Yi
]), Hh = Yi(), [RD, mi] = ea($l), [ED, OD] = ea($l), Pg = (t) => {
  const {
    __scopeSelect: e,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: o,
    value: s,
    defaultValue: a,
    onValueChange: c,
    dir: h,
    // name,
    // autoComplete,
    disabled: f,
    required: d,
    multi: p = !1
  } = t, v = Hh(e), [w, b] = C.useState(null), [y, $] = C.useState(null), [A, k] = C.useState(!1), T = Fo(h), [R = !1, _] = zt({
    prop: r,
    defaultProp: i,
    onChange: o
  }), [D, P] = zt({
    prop: s,
    defaultProp: a,
    onChange(K) {
      c && (Array.isArray(K), c(K));
    }
  }), H = C.useRef(null), [z, j] = C.useState(/* @__PURE__ */ new Set());
  return /* @__PURE__ */ m(ml, { ...v, children: /* @__PURE__ */ m(
    RD,
    {
      required: d,
      scope: e,
      trigger: w,
      onTriggerChange: b,
      valueNode: y,
      onValueNodeChange: $,
      valueNodeHasChildren: A,
      onValueNodeHasChildrenChange: k,
      contentId: Ut(),
      value: D,
      onValueChange: P,
      open: R,
      onOpenChange: _,
      dir: T,
      triggerPointerDownPosRef: H,
      disabled: f,
      multi: p,
      children: /* @__PURE__ */ m(Vh.Provider, { scope: e, children: /* @__PURE__ */ m(
        ED,
        {
          scope: t.__scopeSelect,
          onNativeOptionAdd: C.useCallback((K) => {
            j((te) => new Set(te).add(K));
          }, []),
          onNativeOptionRemove: C.useCallback((K) => {
            j((te) => {
              const ee = new Set(te);
              return ee.delete(K), ee;
            });
          }, []),
          children: n
        }
      ) })
    }
  ) });
};
Pg.displayName = $l;
const wx = "SelectTrigger", Wg = C.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, ...r } = t, i = Hh(n), o = mi(wx, n), s = o.disabled, a = ke(e, o.onTriggerChange), c = Sl(n), [h, f, d] = Tx((v) => {
      const w = c().filter(($) => !$.disabled), b = w.find(($) => $.value === o.value), y = Rx(w, v, b);
      if (y !== void 0 && !Array.isArray(y.value)) {
        const $ = o.multi ? [y.value] : y.value;
        o.onValueChange($);
      }
    }), p = () => {
      s || (o.onOpenChange(!0), d());
    };
    return /* @__PURE__ */ m(vl, { asChild: !0, ...i, children: /* @__PURE__ */ m(
      we.div,
      {
        role: "combobox",
        "aria-controls": o.contentId,
        "aria-expanded": o.open,
        "aria-required": o.required,
        "aria-autocomplete": "none",
        dir: o.dir,
        "data-state": o.open ? "open" : "closed",
        "data-disabled": s ? "" : void 0,
        "data-placeholder": o.value === void 0 ? "" : void 0,
        tabIndex: s ? void 0 : 0,
        ...r,
        ref: a,
        onClick: oe(r.onClick, (v) => {
          v.currentTarget.focus();
        }),
        onPointerDown: oe(r.onPointerDown, (v) => {
          const w = v.target;
          w.hasPointerCapture(v.pointerId) && w.releasePointerCapture(v.pointerId), (w.closest("button") ?? w.closest("div")) === v.currentTarget && v.button === 0 && v.ctrlKey === !1 && (p(), o.triggerPointerDownPosRef.current = {
            x: Math.round(v.pageX),
            y: Math.round(v.pageY)
          }, v.preventDefault());
        }),
        onKeyDown: oe(r.onKeyDown, (v) => {
          const w = h.current !== "", b = v.ctrlKey || v.altKey || v.metaKey, y = v.target;
          (y.closest("button") ?? y.closest("div")) === v.currentTarget && (!b && v.key.length === 1 && f(v.key), !(w && v.key === " ") && AD.includes(v.key) && (p(), v.preventDefault()));
        })
      }
    ) });
  }
);
Wg.displayName = wx;
const xx = "SelectValue", zg = C.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, children: r, placeholder: i, ...o } = t, s = mi(xx, n), { onValueNodeHasChildrenChange: a } = s, c = r !== void 0, h = ke(e, s.onValueNodeChange), [f, d] = C.useState([]), p = Sl(n);
    xt(() => {
      a(c);
    }, [a, c]), C.useLayoutEffect(() => {
      if (Array.isArray(s.value) && f.length !== s.value.length) {
        const w = setTimeout(() => {
          const b = p().filter(
            (y) => Array.isArray(y.value) ? !1 : s.value?.includes(y.value)
          );
          d(b);
        });
        return () => {
          clearTimeout(w);
        };
      }
    }, [s.value, p, f]);
    let v;
    if ((s.value === void 0 || s.value.length === 0) && i !== void 0)
      v = /* @__PURE__ */ m("span", { children: i });
    else if (typeof r == "function")
      if (Array.isArray(s.value)) {
        const w = s.value.map((b) => {
          const y = f.find(($) => $.value === b);
          return y ? r({ value: b, textValue: y?.textValue }) : null;
        });
        v = w.every((b) => b === null) ? i : w;
      } else
        v = r(s.value);
    else
      v = r;
    return /* @__PURE__ */ m(we.span, { ...o, ref: h, children: v || null });
  }
);
zg.displayName = xx;
const DD = "SelectIcon", Ug = C.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, children: r, ...i } = t;
    return /* @__PURE__ */ m(we.span, { "aria-hidden": !0, ...i, ref: e, children: r || "▼" });
  }
);
Ug.displayName = DD;
const ID = "SelectPortal", Kg = (t) => /* @__PURE__ */ m(Zs, { asChild: !0, ...t });
Kg.displayName = ID;
const To = "SelectContent", qg = C.forwardRef(
  (t, e) => {
    const n = mi(To, t.__scopeSelect), [r, i] = C.useState();
    if (xt(() => {
      i(new DocumentFragment());
    }, []), !n.open) {
      const o = r;
      return o ? Ys.createPortal(
        /* @__PURE__ */ m(yx, { scope: t.__scopeSelect, children: /* @__PURE__ */ m(Vh.Slot, { scope: t.__scopeSelect, children: /* @__PURE__ */ m("div", { children: t.children }) }) }),
        o
      ) : null;
    }
    return /* @__PURE__ */ m(Cx, { ...t, ref: e });
  }
);
qg.displayName = To;
const ti = 10, [yx, ji] = ea(To), _D = "SelectContentImpl", Cx = C.forwardRef(
  (t, e) => {
    const {
      __scopeSelect: n,
      position: r = "item-aligned",
      onCloseAutoFocus: i,
      onEscapeKeyDown: o,
      onPointerDownOutside: s,
      //
      // PopperContent props
      side: a,
      sideOffset: c,
      align: h,
      alignOffset: f,
      arrowPadding: d,
      collisionBoundary: p,
      collisionPadding: v,
      sticky: w,
      hideWhenDetached: b,
      avoidCollisions: y,
      //
      ...$
    } = t, A = mi(To, n), [k, T] = C.useState(null), [R, _] = C.useState(null), D = ke(e, (xe) => T(xe)), [P, H] = C.useState(null), [z, j] = C.useState(null), K = Sl(n), [te, ee] = C.useState(!1), re = C.useRef(!1);
    C.useEffect(() => {
      if (k)
        return G3(k);
    }, [k]), Qs();
    const de = C.useCallback(
      (xe) => {
        const [Ve, ...Oe] = K().map((je) => je.ref.current), [Ue] = Oe.slice(-1), Ee = document.activeElement;
        for (const je of xe)
          if (je === Ee || (je?.scrollIntoView({ block: "nearest" }), je === Ve && R && (R.scrollTop = 0), je === Ue && R && (R.scrollTop = R.scrollHeight), je?.focus(), document.activeElement !== Ee))
            return;
      },
      [K, R]
    ), ie = C.useCallback(
      () => de([P, k]),
      [de, P, k]
    );
    C.useEffect(() => {
      te && ie();
    }, [te, ie]);
    const { onOpenChange: se, triggerPointerDownPosRef: X } = A;
    C.useEffect(() => {
      if (k) {
        let xe = { x: 0, y: 0 };
        const Ve = (Ue) => {
          xe = {
            x: Math.abs(Math.round(Ue.pageX) - (X.current?.x ?? 0)),
            y: Math.abs(Math.round(Ue.pageY) - (X.current?.y ?? 0))
          };
        }, Oe = (Ue) => {
          xe.x <= 10 && xe.y <= 10 ? Ue.preventDefault() : k.contains(Ue.target) || se(!1), document.removeEventListener("pointermove", Ve), X.current = null;
        };
        return X.current !== null && (document.addEventListener("pointermove", Ve), document.addEventListener("pointerup", Oe, { capture: !0, once: !0 })), () => {
          document.removeEventListener("pointermove", Ve), document.removeEventListener("pointerup", Oe, { capture: !0 });
        };
      }
    }, [k, se, X]), C.useEffect(() => {
      const xe = () => se(!1);
      return window.addEventListener("blur", xe), window.addEventListener("resize", xe), () => {
        window.removeEventListener("blur", xe), window.removeEventListener("resize", xe);
      };
    }, [se]);
    const [ce, be] = Tx((xe) => {
      const Ve = K().filter((Ee) => !Ee.disabled), Oe = Ve.find((Ee) => Ee.ref.current === document.activeElement), Ue = Rx(Ve, xe, Oe);
      Ue && setTimeout(() => Ue.ref.current.focus());
    }), Le = C.useCallback(
      (xe, Ve, Oe) => {
        const Ue = !re.current && !Oe;
        (A.value !== void 0 && A.value === Ve || Ue) && (H(xe), Ue && (re.current = !0));
      },
      [A.value]
    ), Ae = C.useCallback(() => k?.focus(), [k]), qe = C.useCallback(
      (xe, Ve, Oe) => {
        const Ue = !re.current && !Oe;
        (A.value !== void 0 && (Array.isArray(Ve) ? Ve.every((je) => A.value?.includes(je)) : A.value === Ve) || Ue) && j(xe);
      },
      [A.value]
    ), He = r === "popper" ? Q0 : $x, Ze = He === Q0 ? {
      side: a,
      sideOffset: c,
      align: h,
      alignOffset: f,
      arrowPadding: d,
      collisionBoundary: p,
      collisionPadding: v,
      sticky: w,
      hideWhenDetached: b,
      avoidCollisions: y
    } : {};
    return /* @__PURE__ */ m(
      yx,
      {
        scope: n,
        content: k,
        viewport: R,
        onViewportChange: _,
        itemRefCallback: Le,
        selectedItem: P,
        onItemLeave: Ae,
        itemTextRefCallback: qe,
        focusSelectedItem: ie,
        selectedItemText: z,
        position: r,
        isPositioned: te,
        searchRef: ce,
        children: /* @__PURE__ */ m(Lh, { as: Dr, allowPinchZoom: !0, children: /* @__PURE__ */ m(
          Js,
          {
            asChild: !0,
            trapped: A.open,
            onMountAutoFocus: (xe) => {
              xe.preventDefault();
            },
            onUnmountAutoFocus: oe(i, (xe) => {
              A.trigger?.focus({ preventScroll: !0 }), document.getSelection()?.empty(), xe.preventDefault();
            }),
            children: /* @__PURE__ */ m(
              No,
              {
                asChild: !0,
                disableOutsidePointerEvents: !0,
                onEscapeKeyDown: o,
                onPointerDownOutside: s,
                onFocusOutside: (xe) => xe.preventDefault(),
                onDismiss: () => A.onOpenChange(!1),
                children: /* @__PURE__ */ m(
                  He,
                  {
                    role: "listbox",
                    id: A.contentId,
                    "data-state": A.open ? "open" : "closed",
                    "aria-multiselectable": A.multi ? "true" : void 0,
                    dir: A.dir,
                    onContextMenu: (xe) => xe.preventDefault(),
                    ...$,
                    ...Ze,
                    onPlaced: () => ee(!0),
                    ref: D,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...$.style
                    },
                    onKeyDown: oe($.onKeyDown, (xe) => {
                      const Ve = xe.ctrlKey || xe.altKey || xe.metaKey;
                      if (xe.key === "Tab" && xe.preventDefault(), !Ve && xe.key.length === 1 && be(xe.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(xe.key)) {
                        let Ue = K().filter((Ee) => !Ee.disabled).map((Ee) => Ee.ref.current);
                        if (["ArrowUp", "End"].includes(xe.key) && (Ue = Ue.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(xe.key)) {
                          const Ee = xe.target, je = Ue.indexOf(Ee);
                          Ue = Ue.slice(je + 1);
                        }
                        setTimeout(() => de(Ue)), xe.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
Cx.displayName = _D;
const LD = "SelectItemAlignedPosition", $x = C.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, onPlaced: r, ...i } = t, o = mi(To, n), s = ji(To, n), [a, c] = C.useState(null), [h, f] = C.useState(null), d = ke(e, (D) => f(D)), p = Sl(n), v = C.useRef(!1), w = C.useRef(!0), { viewport: b, selectedItem: y, selectedItemText: $, focusSelectedItem: A } = s, k = C.useCallback(() => {
      if (o.trigger && o.valueNode && a && h && b && y && $) {
        const D = o.trigger.getBoundingClientRect(), P = h.getBoundingClientRect(), H = o.valueNode.getBoundingClientRect(), z = $.getBoundingClientRect();
        if (o.dir !== "rtl") {
          const Ee = z.left - P.left, je = H.left - Ee, Rt = D.left - je, at = D.width + Rt, Qe = Math.max(at, P.width), an = window.innerWidth - ti, Ct = X0(je, [ti, an - Qe]);
          a.style.minWidth = `${at}px`, a.style.left = `${Ct}px`;
        } else {
          const Ee = P.right - z.right, je = window.innerWidth - H.right - Ee, Rt = window.innerWidth - D.right - je, at = D.width + Rt, Qe = Math.max(at, P.width), an = window.innerWidth - ti, Ct = X0(je, [ti, an - Qe]);
          a.style.minWidth = `${at}px`, a.style.right = `${Ct}px`;
        }
        const j = p(), K = window.innerHeight - ti * 2, te = b.scrollHeight, ee = window.getComputedStyle(h), re = parseInt(ee.borderTopWidth, 10), de = parseInt(ee.paddingTop, 10), ie = parseInt(ee.borderBottomWidth, 10), se = parseInt(ee.paddingBottom, 10), X = re + de + te + se + ie, ce = Math.min(y.offsetHeight * 5, X), be = window.getComputedStyle(b), Le = parseInt(be.paddingTop, 10), Ae = parseInt(be.paddingBottom, 10), qe = D.top + D.height / 2 - ti, He = K - qe, Ze = y.offsetHeight / 2, xe = y.offsetTop + Ze, Ve = re + de + xe, Oe = X - Ve;
        if (Ve <= qe) {
          const Ee = y === j[j.length - 1].ref.current;
          a.style.bottom = "0px";
          const je = h.clientHeight - b.offsetTop - b.offsetHeight, Rt = Math.max(
            He,
            Ze + // viewport might have padding bottom, include it to avoid a scrollable viewport
            (Ee ? Ae : 0) + je + ie
          ), at = Ve + Rt;
          a.style.height = `${at}px`;
        } else {
          const Ee = y === j[0].ref.current;
          a.style.top = "0px";
          const Rt = Math.max(
            qe,
            re + b.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
            (Ee ? Le : 0) + Ze
          ) + Oe;
          a.style.height = `${Rt}px`, b.scrollTop = Ve - qe + b.offsetTop;
        }
        a.style.margin = `${ti}px 0`, a.style.minHeight = `${ce}px`, a.style.maxHeight = `${K}px`, r?.(), requestAnimationFrame(() => v.current = !0);
      }
    }, [
      p,
      o.trigger,
      o.valueNode,
      a,
      h,
      b,
      y,
      $,
      o.dir,
      r
    ]);
    xt(() => k(), [k]);
    const [T, R] = C.useState();
    xt(() => {
      h && R(window.getComputedStyle(h).zIndex);
    }, [h]);
    const _ = C.useCallback(
      (D) => {
        D && w.current === !0 && (k(), A?.(), w.current = !1);
      },
      [k, A]
    );
    return /* @__PURE__ */ m(
      ND,
      {
        scope: n,
        contentWrapper: a,
        shouldExpandOnScrollRef: v,
        onScrollButtonChange: _,
        children: /* @__PURE__ */ m(
          "div",
          {
            ref: c,
            style: {
              display: "flex",
              flexDirection: "column",
              position: "fixed",
              zIndex: T
            },
            children: /* @__PURE__ */ m(
              we.div,
              {
                ...i,
                ref: d,
                style: {
                  // When we get the height of the content, it includes borders. If we were to set
                  // the height without having `boxSizing: 'border-box'` it would be too big.
                  boxSizing: "border-box",
                  // We need to ensure the content doesn't get taller than the wrapper
                  maxHeight: "100%",
                  ...i.style
                }
              }
            )
          }
        )
      }
    );
  }
);
$x.displayName = LD;
const BD = "SelectPopperPosition", Q0 = C.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, align: r = "start", collisionPadding: i = ti, ...o } = t, s = Hh(n);
    return /* @__PURE__ */ m(
      bl,
      {
        ...s,
        ...o,
        ref: e,
        align: r,
        collisionPadding: i,
        style: {
          // Ensure border-box for floating-ui calculations
          boxSizing: "border-box",
          ...o.style,
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
Q0.displayName = BD;
const [ND, Gg] = ea(
  To,
  {}
), J0 = "SelectViewport", Yg = C.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, ...r } = t, i = ji(J0, n), o = Gg(J0, n), s = ke(e, i.onViewportChange), a = C.useRef(0);
    return /* @__PURE__ */ ae(Gs, { children: [
      /* @__PURE__ */ m(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
          }
        }
      ),
      /* @__PURE__ */ m(Vh.Slot, { scope: n, children: /* @__PURE__ */ m(
        we.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...r,
          ref: s,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            overflow: "auto",
            ...r.style
          },
          onScroll: oe(r.onScroll, (c) => {
            const h = c.currentTarget, { contentWrapper: f, shouldExpandOnScrollRef: d } = o;
            if (d?.current && f) {
              const p = Math.abs(a.current - h.scrollTop);
              if (p > 0) {
                const v = window.innerHeight - ti * 2, w = parseFloat(f.style.minHeight), b = parseFloat(f.style.height), y = Math.max(w, b);
                if (y < v) {
                  const $ = y + p, A = Math.min(v, $), k = $ - A;
                  f.style.height = `${A}px`, f.style.bottom === "0px" && (h.scrollTop = k > 0 ? k : 0, f.style.justifyContent = "flex-end");
                }
              }
            }
            a.current = h.scrollTop;
          })
        }
      ) })
    ] });
  }
);
Yg.displayName = J0;
const Sx = "SelectGroup", [FD, VD] = ea(Sx), jg = C.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, ...r } = t, i = Ut();
    return /* @__PURE__ */ m(FD, { scope: n, id: i, children: /* @__PURE__ */ m(we.div, { role: "group", "aria-labelledby": i, ...r, ref: e }) });
  }
);
jg.displayName = Sx;
const Ax = "SelectLabel", Xg = C.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, ...r } = t, i = VD(Ax, n);
    return /* @__PURE__ */ m(we.div, { id: i.id, ...r, ref: e });
  }
);
Xg.displayName = Ax;
const Fu = "SelectItem", [HD, kx] = ea(Fu), Zg = C.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, value: r, disabled: i = !1, textValue: o, ...s } = t, a = mi(Fu, n), c = ji(Fu, n), h = typeof r == "string" ? Array.isArray(a.value) ? a.value.includes(r) : a.value === r : r.every((A) => a.value?.includes(A)), f = Array.isArray(a.value) && Array.isArray(r) && r.some((A) => a.value?.includes(A)), [d, p] = C.useState(o ?? ""), [v, w] = C.useState(!1), b = ke(
      e,
      (A) => c.itemRefCallback?.(A, r, i)
    ), y = Ut(), $ = () => {
      if (!i) {
        let A = a.multi && typeof r == "string" ? [r] : r;
        f && !h ? a.onValueChange(A) : Array.isArray(a.value) && (A = Ex(r, a.value)), a.onValueChange(A), a.multi || a.onOpenChange(!1);
      }
    };
    if (!a.multi && Array.isArray(r))
      throw new Error("You can only pass an array of values in multi selects");
    return /* @__PURE__ */ m(
      HD,
      {
        scope: n,
        value: r,
        disabled: i,
        textId: y,
        isSelected: h,
        isIntermediate: f,
        onItemTextChange: C.useCallback((A) => {
          p((k) => k || (A?.textContent ?? "").trim());
        }, []),
        children: /* @__PURE__ */ m(Vh.ItemSlot, { scope: n, value: r, disabled: i, textValue: d, children: /* @__PURE__ */ m(
          we.div,
          {
            role: "option",
            "aria-labelledby": y,
            "data-highlighted": v ? "" : void 0,
            "aria-selected": a.multi ? void 0 : h && v,
            "aria-checked": a.multi ? h : void 0,
            "data-state": h ? "checked" : "unchecked",
            "aria-disabled": i || void 0,
            "data-disabled": i ? "" : void 0,
            tabIndex: i ? void 0 : -1,
            ...s,
            ref: b,
            onFocus: oe(s.onFocus, () => w(!0)),
            onBlur: oe(s.onBlur, () => w(!1)),
            onPointerUp: oe(s.onPointerUp, $),
            onPointerMove: oe(s.onPointerMove, (A) => {
              i ? c.onItemLeave?.() : A.currentTarget.focus({ preventScroll: !0 });
            }),
            onPointerLeave: oe(s.onPointerLeave, (A) => {
              A.currentTarget === document.activeElement && c.onItemLeave?.();
            }),
            onKeyDown: oe(s.onKeyDown, (A) => {
              c.searchRef?.current !== "" && A.key === " " || (kD.includes(A.key) && $(), A.key === " " && A.preventDefault());
            })
          }
        ) })
      }
    );
  }
);
Zg.displayName = Fu;
const Oa = "SelectItemText", Qg = C.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, className: r, style: i, ...o } = t, s = mi(Oa, n), a = ji(Oa, n), c = kx(Oa, n), h = OD(Oa, n), [f, d] = C.useState(null), p = ke(
      e,
      ($) => d($),
      c.onItemTextChange,
      ($) => a.itemTextRefCallback?.($, c.value, c.disabled)
    ), v = f?.textContent, w = C.useMemo(
      () => /* @__PURE__ */ m(
        "option",
        {
          value: c.value,
          disabled: c.disabled,
          children: v
        },
        Array.isArray(c.value) ? c.value.join(";") : c.value
      ),
      [c.disabled, c.value, v]
    ), { onNativeOptionAdd: b, onNativeOptionRemove: y } = h;
    return xt(() => (b(w), () => y(w)), [b, y, w]), /* @__PURE__ */ ae(Gs, { children: [
      /* @__PURE__ */ m(we.span, { id: c.textId, ...o, ref: p }),
      c.isSelected && s.valueNode && !s.valueNodeHasChildren ? Ys.createPortal(o.children, s.valueNode) : null
    ] });
  }
);
Qg.displayName = Oa;
const Mx = "SelectItemIndicator", Jg = C.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, children: r, ...i } = t, o = kx(Mx, n);
    return typeof r == "function" ? /* @__PURE__ */ m(we.span, { "aria-hidden": !0, ...i, ref: e, children: r({
      isSelected: o.isSelected,
      isIntermediate: o.isIntermediate
    }) }) : o.isSelected ? /* @__PURE__ */ m(we.span, { "aria-hidden": !0, ...i, ref: e, children: r }) : null;
  }
);
Jg.displayName = Mx;
const e1 = "SelectScrollUpButton", ep = C.forwardRef(
  (t, e) => {
    const n = ji(e1, t.__scopeSelect), r = Gg(e1, t.__scopeSelect), [i, o] = C.useState(!1), s = ke(e, r.onScrollButtonChange);
    return xt(() => {
      if (n.viewport && n.isPositioned) {
        const a = n.viewport, c = () => {
          const h = a.scrollTop > 0;
          o(h);
        };
        return c(), a.addEventListener("scroll", c), () => a.removeEventListener("scroll", c);
      }
    }, [n.viewport, n.isPositioned]), i ? /* @__PURE__ */ m(
      np,
      {
        ...t,
        ref: s,
        onAutoScroll: () => {
          const { viewport: a, selectedItem: c } = n;
          a && c && (a.scrollTop -= c.offsetHeight);
        }
      }
    ) : null;
  }
);
ep.displayName = e1;
const t1 = "SelectScrollDownButton", tp = C.forwardRef(
  (t, e) => {
    const n = ji(t1, t.__scopeSelect), r = Gg(t1, t.__scopeSelect), [i, o] = C.useState(!1), s = ke(e, r.onScrollButtonChange);
    return xt(() => {
      if (n.viewport && n.isPositioned) {
        const a = n.viewport, c = () => {
          const h = a.scrollHeight - a.clientHeight, f = Math.ceil(a.scrollTop) < h;
          o(f);
        };
        return c(), a.addEventListener("scroll", c), () => a.removeEventListener("scroll", c);
      }
    }, [n.viewport, n.isPositioned]), i ? /* @__PURE__ */ m(
      np,
      {
        ...t,
        ref: s,
        onAutoScroll: () => {
          const { viewport: a, selectedItem: c } = n;
          a && c && (a.scrollTop += c.offsetHeight);
        }
      }
    ) : null;
  }
);
tp.displayName = t1;
const np = C.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, onAutoScroll: r, ...i } = t, o = ji("SelectScrollButton", n), s = C.useRef(null), a = Sl(n), c = C.useCallback(() => {
      s.current !== null && (window.clearInterval(s.current), s.current = null);
    }, []);
    return C.useEffect(() => () => c(), [c]), xt(() => {
      a().find((f) => f.ref.current === document.activeElement)?.ref.current?.scrollIntoView({ block: "nearest" });
    }, [a]), /* @__PURE__ */ m(
      we.div,
      {
        "aria-hidden": !0,
        ...i,
        ref: e,
        style: { flexShrink: 0, ...i.style },
        onPointerMove: oe(i.onPointerMove, () => {
          o.onItemLeave?.(), s.current === null && (s.current = window.setInterval(r, 50));
        }),
        onPointerLeave: oe(i.onPointerLeave, () => {
          c();
        })
      }
    );
  }
);
np.displayName = "SelectScrollButtonImpl";
const PD = "SelectSeparator", rp = C.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, ...r } = t;
    return /* @__PURE__ */ m(we.div, { "aria-hidden": !0, ...r, ref: e });
  }
);
rp.displayName = PD;
const n1 = "SelectArrow", ip = C.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, ...r } = t, i = Hh(n), o = mi(n1, n), s = ji(n1, n);
    return o.open && s.position === "popper" ? /* @__PURE__ */ m(zE, { ...i, ...r, ref: e }) : null;
  }
);
ip.displayName = n1;
const WD = "BubbleSelect", zD = C.forwardRef(
  (t, e) => {
    const { value: n, ...r } = t, i = C.useRef(null), o = ke(e, i), s = Nh(n), a = mi(WD, void 0);
    C.useEffect(() => {
      const h = i.current, f = window.HTMLSelectElement.prototype, p = Object.getOwnPropertyDescriptor(f, "value").set;
      if (s !== n && p) {
        const v = new Event("change", { bubbles: !0 });
        p.call(h, n), h.dispatchEvent(v);
      }
    }, [s, n]);
    let c = n;
    return a.multi && !Array.isArray(n) && (c = []), /* @__PURE__ */ m(F3, { asChild: !0, children: /* @__PURE__ */ m(
      "select",
      {
        ...r,
        multiple: a.multi ? !0 : void 0,
        ref: o,
        defaultValue: c
      }
    ) });
  }
);
zD.displayName = "BubbleSelect";
function Tx(t) {
  const e = Hg(t), n = C.useRef(""), r = C.useRef(0), i = C.useCallback(
    (s) => {
      const a = n.current + s;
      e(a), function c(h) {
        n.current = h, window.clearTimeout(r.current), h !== "" && (r.current = window.setTimeout(() => c(""), 1e3));
      }(a);
    },
    [e]
  ), o = C.useCallback(() => {
    n.current = "", window.clearTimeout(r.current);
  }, []);
  return C.useEffect(() => () => window.clearTimeout(r.current), []), [n, i, o];
}
function Rx(t, e, n) {
  const i = e.length > 1 && Array.from(e).every((h) => h === e[0]) ? e[0] : e, o = n ? t.indexOf(n) : -1;
  let s = UD(t, Math.max(o, 0));
  i.length === 1 && (s = s.filter((h) => h !== n));
  const c = s.find((h) => h.textValue.toLowerCase().startsWith(i.toLowerCase()));
  return c !== n ? c : void 0;
}
function UD(t, e) {
  return t.map((n, r) => t[(e + r) % t.length]);
}
const Ex = (t, e = []) => {
  if (Array.isArray(t))
    return t.reduce((r, i) => Ex(i, r), e);
  const n = e.indexOf(t);
  return n === -1 ? [...e, t] : [...e.slice(0, n), ...e.slice(n + 1)];
}, KD = Pg, qD = Wg, GD = zg, YD = Ug, jD = Kg, XD = qg, ZD = Yg, QD = jg, JD = Xg, eI = Zg, tI = Qg, nI = Jg, rI = ep, iI = tp, oI = rp, sI = ip, dr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arrow: sI,
  Content: XD,
  Group: QD,
  Icon: YD,
  Item: eI,
  ItemIndicator: nI,
  ItemText: tI,
  Label: JD,
  Portal: jD,
  Root: KD,
  ScrollDownButton: iI,
  ScrollUpButton: rI,
  Select: Pg,
  SelectArrow: ip,
  SelectContent: qg,
  SelectGroup: jg,
  SelectIcon: Ug,
  SelectItem: Zg,
  SelectItemIndicator: Jg,
  SelectItemText: Qg,
  SelectLabel: Xg,
  SelectPortal: Kg,
  SelectScrollDownButton: tp,
  SelectScrollUpButton: ep,
  SelectSeparator: rp,
  SelectTrigger: Wg,
  SelectValue: zg,
  SelectViewport: Yg,
  Separator: oI,
  Trigger: qD,
  Value: GD,
  Viewport: ZD,
  createSelectScope: TD
}, Symbol.toStringTag, { value: "Module" }));
function xo(t, e, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (t?.(i), n === !1 || !i.defaultPrevented)
      return e?.(i);
  };
}
const Ox = "Collapsible", [aI, Dx] = Tt(Ox), [lI, op] = aI(Ox), cI = /* @__PURE__ */ O((t, e) => {
  const { __scopeCollapsible: n, open: r, defaultOpen: i, disabled: o, onOpenChange: s, ...a } = t, [c = !1, h] = zt({
    prop: r,
    defaultProp: i,
    onChange: s
  });
  return /* @__PURE__ */ B(lI, {
    scope: n,
    disabled: o,
    contentId: Ut(),
    open: c,
    onOpenToggle: rt(
      () => h(
        (f) => !f
      ),
      [
        h
      ]
    )
  }, /* @__PURE__ */ B(we.div, G({
    "data-state": sp(c),
    "data-disabled": o ? "" : void 0
  }, a, {
    ref: e
  })));
}), uI = "CollapsibleTrigger", hI = /* @__PURE__ */ O((t, e) => {
  const { __scopeCollapsible: n, ...r } = t, i = op(uI, n);
  return /* @__PURE__ */ B(we.button, G({
    type: "button",
    "aria-controls": i.contentId,
    "aria-expanded": i.open || !1,
    "data-state": sp(i.open),
    "data-disabled": i.disabled ? "" : void 0,
    disabled: i.disabled
  }, r, {
    ref: e,
    onClick: oe(t.onClick, i.onOpenToggle)
  }));
}), Ix = "CollapsibleContent", fI = /* @__PURE__ */ O((t, e) => {
  const { forceMount: n, ...r } = t, i = op(Ix, t.__scopeCollapsible);
  return /* @__PURE__ */ B(
    Vt,
    {
      present: n || i.open
    },
    ({ present: o }) => /* @__PURE__ */ B(dI, G({}, r, {
      ref: e,
      present: o
    }))
  );
}), dI = /* @__PURE__ */ O((t, e) => {
  const { __scopeCollapsible: n, present: r, children: i, ...o } = t, s = op(Ix, n), [a, c] = De(r), h = ue(null), f = ke(e, h), d = ue(0), p = d.current, v = ue(0), w = v.current, b = s.open || a, y = ue(b), $ = ue();
  return Ce(() => {
    const A = requestAnimationFrame(
      () => y.current = !1
    );
    return () => cancelAnimationFrame(A);
  }, []), xt(() => {
    const A = h.current;
    if (A) {
      $.current = $.current || {
        transitionDuration: A.style.transitionDuration,
        animationName: A.style.animationName
      }, A.style.transitionDuration = "0s", A.style.animationName = "none";
      const k = A.getBoundingClientRect();
      d.current = k.height, v.current = k.width, y.current || (A.style.transitionDuration = $.current.transitionDuration, A.style.animationName = $.current.animationName), c(r);
    }
  }, [
    s.open,
    r
  ]), /* @__PURE__ */ B(we.div, G({
    "data-state": sp(s.open),
    "data-disabled": s.disabled ? "" : void 0,
    id: s.contentId,
    hidden: !b
  }, o, {
    ref: f,
    style: {
      "--radix-collapsible-content-height": p ? `${p}px` : void 0,
      "--radix-collapsible-content-width": w ? `${w}px` : void 0,
      ...t.style
    }
  }), b && i);
});
function sp(t) {
  return t ? "open" : "closed";
}
const gI = cI, pI = hI, mI = fI, Xi = "Accordion", vI = [
  "Home",
  "End",
  "ArrowDown",
  "ArrowUp",
  "ArrowLeft",
  "ArrowRight"
], [ap, bI, wI] = Bh(Xi), [Ph, tte] = Tt(Xi, [
  wI,
  Dx
]), lp = Dx(), _x = /* @__PURE__ */ ze.forwardRef((t, e) => {
  const { type: n, ...r } = t, i = r, o = r;
  return /* @__PURE__ */ ze.createElement(ap.Provider, {
    scope: t.__scopeAccordion
  }, n === "multiple" ? /* @__PURE__ */ ze.createElement($I, G({}, o, {
    ref: e
  })) : /* @__PURE__ */ ze.createElement(CI, G({}, i, {
    ref: e
  })));
});
_x.propTypes = {
  type(t) {
    const e = t.value || t.defaultValue;
    return t.type && ![
      "single",
      "multiple"
    ].includes(t.type) ? new Error("Invalid prop `type` supplied to `Accordion`. Expected one of `single | multiple`.") : t.type === "multiple" && typeof e == "string" ? new Error("Invalid prop `type` supplied to `Accordion`. Expected `single` when `defaultValue` or `value` is type `string`.") : t.type === "single" && Array.isArray(e) ? new Error("Invalid prop `type` supplied to `Accordion`. Expected `multiple` when `defaultValue` or `value` is type `string[]`.") : null;
  }
};
const [Lx, xI] = Ph(Xi), [Bx, yI] = Ph(Xi, {
  collapsible: !1
}), CI = /* @__PURE__ */ ze.forwardRef((t, e) => {
  const { value: n, defaultValue: r, onValueChange: i = () => {
  }, collapsible: o = !1, ...s } = t, [a, c] = zt({
    prop: n,
    defaultProp: r,
    onChange: i
  });
  return /* @__PURE__ */ ze.createElement(Lx, {
    scope: t.__scopeAccordion,
    value: a ? [
      a
    ] : [],
    onItemOpen: c,
    onItemClose: ze.useCallback(
      () => o && c(""),
      [
        o,
        c
      ]
    )
  }, /* @__PURE__ */ ze.createElement(Bx, {
    scope: t.__scopeAccordion,
    collapsible: o
  }, /* @__PURE__ */ ze.createElement(Nx, G({}, s, {
    ref: e
  }))));
}), $I = /* @__PURE__ */ ze.forwardRef((t, e) => {
  const { value: n, defaultValue: r, onValueChange: i = () => {
  }, ...o } = t, [s = [], a] = zt({
    prop: n,
    defaultProp: r,
    onChange: i
  }), c = ze.useCallback(
    (f) => a(
      (d = []) => [
        ...d,
        f
      ]
    ),
    [
      a
    ]
  ), h = ze.useCallback(
    (f) => a(
      (d = []) => d.filter(
        (p) => p !== f
      )
    ),
    [
      a
    ]
  );
  return /* @__PURE__ */ ze.createElement(Lx, {
    scope: t.__scopeAccordion,
    value: s,
    onItemOpen: c,
    onItemClose: h
  }, /* @__PURE__ */ ze.createElement(Bx, {
    scope: t.__scopeAccordion,
    collapsible: !0
  }, /* @__PURE__ */ ze.createElement(Nx, G({}, o, {
    ref: e
  }))));
}), [SI, Wh] = Ph(Xi), Nx = /* @__PURE__ */ ze.forwardRef((t, e) => {
  const { __scopeAccordion: n, disabled: r, dir: i, orientation: o = "vertical", ...s } = t, a = ze.useRef(null), c = ke(a, e), h = bI(n), d = Fo(i) === "ltr", p = oe(t.onKeyDown, (v) => {
    var w;
    if (!vI.includes(v.key)) return;
    const b = v.target, y = h().filter((H) => {
      var z;
      return !((z = H.ref.current) !== null && z !== void 0 && z.disabled);
    }), $ = y.findIndex(
      (H) => H.ref.current === b
    ), A = y.length;
    if ($ === -1) return;
    v.preventDefault();
    let k = $;
    const T = 0, R = A - 1, _ = () => {
      k = $ + 1, k > R && (k = T);
    }, D = () => {
      k = $ - 1, k < T && (k = R);
    };
    switch (v.key) {
      case "Home":
        k = T;
        break;
      case "End":
        k = R;
        break;
      case "ArrowRight":
        o === "horizontal" && (d ? _() : D());
        break;
      case "ArrowDown":
        o === "vertical" && _();
        break;
      case "ArrowLeft":
        o === "horizontal" && (d ? D() : _());
        break;
      case "ArrowUp":
        o === "vertical" && D();
        break;
    }
    const P = k % A;
    (w = y[P].ref.current) === null || w === void 0 || w.focus();
  });
  return /* @__PURE__ */ ze.createElement(SI, {
    scope: n,
    disabled: r,
    direction: i,
    orientation: o
  }, /* @__PURE__ */ ze.createElement(ap.Slot, {
    scope: n
  }, /* @__PURE__ */ ze.createElement(we.div, G({}, s, {
    "data-orientation": o,
    ref: c,
    onKeyDown: r ? void 0 : p
  }))));
}), r1 = "AccordionItem", [AI, cp] = Ph(r1), kI = /* @__PURE__ */ ze.forwardRef((t, e) => {
  const { __scopeAccordion: n, value: r, ...i } = t, o = Wh(r1, n), s = xI(r1, n), a = lp(n), c = Ut(), h = r && s.value.includes(r) || !1, f = o.disabled || t.disabled;
  return /* @__PURE__ */ ze.createElement(AI, {
    scope: n,
    open: h,
    disabled: f,
    triggerId: c
  }, /* @__PURE__ */ ze.createElement(gI, G({
    "data-orientation": o.orientation,
    "data-state": Fx(h)
  }, a, i, {
    ref: e,
    disabled: f,
    open: h,
    onOpenChange: (d) => {
      d ? s.onItemOpen(r) : s.onItemClose(r);
    }
  })));
}), MI = "AccordionHeader", TI = /* @__PURE__ */ ze.forwardRef((t, e) => {
  const { __scopeAccordion: n, ...r } = t, i = Wh(Xi, n), o = cp(MI, n);
  return /* @__PURE__ */ ze.createElement(we.h3, G({
    "data-orientation": i.orientation,
    "data-state": Fx(o.open),
    "data-disabled": o.disabled ? "" : void 0
  }, r, {
    ref: e
  }));
}), d5 = "AccordionTrigger", RI = /* @__PURE__ */ ze.forwardRef((t, e) => {
  const { __scopeAccordion: n, ...r } = t, i = Wh(Xi, n), o = cp(d5, n), s = yI(d5, n), a = lp(n);
  return /* @__PURE__ */ ze.createElement(ap.ItemSlot, {
    scope: n
  }, /* @__PURE__ */ ze.createElement(pI, G({
    "aria-disabled": o.open && !s.collapsible || void 0,
    "data-orientation": i.orientation,
    id: o.triggerId
  }, a, r, {
    ref: e
  })));
}), EI = "AccordionContent", OI = /* @__PURE__ */ ze.forwardRef((t, e) => {
  const { __scopeAccordion: n, ...r } = t, i = Wh(Xi, n), o = cp(EI, n), s = lp(n);
  return /* @__PURE__ */ ze.createElement(mI, G({
    role: "region",
    "aria-labelledby": o.triggerId,
    "data-orientation": i.orientation
  }, s, r, {
    ref: e,
    style: {
      "--radix-accordion-content-height": "var(--radix-collapsible-content-height)",
      "--radix-accordion-content-width": "var(--radix-collapsible-content-width)",
      ...t.style
    }
  }));
});
function Fx(t) {
  return t ? "open" : "closed";
}
const DI = _x, II = kI, _I = TI, LI = RI, BI = OI, NI = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M16 2A12.014 12.014 0 0 0 4 14c0 3 1.57 6.883 4.201 10.375C10.85 27.894 13.764 30 16 30s5.151-2.101 7.799-5.625C26.43 20.875 28 17 28 14A12.014 12.014 0 0 0 16 2M8 14.5A1.5 1.5 0 0 1 9.5 13a4.5 4.5 0 0 1 4.5 4.5 1.5 1.5 0 0 1-1.5 1.5A4.5 4.5 0 0 1 8 14.5M18 25h-4a1 1 0 0 1 0-2h4a1 1 0 0 1 0 2m1.5-6a1.5 1.5 0 0 1-1.5-1.5 4.5 4.5 0 0 1 4.5-4.5 1.5 1.5 0 0 1 1.5 1.5 4.5 4.5 0 0 1-4.5 4.5" }) });
};
O(NI);
const FI = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M28 6H4a2 2 0 0 0-2 2v3a2 2 0 0 0 2 2v11a2 2 0 0 0 2 2h20a2 2 0 0 0 2-2V13a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2m-9 12h-6a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2m9-7H4V8h24z" }) });
};
O(FI);
const VI = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M30.5 7v6a1.5 1.5 0 0 1-1.5 1.5h-6a1.5 1.5 0 0 1 0-3h2.137l-2.375-2.173-.047-.046a9.5 9.5 0 1 0-6.84 16.219H16a9.44 9.44 0 0 0 6.519-2.59 1.5 1.5 0 1 1 2.061 2.181A12.43 12.43 0 0 1 16 28.5h-.171a12.5 12.5 0 1 1 8.985-21.368L27.5 9.59V7a1.5 1.5 0 0 1 3 0" }) });
}, HI = O(VI), nte = HI, PI = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "m26.061 19.061-9 9a1.503 1.503 0 0 1-2.125 0l-9-9a1.503 1.503 0 1 1 2.125-2.125l6.439 6.439V5a1.5 1.5 0 1 1 3 0v18.375l6.439-6.44a1.502 1.502 0 1 1 2.125 2.125z" }) });
};
O(PI);
const WI = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M28.5 16a1.5 1.5 0 0 1-1.5 1.5H8.625l6.44 6.439a1.502 1.502 0 1 1-2.125 2.125l-9-9a1.5 1.5 0 0 1 0-2.125l9-9a1.503 1.503 0 0 1 2.125 2.125L8.625 14.5H27a1.5 1.5 0 0 1 1.5 1.5" }) });
};
O(WI);
const zI = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: o, viewBox: "0 0 16 16", stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M14.75 8a.75.75 0 0 1-.75.75H6.813l3.22 3.22a.751.751 0 1 1-1.063 1.062l-4.5-4.5a.75.75 0 0 1 0-1.063l4.5-4.5a.751.751 0 0 1 1.063 1.063L6.813 7.25H14a.75.75 0 0 1 .75.75M2.5 1.75a.75.75 0 0 0-.75.75v11a.75.75 0 0 0 1.5 0v-11a.75.75 0 0 0-.75-.75" }) });
};
O(zI);
const UI = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: o, viewBox: "0 0 16 16", stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M11.53 7.47a.75.75 0 0 1 0 1.062l-4.5 4.5a.751.751 0 1 1-1.062-1.063l3.22-3.219H2a.75.75 0 1 1 0-1.5h7.188L5.969 4.03a.751.751 0 1 1 1.063-1.062zm1.97-5.72a.75.75 0 0 0-.75.75v11a.75.75 0 0 0 1.5 0v-11a.75.75 0 0 0-.75-.75" }) });
};
O(UI);
const KI = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "m28.061 17.061-9 9a1.503 1.503 0 1 1-2.125-2.125l6.439-6.436H5a1.5 1.5 0 1 1 0-3h18.375l-6.436-6.44a1.503 1.503 0 0 1 2.125-2.125l9 9a1.5 1.5 0 0 1-.003 2.126" }) });
};
O(KI);
const qI = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M26.061 15.061a1.5 1.5 0 0 1-2.125 0L17.5 8.625V27a1.5 1.5 0 1 1-3 0V8.625l-6.439 6.436a1.503 1.503 0 1 1-2.125-2.125l9-9a1.5 1.5 0 0 1 2.125 0l9 9a1.5 1.5 0 0 1 0 2.125" }) });
}, GI = O(qI), rte = GI, YI = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M11 13.5H5A1.5 1.5 0 0 1 3.5 12V6a1.5 1.5 0 0 1 3 0v1.733C8.581 5.683 11.786 3.5 16 3.5c5.558 0 8.92 3.299 9.061 3.439a1.5 1.5 0 0 1-2.117 2.125C22.889 9.01 20.25 6.5 16 6.5c-3.625 0-6.367 2.21-8 4h3a1.5 1.5 0 1 1 0 3m16 5h-6a1.5 1.5 0 1 0 0 3h3c-1.625 1.79-4.375 4-8 4-4.25 0-6.889-2.511-6.944-2.565A1.5 1.5 0 0 0 6.94 25.06c.141.141 3.504 3.44 9.061 3.44 4.214 0 7.419-2.183 9.5-4.233V26a1.5 1.5 0 1 0 3 0v-6a1.5 1.5 0 0 0-1.5-1.5" }) });
};
O(YI);
const jI = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 256 256", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M220 48v48a12 12 0 0 1-24 0V77l-39.51 39.52a12 12 0 0 1-17-17L179 60h-19a12 12 0 0 1 0-24h48a12 12 0 0 1 12 12M99.51 139.51 60 179v-19a12 12 0 0 0-24 0v48a12 12 0 0 0 12 12h48a12 12 0 0 0 0-24H77l39.52-39.51a12 12 0 0 0-17-17Z" }) });
};
O(jI);
const XI = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M27.725 21.993C27.031 20.798 26 17.416 26 13a10 10 0 0 0-20 0c0 4.418-1.032 7.797-1.726 8.993A2 2 0 0 0 6 25h5.101a5 5 0 0 0 9.798 0H26a2 2 0 0 0 1.725-3.008M16 27a3 3 0 0 1-2.828-2h5.656A3 3 0 0 1 16 27" }) });
};
O(XI);
const ZI = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M22.135 14.308A6.001 6.001 0 0 0 17.5 4.5H9A1.5 1.5 0 0 0 7.5 6v19A1.5 1.5 0 0 0 9 26.5h10a6.5 6.5 0 0 0 3.135-12.192M10.5 7.5h7a3 3 0 0 1 0 6h-7zm8.5 16h-8.5v-7H19a3.5 3.5 0 1 1 0 7" }) });
}, QI = O(ZI), ite = QI, JI = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M27 4v20a1 1 0 0 1-1 1H9a2 2 0 0 0-2 2h17a1 1 0 0 1 0 2H6a1 1 0 0 1-1-1V7a4 4 0 0 1 4-4h17a1 1 0 0 1 1 1" }) });
};
O(JI);
const e_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M19 14a1 1 0 0 1-1 1h-4a1 1 0 0 1 0-2h4a1 1 0 0 1 1 1m10-5v16a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h5V6a3 3 0 0 1 3-3h6a3 3 0 0 1 3 3v1h5a2 2 0 0 1 2 2M12 7h8V6a1 1 0 0 0-1-1h-6a1 1 0 0 0-1 1zm15 7.201V9H5v5.201A23 23 0 0 0 16 17a23 23 0 0 0 11-2.799" }) });
};
O(e_);
const t_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M9.5 8A1.5 1.5 0 0 1 11 6.5h16a1.5 1.5 0 0 1 0 3H11A1.5 1.5 0 0 1 9.5 8M27 14.5H11a1.5 1.5 0 1 0 0 3h16a1.5 1.5 0 1 0 0-3m0 8H11a1.5 1.5 0 1 0 0 3h16a1.5 1.5 0 1 0 0-3M5.5 14a2 2 0 1 0 0 4 2 2 0 0 0 0-4m0-8a2 2 0 1 0 0 4 2 2 0 0 0 0-4m0 16a2 2 0 1 0 0 4 2 2 0 0 0 0-4" }) });
}, n_ = O(t_), ote = n_, r_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M26 4h-3V3a1 1 0 0 0-2 0v1H11V3a1 1 0 0 0-2 0v1H6a2 2 0 0 0-2 2v20a2 2 0 0 0 2 2h20a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2m0 6H6V6h3v1a1 1 0 0 0 2 0V6h10v1a1 1 0 0 0 2 0V6h3z" }) });
}, i_ = O(r_), o_ = i_, s_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M30 14h-1.35l-3.472-7.812A2 2 0 0 0 23.35 5H8.65a2 2 0 0 0-1.828 1.188L3.35 14H2a1 1 0 0 0 0 2h1v10a2 2 0 0 0 2 2h3a2 2 0 0 0 2-2v-2h12v2a2 2 0 0 0 2 2h3a2 2 0 0 0 2-2V16h1a1 1 0 0 0 0-2m-20 6H8a1 1 0 0 1 0-2h2a1 1 0 0 1 0 2m12 0a1 1 0 0 1 0-2h2a1 1 0 0 1 0 2z" }) });
};
O(s_);
const a_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "m26.708 12.708-10 10a1 1 0 0 1-1.415 0l-10-10A1 1 0 0 1 6 11h20a1 1 0 0 1 .707 1.707" }) });
}, l_ = O(a_), Wi = l_, c_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M26.924 20.383A1 1 0 0 1 26 21H6a1 1 0 0 1-.708-1.707l10-10a1 1 0 0 1 1.415 0l10 10a1 1 0 0 1 .217 1.09" }) });
};
O(c_);
const u_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M7 26a1 1 0 1 1-2 0 1 1 0 0 0-1-1 1 1 0 0 1 0-2 3 3 0 0 1 3 3m-3-7a1 1 0 0 0 0 2 5 5 0 0 1 5 5 1 1 0 1 0 2 0 7.01 7.01 0 0 0-7-7m0-4a1 1 0 0 0 0 2 9.01 9.01 0 0 1 9 9 1 1 0 0 0 2 0A11.01 11.01 0 0 0 4 15M27 5H5a2 2 0 0 0-2 2v5a1 1 0 0 0 1 1 13.014 13.014 0 0 1 13 13 1 1 0 0 0 1 1h9a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2" }) });
};
O(u_);
const h_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M25 3h-1a2 2 0 0 0-2 2v2h-3.5V5a2 2 0 0 0-2-2h-1a2 2 0 0 0-2 2v2H10V5a2 2 0 0 0-2-2H7a2 2 0 0 0-2 2v5.586A1.98 1.98 0 0 0 5.586 12L7 13.414V27a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V13.414L26.414 12A1.98 1.98 0 0 0 27 10.586V5a2 2 0 0 0-2-2m-6 24h-6v-8a3 3 0 0 1 6 0z" }) });
};
O(h_);
const f_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M27 5H5a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h22a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2m-3.5 4a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3m0 7a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3m-5-2a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3m-3-5a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3m-3 7a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3M25 24H7a1 1 0 0 1-1-1V9a1 1 0 0 1 2 0v13h17a1 1 0 0 1 0 2" }) });
};
O(f_);
const d_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M3.094 14.443a12.8 12.8 0 0 1 2.914-6.72 2 2 0 0 1 2.953-.138l3.459 3.533a1.98 1.98 0 0 1 .211 2.56 3.2 3.2 0 0 0-.462.968.5.5 0 0 1-.478.354h-8.1a.5.5 0 0 1-.497-.557m14.08-11.435A2 2 0 0 0 15 5v5.084a1.98 1.98 0 0 0 1.656 1.97 4 4 0 0 1 .677 7.72.51.51 0 0 0-.333.476v8.154a.5.5 0 0 0 .558.5A13.04 13.04 0 0 0 29 16.185C29.094 9.4 23.899 3.61 17.174 3.008M14.656 19.77a4 4 0 0 1-2.425-2.427.51.51 0 0 0-.475-.343H3.59a.5.5 0 0 0-.5.556A13.01 13.01 0 0 0 14.443 28.91a.5.5 0 0 0 .556-.5V20.25a.51.51 0 0 0-.343-.48" }) });
};
O(d_);
const g_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M16 3a13 13 0 1 0 13 13A13.013 13.013 0 0 0 16 3m0 2a11 11 0 0 1 8.984 4.659L16 14.845zm0 22a11 11 0 0 1-8.984-4.659l18.97-10.951A11 11 0 0 1 16 27" }) });
};
O(g_);
const p_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "m29.061 10.061-16 16a1.5 1.5 0 0 1-2.125 0l-7-7a1.504 1.504 0 0 1 2.125-2.125L12 22.875 26.939 7.939a1.502 1.502 0 1 1 2.125 2.125z" }) });
}, m_ = O(p_), ste = m_, v_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M16 3a13 13 0 1 0 13 13A13.013 13.013 0 0 0 16 3m5.708 10.708-7 7a1 1 0 0 1-1.415 0l-3-3a1 1 0 0 1 1.415-1.415L14 18.586l6.293-6.293a1 1 0 0 1 1.415 1.415" }) });
}, b_ = O(v_), w_ = b_, x_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, viewBox: "0 0 256 256", fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M176.49 95.51a12 12 0 0 1 0 17l-56 56a12 12 0 0 1-17 0l-24-24a12 12 0 1 1 17-17L112 143l47.51-47.52a12 12 0 0 1 16.98.03M236 128A108 108 0 1 1 128 20a108.12 108.12 0 0 1 108 108m-24 0a84 84 0 1 0-84 84 84.09 84.09 0 0 0 84-84" }) });
};
O(x_);
const y_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "m27.061 13.061-10 10a1.503 1.503 0 0 1-2.125 0l-10-10a1.503 1.503 0 1 1 2.125-2.125L16 19.875l8.939-8.94a1.502 1.502 0 1 1 2.125 2.125z" }) });
};
O(y_);
const C_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M21.061 24.939a1.503 1.503 0 0 1-2.125 2.125l-10-10a1.5 1.5 0 0 1 0-2.125l10-10a1.503 1.503 0 0 1 2.125 2.125L12.125 16z" }) });
}, $_ = O(C_), Vx = $_, S_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "m23.061 17.061-10 10a1.503 1.503 0 0 1-2.125-2.125L19.875 16l-8.936-8.939a1.502 1.502 0 1 1 2.125-2.125l10 10a1.5 1.5 0 0 1-.003 2.125" }) });
}, A_ = O(S_), up = A_, k_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M27.061 21.061a1.503 1.503 0 0 1-2.125 0L16 12.125l-8.939 8.936a1.503 1.503 0 0 1-2.125-2.125l10-10a1.5 1.5 0 0 1 2.125 0l10 10a1.5 1.5 0 0 1 0 2.125" }) });
};
O(k_);
const M_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M16 3a13 13 0 1 0 13 13A13.013 13.013 0 0 0 16 3m7 14h-7a1 1 0 0 1-1-1V9a1 1 0 0 1 2 0v6h6a1 1 0 0 1 0 2" }) });
}, T_ = O(M_), R_ = T_, E_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M28 16a12 12 0 0 1-20.236 8.728 1.002 1.002 0 0 1 1.375-1.456 10 10 0 1 0-.21-14.343c-.441.446-.857.885-1.26 1.321l2.039 2.043A1 1 0 0 1 9 14H4a1 1 0 0 1-1-1V8a1 1 0 0 1 1.707-.707L6.25 8.838c.402-.437.817-.875 1.258-1.32A12 12 0 0 1 28 16M16 9a1 1 0 0 0-1 1v6a1 1 0 0 0 .485.858l5 3a.999.999 0 0 0 1.486-1.1 1 1 0 0 0-.456-.616L17 15.434V10a1 1 0 0 0-1-1" }) });
};
O(E_);
const O_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M20.008 5a11.01 11.01 0 0 0-9.847 6.084A10.9 10.9 0 0 0 9 15.966 1.023 1.023 0 0 1 8.071 17 1 1 0 0 1 7 16a13 13 0 0 1 .668-4.115.5.5 0 0 0-.594-.647A8.01 8.01 0 0 0 1 19c0 4.399 3.719 8 8.125 8H20a11.01 11.01 0 0 0 10.991-11.435C30.764 9.693 25.884 5 20.008 5" }) });
};
O(O_);
const D_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M30.991 15.565C30.764 9.693 25.884 5 20.008 5a11.01 11.01 0 0 0-9.847 6.084A10.9 10.9 0 0 0 9 15.966 1.023 1.023 0 0 1 8.071 17 1 1 0 0 1 7 16a13 13 0 0 1 .668-4.115.5.5 0 0 0-.594-.647A8.01 8.01 0 0 0 1 19c0 4.399 3.719 8 8.125 8H20a11.01 11.01 0 0 0 10.991-11.435m-7.283 3.143a1 1 0 0 1-1.415 0L20 16.414V24a1 1 0 0 1-2 0v-7.586l-2.293 2.293a1 1 0 0 1-1.415-1.415l4-4a1 1 0 0 1 1.415 0l4 4a1 1 0 0 1 0 1.415" }) });
};
O(D_);
const I_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M8.96 12.153 4.342 16l4.618 3.848a1.5 1.5 0 1 1-1.92 2.305l-6-5a1.5 1.5 0 0 1 0-2.305l6-5a1.5 1.5 0 0 1 1.92 2.304m22 2.694-6-5a1.5 1.5 0 1 0-1.92 2.306L27.658 16l-4.618 3.848a1.5 1.5 0 1 0 1.92 2.305l6-5a1.5 1.5 0 0 0 0-2.305M20.512 3.59a1.5 1.5 0 0 0-1.922.898l-8 22a1.5 1.5 0 0 0 2.82 1.024l8-22a1.5 1.5 0 0 0-.898-1.922" }) });
}, __ = O(I_), ate = __, L_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, viewBox: "0 0 256 256", fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M200 40h-32a16 16 0 0 0-16-16H32a16 16 0 0 0-16 16v80a16 16 0 0 0 16 16h8v64a16 16 0 0 0 16 16h144a16 16 0 0 0 16-16V56a16 16 0 0 0-16-16m-93.66 21.66a8 8 0 0 1 11.32-11.32l24 24a8 8 0 0 1 0 11.32l-24 24a8 8 0 0 1-11.32-11.32L124.69 80Zm-64 24a8 8 0 0 1 0-11.32l24-24a8 8 0 0 1 11.32 11.32L59.31 80l18.35 18.34a8 8 0 0 1-11.32 11.32ZM200 200H56v-64h96a16 16 0 0 0 16-16V56h32Z" }) });
};
O(L_);
const B_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M26 10H4a1 1 0 0 0-1 1v6a12.04 12.04 0 0 0 4.068 9H4a1 1 0 0 0 0 2h22a1 1 0 0 0 0-2h-3.067a12.1 12.1 0 0 0 3.375-5.011A5 5 0 0 0 31 16v-1a5 5 0 0 0-5-5m3 6a3 3 0 0 1-2.15 2.875Q27 17.944 27 17v-4.828A3 3 0 0 1 29 15zM14 7V3a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0m4 0V3a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0m-8 0V3a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0" }) });
};
O(B_);
const N_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M29.743 13.401a1 1 0 0 0-.487-.675l-3.729-2.125-.015-4.202a1 1 0 0 0-.353-.76 14 14 0 0 0-4.59-2.584 1 1 0 0 0-.808.074L16 5.23l-3.765-2.106a1 1 0 0 0-.809-.075 14 14 0 0 0-4.585 2.594 1 1 0 0 0-.354.758L6.47 10.61 2.74 12.734a1 1 0 0 0-.486.675 13.3 13.3 0 0 0 0 5.195 1 1 0 0 0 .486.675l3.729 2.125.015 4.204a1 1 0 0 0 .353.76 14 14 0 0 0 4.59 2.583 1 1 0 0 0 .808-.073L16 26.768l3.765 2.107a1.013 1.013 0 0 0 .809.073 14 14 0 0 0 4.585-2.592 1 1 0 0 0 .354-.759l.018-4.206 3.729-2.125a1 1 0 0 0 .486-.675c.34-1.713.338-3.477-.003-5.19M16 21a5 5 0 1 1 0-10 5 5 0 0 1 0 10" }) });
};
O(N_);
const F_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M18.5 12V6a1.5 1.5 0 1 1 3 0v4.5H26a1.5 1.5 0 1 1 0 3h-6a1.5 1.5 0 0 1-1.5-1.5M12 18.5H6a1.5 1.5 0 1 0 0 3h4.5V26a1.5 1.5 0 1 0 3 0v-6a1.5 1.5 0 0 0-1.5-1.5m14 0h-6a1.5 1.5 0 0 0-1.5 1.5v6a1.5 1.5 0 1 0 3 0v-4.5H26a1.5 1.5 0 1 0 0-3m-14-14A1.5 1.5 0 0 0 10.5 6v4.5H6a1.5 1.5 0 1 0 0 3h6a1.5 1.5 0 0 0 1.5-1.5V6A1.5 1.5 0 0 0 12 4.5" }) });
}, V_ = O(F_), lte = V_, H_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M22.5 17.5h-2v-3h2a5 5 0 1 0-5-5v2h-3v-2a5 5 0 1 0-5 5h2v3h-2a5 5 0 1 0 5 5v-2h3v2a5 5 0 1 0 5-5m-2-8a2 2 0 1 1 2 2h-2zm-13 0a2 2 0 0 1 4 0v2h-2a2 2 0 0 1-2-2m4 13a2 2 0 1 1-2-2h2zm3-8h3v3h-3zm8 10a2 2 0 0 1-2-2v-2h2a2 2 0 0 1 0 4" }) });
};
O(H_);
const P_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M30.5 24a1.5 1.5 0 0 1-1.5 1.5h-3.5V29a1.5 1.5 0 1 1-3 0v-3.5H8A1.5 1.5 0 0 1 6.5 24V9.5H3a1.5 1.5 0 0 1 0-3h3.5V3a1.5 1.5 0 0 1 3 0v19.5H29a1.5 1.5 0 0 1 1.5 1.5M13 9.5h9.5V19a1.5 1.5 0 1 0 3 0V8A1.5 1.5 0 0 0 24 6.5H13a1.5 1.5 0 0 0 0 3" }) });
};
O(P_);
const W_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M26.061 23.939a1.503 1.503 0 0 1-2.125 2.125L16 18.125l-7.939 7.936a1.503 1.503 0 1 1-2.125-2.125L13.875 16 5.939 8.061a1.503 1.503 0 1 1 2.125-2.125L16 13.875l7.939-7.94a1.502 1.502 0 1 1 2.125 2.125L18.125 16z" }) });
}, z_ = O(W_), Vo = z_, U_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M16 3a13 13 0 1 0 13 13A13.013 13.013 0 0 0 16 3m4.708 16.293a1 1 0 0 1-1.415 1.415L16 17.414l-3.293 3.293a1 1 0 0 1-1.415-1.415L14.587 16l-3.293-3.293a1 1 0 1 1 1.415-1.415L16 14.587l3.293-3.293a1 1 0 0 1 1.415 1.415L17.414 16z" }) });
};
O(U_);
const K_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M30.48 9.524a1.51 1.51 0 0 0-1.668-.213l-6.276 3.125-5.24-8.704a1.514 1.514 0 0 0-2.592 0l-5.24 8.708L3.19 9.315a1.514 1.514 0 0 0-2.113 1.825l4.625 14.17a1 1 0 0 0 1.46.55C7.194 25.841 10.39 24 16 24s8.806 1.841 8.835 1.859a1 1 0 0 0 1.464-.549l4.625-14.166a1.51 1.51 0 0 0-.444-1.62M21.98 19.6a1 1 0 0 1-1.159.811 28.5 28.5 0 0 0-9.652 0 1 1 0 0 1-.348-1.97 30.6 30.6 0 0 1 10.348 0 1 1 0 0 1 .816 1.159z" }) });
};
O(K_);
const q_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M27.414 24a2 2 0 0 1 0 2.829l-.585.585a2 2 0 0 1-2.829 0l-6.906-6.905-2.735 6.292A1.98 1.98 0 0 1 12.533 28h-.098a1.98 1.98 0 0 1-1.801-1.375L4.1 6.615A1.994 1.994 0 0 1 6.615 4.1l20.01 6.534a2 2 0 0 1 .176 3.725l-6.292 2.735z" }) });
};
O(q_);
const G_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M16 3C9.271 3 4 6.075 4 10v12c0 3.925 5.271 7 12 7s12-3.075 12-7V10c0-3.925-5.271-7-12-7m10 13c0 1.203-.985 2.429-2.701 3.365C21.366 20.419 18.774 21 16 21s-5.366-.581-7.299-1.635C6.985 18.429 6 17.203 6 16v-2.08C8.133 15.795 11.779 17 16 17s7.868-1.21 10-3.08zm-2.701 9.365C21.366 26.419 18.774 27 16 27s-5.366-.581-7.299-1.635C6.985 24.429 6 23.203 6 22v-2.08C8.133 21.795 11.779 23 16 23s7.868-1.21 10-3.08V22c0 1.203-.985 2.429-2.701 3.365" }) });
};
O(G_);
const Y_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M29 12a2 2 0 0 0-2-2h-4V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v16a1 1 0 0 0 1.625.777L9 19.25V23a2 2 0 0 0 2 2h11.699l4.676 3.778A1 1 0 0 0 29 28zm-5.319 11.223a1 1 0 0 0-.625-.223H11v-4h10a2 2 0 0 0 2-2v-5h4v13.906z" }) });
};
O(Y_);
const j_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M28.5 19v7a2.5 2.5 0 0 1-2.5 2.5H6A2.5 2.5 0 0 1 3.5 26v-7a1.5 1.5 0 0 1 3 0v6.5h19V19a1.5 1.5 0 1 1 3 0m-13.561 1.061a1.5 1.5 0 0 0 2.125 0l5-5a1.502 1.502 0 1 0-2.125-2.125L17.5 15.375V5a1.5 1.5 0 1 0-3 0v10.375l-2.439-2.436a1.502 1.502 0 1 0-2.125 2.125z" }) });
};
O(j_);
const X_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M13.5 7.5a2 2 0 1 1-4 0 2 2 0 0 1 4 0m7 2a2 2 0 1 0 0-4 2 2 0 0 0 0 4m-9 4.5a2 2 0 1 0 0 4 2 2 0 0 0 0-4m9 0a2 2 0 1 0 0 4 2 2 0 0 0 0-4m-9 8.5a2 2 0 1 0 0 4 2 2 0 0 0 0-4m9 0a2 2 0 1 0 0 4 2 2 0 0 0 0-4" }) });
};
O(X_);
const Z_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M27 4H11a1 1 0 0 0-1 1v5H5a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1v-5h5a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1m-1 16h-4v-9a1 1 0 0 0-1-1h-9V6h14z" }) });
};
O(Z_);
const Q_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M16 3a13 13 0 1 0 13 13A13.013 13.013 0 0 0 16 3m11 13c.001 1.411-.27 2.81-.8 4.118l-5.587-3.437a2 2 0 0 0-.78-.279l-2.853-.385a2.01 2.01 0 0 0-2 .983h-1.09l-.475-.983a1.99 1.99 0 0 0-1.375-1.083l-1-.216.978-1.718h2.088c.338 0 .67-.087.966-.25l1.532-.845q.202-.113.375-.268l3.364-3.042a1.99 1.99 0 0 0 .407-2.458l-.045-.08A11.01 11.01 0 0 1 27 16M5 16a10.94 10.94 0 0 1 1.068-4.725l1.417 3.784a2 2 0 0 0 1.453 1.25l2.678.576.476.99a2.01 2.01 0 0 0 1.8 1.125h.186l-.904 2.029a2 2 0 0 0 .357 2.171l.018.018L16 25.742l-.242 1.25A11.014 11.014 0 0 1 5 16" }) });
};
O(Q_);
const J_ = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ ae("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: [
    /* @__PURE__ */ m("path", { d: "M20.689 3.88A13 13 0 0 0 16 3a13 13 0 0 0-8.155 23.124l1.02-1.765A11 11 0 0 1 5 16a10.94 10.94 0 0 1 1.068-4.724l1.417 3.784a2 2 0 0 0 1.453 1.25l2.678.576.476.99q.113.226.275.418l1.169-2.025-.121-.25a1.99 1.99 0 0 0-1.375-1.084l-1-.217.978-1.717h2.088c.338 0 .67-.087.966-.25l.726-.4z" }),
    /* @__PURE__ */ m("path", { fillRule: "evenodd", d: "m24 2.144 1.732 1-1.58 2.736q.54.435 1.036.932A13.01 13.01 0 0 1 29 16a13 13 0 0 1-17.69 12.124l-1.578 2.732-1.732-1zm-.86 5.49-4.936 8.549 1.628.22c.277.037.543.132.78.278l5.588 3.436c.53-1.308.801-2.706.8-4.117a11.01 11.01 0 0 0-3.86-8.367M13.92 23.6l-1.593 2.76a11 11 0 0 0 3.43.631l.242-1.25z", clipRule: "evenodd" })
  ] });
};
O(J_);
const eL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M16 3a13 13 0 1 0 13 13A13.013 13.013 0 0 0 16 3m-4.5 9a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3m10.365 7.5C20.579 21.724 18.441 23 16 23s-4.579-1.275-5.865-3.5a1.001 1.001 0 0 1 1.477-1.31q.157.129.253.31C12.799 20.114 14.266 21 16 21s3.201-.887 4.135-2.5a1 1 0 1 1 1.73 1M20.5 15a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3" }) });
};
O(eL);
const tL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M16 3a13 13 0 1 0 13 13A13.013 13.013 0 0 0 16 3m-4.5 9a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3m10 10.865a1 1 0 0 1-1.365-.365C19.201 20.886 17.734 20 16 20s-3.201.887-4.135 2.5a1.001 1.001 0 1 1-1.73-1C11.421 19.276 13.559 18 16 18s4.579 1.275 5.865 3.5a1 1 0 0 1-.365 1.365M20.5 15a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3" }) });
};
O(tL);
const nL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M27.5 6v5a1.5 1.5 0 1 1-3 0V7.5H21a1.5 1.5 0 0 1 0-3h5A1.5 1.5 0 0 1 27.5 6M11 24.5H7.5V21a1.5 1.5 0 0 0-3 0v5A1.5 1.5 0 0 0 6 27.5h5a1.5 1.5 0 1 0 0-3m15-5a1.5 1.5 0 0 0-1.5 1.5v3.5H21a1.5 1.5 0 1 0 0 3h5a1.5 1.5 0 0 0 1.5-1.5v-5a1.5 1.5 0 0 0-1.5-1.5m-15-15H6A1.5 1.5 0 0 0 4.5 6v5a1.5 1.5 0 0 0 3 0V7.5H11a1.5 1.5 0 0 0 0-3" }) });
}, rL = O(nL), cte = rL, iL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M28.5 13a1.5 1.5 0 1 1-3 0V8.625l-7.439 7.439a1.503 1.503 0 1 1-2.125-2.125L23.375 6.5H19a1.5 1.5 0 0 1 0-3h8A1.5 1.5 0 0 1 28.5 5zM23 16a1.5 1.5 0 0 0-1.5 1.5v8h-15v-15h8a1.5 1.5 0 1 0 0-3H6A2.5 2.5 0 0 0 3.5 10v16A2.5 2.5 0 0 0 6 28.5h16a2.5 2.5 0 0 0 2.5-2.5v-8.5A1.5 1.5 0 0 0 23 16" }) });
}, oL = O(iL), sL = oL, aL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M30.914 15.595c-.044-.099-1.103-2.447-3.457-4.801C24.322 7.657 20.36 6 16 6S7.679 7.657 4.542 10.794C2.19 13.148 1.125 15.5 1.086 15.595a1 1 0 0 0 0 .812c.044.1 1.103 2.447 3.456 4.8C7.68 24.344 11.64 26 16 26s8.321-1.657 11.458-4.792c2.353-2.354 3.412-4.702 3.456-4.8a1 1 0 0 0 0-.813M16 21a5 5 0 1 1 0-10 5 5 0 0 1 0 10" }) });
}, lL = O(aL), ute = lL, cL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M6.74 4.328a1 1 0 1 0-1.48 1.345l2.405 2.646c-4.54 2.786-6.493 7.081-6.579 7.276a1 1 0 0 0 0 .813c.044.098 1.103 2.446 3.456 4.8C7.68 24.343 11.64 26 16 26c2.24.013 4.459-.448 6.509-1.354l2.75 3.027a1 1 0 1 0 1.48-1.345zm11.125 15.21a4 4 0 0 1-5.209-5.73zm13.049-3.13c-.053.117-1.319 2.92-4.17 5.475a1 1 0 0 1-1.408-.072L12.675 7.884a1 1 0 0 1 .575-1.66A17 17 0 0 1 16 6c4.36 0 8.321 1.658 11.458 4.794 2.353 2.354 3.412 4.702 3.456 4.801a1 1 0 0 1 0 .813" }) });
};
O(cL);
const uL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M17 15v12a1 1 0 0 1-2 0V15a1 1 0 0 1 2 0m8 9a1 1 0 0 0-1 1v2a1 1 0 0 0 2 0v-2a1 1 0 0 0-1-1m3-6h-2V5a1 1 0 0 0-2 0v13h-2a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1M7 20a1 1 0 0 0-1 1v6a1 1 0 1 0 2 0v-6a1 1 0 0 0-1-1m3-6H8V5a1 1 0 0 0-2 0v9H4a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1m9-6h-2V5a1 1 0 0 0-2 0v3h-2a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1" }) });
};
O(uL);
const hL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "m26.48 16.851-7.474 7.559a1.97 1.97 0 0 1-1.4.585H9.415l-3.707 3.712a1.001 1.001 0 0 1-1.415-1.415l2.823-2.822L15.588 16h10.537a.5.5 0 0 1 .355.851m.607-13.03a8 8 0 0 0-10.737.518l-1.2 1.185a.5.5 0 0 0-.15.351v7.875l6.875-6.875a1 1 0 0 1 1.414 1.414L17.589 14h11.047a.5.5 0 0 0 .445-.27 8.01 8.01 0 0 0-1.994-9.909M7.854 20.904 13 15.758V8.845a.5.5 0 0 0-.851-.355L7.586 13A1.99 1.99 0 0 0 7 14.414v6.136a.5.5 0 0 0 .854.354" }) });
};
O(hL);
const fL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "m26.708 10.293-7-7A1 1 0 0 0 19 3H7a2 2 0 0 0-2 2v22a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V11a1 1 0 0 0-.293-.707M19 11V5.5l5.5 5.5z" }) });
};
O(fL);
const dL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, viewBox: "0 0 256 256", fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "m213.66 82.34-56-56A8 8 0 0 0 152 24H56a16 16 0 0 0-16 16v76a4 4 0 0 0 4 4h168a4 4 0 0 0 4-4V88a8 8 0 0 0-2.34-5.66M152 88V44l44 44ZM48 180c0 11 7.18 20 16 20a14.18 14.18 0 0 0 10.06-4.5 8.21 8.21 0 0 1 10.9-.91 8 8 0 0 1 .82 11.81A30.06 30.06 0 0 1 64 216c-17.64 0-32-16.15-32-36s14.36-36 32-36a30 30 0 0 1 21.39 9.19 8.26 8.26 0 0 1 .73 11.09 8 8 0 0 1-11.9.38A14.17 14.17 0 0 0 64 160c-8.82 0-16 9-16 20m103.81 16.31a20.82 20.82 0 0 1-9.19 15.23C137.43 215 131 216 125.13 216a61.1 61.1 0 0 1-15.13-2 8 8 0 1 1 4.3-15.41c4.38 1.2 14.95 2.7 19.55-.36.88-.59 1.83-1.52 2.14-3.93.35-2.67-.71-4.1-12.78-7.59-9.35-2.7-25-7.23-23-23.11a20.56 20.56 0 0 1 9-14.95c11.84-8 30.71-3.31 32.83-2.76a8 8 0 0 1-4.07 15.48c-4.49-1.17-15.23-2.56-19.83.56a4.54 4.54 0 0 0-2 3.67c-.12.9-.14 1.09 1.11 1.9 2.31 1.49 6.45 2.68 10.45 3.84 9.79 2.83 26.35 7.66 24.11 24.97M215.42 155l-19.89 55.68a8 8 0 0 1-15.06 0L160.58 155a8.21 8.21 0 0 1 4.5-10.45 8 8 0 0 1 10.45 4.76l12.47 34.9 12.47-34.9a8 8 0 0 1 10.45-4.76 8.23 8.23 0 0 1 4.5 10.45" }) });
};
O(dL);
const gL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "m26.708 10.293-7-7A1 1 0 0 0 19 3H7a2 2 0 0 0-2 2v22a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V11a1 1 0 0 0-.293-.707m-7 11a1 1 0 0 1-1.415 1.415L16 20.414l-2.293 2.293a1 1 0 0 1-1.415-1.415L14.587 19l-2.293-2.293a1 1 0 1 1 1.415-1.415L16 17.587l2.293-2.293a1 1 0 0 1 1.415 1.415L17.414 19zM19 11V5.5l5.5 5.5z" }) });
};
O(gL);
const pL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M6 15h20a1 1 0 0 0 1-1v-3a1 1 0 0 0-.293-.707l-7-7A1 1 0 0 0 19 3H7a2 2 0 0 0-2 2v9a1 1 0 0 0 1 1m13-9.5 5.5 5.5H19zM28 19a1 1 0 0 1-1 1h-3v2h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 0v-7a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1M8 18H6a1 1 0 0 0-1 1v7a1 1 0 1 0 2 0v-1h1a3.5 3.5 0 1 0 0-7m0 5H7v-3h1a1.5 1.5 0 1 1 0 3m8-5h-2a1 1 0 0 0-1 1v7a1 1 0 0 0 1 1h2a4.5 4.5 0 1 0 0-9m0 7h-1v-5h1a2.5 2.5 0 0 1 0 5" }) });
};
O(pL);
const mL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, viewBox: "0 0 256 256", fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M44 120h168a4 4 0 0 0 4-4V88a8 8 0 0 0-2.34-5.66l-56-56A8 8 0 0 0 152 24H56a16 16 0 0 0-16 16v76a4 4 0 0 0 4 4m108-76 44 44h-44Zm4 164.53a8.18 8.18 0 0 1-8.25 7.47H120a8 8 0 0 1-8-8v-55.73a8.18 8.18 0 0 1 7.47-8.25 8 8 0 0 1 8.53 8v48h20a8 8 0 0 1 8 8.51m-61.49-51.88L77.83 180l16.68 23.35a8 8 0 0 1-13 9.3L68 193.76l-13.49 18.89a8 8 0 1 1-13-9.3L58.17 180l-16.68-23.35a8 8 0 0 1 2.3-11.46 8.19 8.19 0 0 1 10.88 2.38L68 166.24l13.49-18.89a8 8 0 0 1 13 9.3Zm121.28 39.66a20.81 20.81 0 0 1-9.18 15.23c-5.19 3.46-11.67 4.46-17.49 4.46a60.6 60.6 0 0 1-15.19-2 8 8 0 0 1 4.31-15.41c4.38 1.21 14.94 2.71 19.54-.35.89-.6 1.84-1.52 2.15-3.93.34-2.67-.72-4.1-12.78-7.59-9.35-2.7-25-7.23-23-23.12a20.58 20.58 0 0 1 8.95-14.94c11.84-8 30.72-3.31 32.83-2.76a8 8 0 0 1-4.07 15.48c-4.48-1.17-15.22-2.56-19.82.56a4.54 4.54 0 0 0-2 3.67c-.11.9-.13 1.08 1.12 1.9 2.31 1.49 6.45 2.68 10.45 3.84 9.87 2.82 26.39 7.65 24.18 24.96" }) });
};
O(mL);
const vL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, viewBox: "0 0 256 256", fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M184 144h-16a8 8 0 0 0-8 8v55.73a8.17 8.17 0 0 0 7.47 8.25 8 8 0 0 0 8.53-8v-8h7.4c15.24 0 28.14-11.92 28.59-27.15A28 28 0 0 0 184 144m-.35 40H176v-24h8a12 12 0 0 1 12 13.16A12.25 12.25 0 0 1 183.65 184M136 152v55.73a8.17 8.17 0 0 1-7.47 8.25 8 8 0 0 1-8.53-8v-55.71a8.17 8.17 0 0 1 7.47-8.25A8 8 0 0 1 136 152m-40 56.53a8.17 8.17 0 0 1-8.27 7.47h-31.5a8.27 8.27 0 0 1-6-2.5 8 8 0 0 1-1.18-9.5l25.16-44H56.27a8.17 8.17 0 0 1-8.27-7.47 8 8 0 0 1 8-8.53h31.77a8.27 8.27 0 0 1 6 2.5A8 8 0 0 1 95 156l-25.21 44H88a8 8 0 0 1 8 8.53M213.66 82.34l-56-56A8 8 0 0 0 152 24H56a16 16 0 0 0-16 16v76a4 4 0 0 0 4 4h168a4 4 0 0 0 4-4V88a8 8 0 0 0-2.34-5.66M152 88V44l44 44Z" }) });
};
O(vL);
const bL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M25.5 16a1.5 1.5 0 0 1-1.5 1.5H8a1.5 1.5 0 1 1 0-3h16a1.5 1.5 0 0 1 1.5 1.5M29 8.5H3a1.5 1.5 0 0 0 0 3h26a1.5 1.5 0 1 0 0-3m-10 12h-6a1.5 1.5 0 1 0 0 3h6a1.5 1.5 0 1 0 0-3" }) });
};
O(bL);
const wL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M27 9H16.414L13 5.586A1.98 1.98 0 0 0 11.586 5H5a2 2 0 0 0-2 2v18.078A1.926 1.926 0 0 0 4.924 27H27.11A1.89 1.89 0 0 0 29 25.111V11a2 2 0 0 0-2-2M5 7h6.586l2 2H5z" }) });
};
O(wL);
const xL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M27 9h-4.385q.075-.06.146-.125A3.7 3.7 0 0 0 24 6.196 4.08 4.08 0 0 0 19.805 2a3.7 3.7 0 0 0-2.68 1.239A6.9 6.9 0 0 0 16 5.049a6.9 6.9 0 0 0-1.125-1.81A3.7 3.7 0 0 0 12.195 2 4.08 4.08 0 0 0 8 6.196a3.7 3.7 0 0 0 1.239 2.679q.072.06.146.125H5a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2v8a2 2 0 0 0 2 2h7.5a.5.5 0 0 0 .5-.5V15H5v-4h10v4h2v-4h10v4H17v11.5a.5.5 0 0 0 .5.5H25a2 2 0 0 0 2-2v-8a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2M10.564 7.375A1.7 1.7 0 0 1 10 6.125 2.076 2.076 0 0 1 12.074 4h.061a1.71 1.71 0 0 1 1.25.563c1.049 1.185 1.419 3.15 1.549 4.365-1.22-.13-3.184-.5-4.37-1.553m10.875 0c-1.186 1.05-3.155 1.42-4.375 1.55.148-1.314.561-3.237 1.561-4.361A1.7 1.7 0 0 1 19.875 4h.061A2.077 2.077 0 0 1 22 6.135a1.7 1.7 0 0 1-.564 1.24z" }) });
};
O(xL);
const yL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M16 3a13 13 0 1 0 13 13A13.013 13.013 0 0 0 16 3m9.796 8h-4.428a17.8 17.8 0 0 0-2.533-5.625A11.05 11.05 0 0 1 25.796 11M16 5.014c1.5 1.625 2.625 3.693 3.296 5.986h-6.592C13.375 8.707 14.5 6.641 16 5.014M12 16c0-1.005.084-2.009.25-3h7.5a18.2 18.2 0 0 1 0 6h-7.5a18 18 0 0 1-.25-3m.704 5h6.592c-.671 2.293-1.796 4.359-3.296 5.986-1.5-1.627-2.625-3.693-3.296-5.986m6.131 5.625A17.8 17.8 0 0 0 21.367 21h4.43a11.05 11.05 0 0 1-6.962 5.625M21.776 19a20.2 20.2 0 0 0 0-6h4.808a11 11 0 0 1 0 6z" }) });
};
O(yL);
const CL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { fillRule: "evenodd", d: "M13.29 28.226 6.765 24.46a2.822 2.822 0 1 1-2.708-4.693v-7.532a2.824 2.824 0 1 1 2.708-4.693l6.525-3.767a2.824 2.824 0 1 1 5.42 0l6.524 3.766a2.822 2.822 0 1 1 2.71 4.693v7.533a2.824 2.824 0 1 1-2.71 4.694l-6.524 3.766A2.825 2.825 0 0 1 16 31.84a2.822 2.822 0 0 1-2.71-3.614M16 5.806q.413-.002.791-.113l8.531 14.776a2.8 2.8 0 0 0-.791 1.37H7.467a2.8 2.8 0 0 0-.79-1.369L15.21 5.693q.377.11.791.112M7.468 23.178l-.033.12 6.526 3.767A2.81 2.81 0 0 1 16 26.195c.802 0 1.526.334 2.04.871l6.523-3.766-.032-.121zM5.397 12.233a2.824 2.824 0 0 0 2.038-3.532l6.526-3.767q.043.045.088.088L5.517 19.8l-.12-.032zM26.482 19.8q.06-.018.121-.033v-7.532a2.824 2.824 0 0 1-2.04-3.534L18.04 4.934q-.045.045-.089.088z", clipRule: "evenodd" }) });
};
O(CL);
const $L = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M27 7v7.5a.5.5 0 0 1-.5.5H17V5.5a.5.5 0 0 1 .5-.5H25a2 2 0 0 1 2 2M14.5 5H7a2 2 0 0 0-2 2v7.5a.5.5 0 0 0 .5.5H15V5.5a.5.5 0 0 0-.5-.5m12 12H17v9.5a.5.5 0 0 0 .5.5H25a2 2 0 0 0 2-2v-7.5a.5.5 0 0 0-.5-.5M5 17.5V25a2 2 0 0 0 2 2h7.5a.5.5 0 0 0 .5-.5V17H5.5a.5.5 0 0 0-.5.5" }) });
};
O($L);
const SL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M10.5 6.5v5h-7A.5.5 0 0 1 3 11V8a2 2 0 0 1 2-2h5a.5.5 0 0 1 .5.5m2 19a.5.5 0 0 0 .5.5h6a.5.5 0 0 0 .5-.5v-5h-7zM3 21v3a2 2 0 0 0 2 2h5a.5.5 0 0 0 .5-.5v-5h-7a.5.5 0 0 0-.5.5m0-7v4a.5.5 0 0 0 .5.5h7v-5h-7a.5.5 0 0 0-.5.5m16-8h-6a.5.5 0 0 0-.5.5v5h7v-5A.5.5 0 0 0 19 6m9.5 7.5h-7v5h7a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 0-.5-.5m-16 5h7v-5h-7zM27 6h-5a.5.5 0 0 0-.5.5v5h7a.5.5 0 0 0 .5-.5V8a2 2 0 0 0-2-2m1.5 14.5h-7v5a.5.5 0 0 0 .5.5h5a2 2 0 0 0 2-2v-3a.5.5 0 0 0-.5-.5" }) });
};
O(SL);
const AL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M28.791 17.633a3.04 3.04 0 0 0-2.326-.597C28.813 14.666 30 12.31 30 10c0-3.309-2.661-6-5.933-6A5.95 5.95 0 0 0 19.5 6.094 5.95 5.95 0 0 0 14.932 4C11.663 4 9 6.691 9 10c0 1.375.405 2.711 1.258 4.125a4 4 0 0 0-1.844 1.05L5.586 18H2a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2h13q.123 0 .242-.03l8-2a1 1 0 0 0 .15-.05l4.858-2.067.055-.025a3.074 3.074 0 0 0 .491-5.195zm-1.362 3.393-4.75 2.023L14.875 25H7v-5.586l2.829-2.828A1.98 1.98 0 0 1 11.242 16H17.5a1.5 1.5 0 0 1 0 3H14a1 1 0 0 0 0 2h4q.113 0 .224-.025l8.375-1.926.038-.01a1.075 1.075 0 0 1 .788 1.987z" }) });
};
O(AL);
const kL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M28 10.5h-5.475l.951-5.231a1.5 1.5 0 1 0-2.952-.538L19.475 10.5h-4.95l.951-5.231a1.5 1.5 0 1 0-2.952-.538L11.475 10.5H6a1.5 1.5 0 0 0 0 3h4.93l-.909 5H4a1.5 1.5 0 0 0 0 3h5.475l-.951 5.231a1.5 1.5 0 0 0 1.207 1.75q.134.022.269.019a1.5 1.5 0 0 0 1.475-1.233l1.05-5.767h4.95l-.951 5.231a1.5 1.5 0 1 0 2.952.543l1.049-5.774H26a1.5 1.5 0 1 0 0-3h-4.93l.909-5H28a1.5 1.5 0 1 0 0-3m-9.979 8H13.07l.909-5h4.951z" }) });
};
O(kL);
const ML = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M31.5 22.5a5 5 0 0 1-5 5 4.94 4.94 0 0 1-3.571-1.45 1.5 1.5 0 0 1 2.142-2.1 1.94 1.94 0 0 0 1.429.55 2 2 0 0 0 0-4 1.94 1.94 0 0 0-1.429.55 1.5 1.5 0 0 1-2.551-1.3l1-6A1.5 1.5 0 0 1 25 12.5h5a1.5 1.5 0 1 1 0 3h-3.729l-.338 2.029q.283-.03.567-.029a5 5 0 0 1 5 5M18 5.5A1.5 1.5 0 0 0 16.5 7v6h-10V7a1.5 1.5 0 0 0-3 0v15a1.5 1.5 0 0 0 3 0v-6h10v6a1.5 1.5 0 1 0 3 0V7A1.5 1.5 0 0 0 18 5.5" }) });
};
O(ML);
const TL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M32 22a1.5 1.5 0 0 1-1.5 1.5V26a1.5 1.5 0 1 1-3 0v-2.5H23a1.5 1.5 0 0 1-1.422-1.974l3-9a1.5 1.5 0 0 1 2.845.948L25.08 20.5H27.5V18a1.5 1.5 0 1 1 3 0v2.5A1.5 1.5 0 0 1 32 22M18 5.5A1.5 1.5 0 0 0 16.5 7v6h-10V7a1.5 1.5 0 0 0-3 0v15a1.5 1.5 0 0 0 3 0v-6h10v6a1.5 1.5 0 1 0 3 0V7A1.5 1.5 0 0 0 18 5.5" }) });
};
O(TL);
const RL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M29.5 14v12a1.5 1.5 0 1 1-3 0v-9.198l-.668.448a1.503 1.503 0 0 1-1.665-2.5l3-2A1.5 1.5 0 0 1 29.5 14M18 5.5A1.5 1.5 0 0 0 16.5 7v6h-10V7a1.5 1.5 0 0 0-3 0v15a1.5 1.5 0 0 0 3 0v-6h10v6a1.5 1.5 0 1 0 3 0V7A1.5 1.5 0 0 0 18 5.5" }) });
};
O(RL);
const EL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "m27.133 17.541 1.655-2.772a1.5 1.5 0 1 0-2.576-1.538l-4.03 6.75q-.018.029-.032.059a5 5 0 1 0 4.983-2.5zM26.5 24.5a2 2 0 1 1 0-4 2 2 0 0 1 0 4M19.5 7v15a1.5 1.5 0 1 1-3 0v-6h-10v6a1.5 1.5 0 0 1-3 0V7a1.5 1.5 0 0 1 3 0v6h10V7a1.5 1.5 0 1 1 3 0" }) });
};
O(EL);
const OL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M31.5 22.5a5 5 0 0 1-8.571 3.5 1.5 1.5 0 1 1 2.142-2.099A2 2 0 1 0 26.5 20.5a1.5 1.5 0 0 1-1.229-2.36l1.854-2.64H24a1.5 1.5 0 1 1 0-3h6a1.5 1.5 0 0 1 1.229 2.36l-2.293 3.275A5 5 0 0 1 31.5 22.5M18 5.5A1.5 1.5 0 0 0 16.5 7v6h-10V7a1.5 1.5 0 0 0-3 0v15a1.5 1.5 0 0 0 3 0v-6h10v6a1.5 1.5 0 1 0 3 0V7A1.5 1.5 0 0 0 18 5.5" }) });
};
O(OL);
const DL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M19.5 7v15a1.5 1.5 0 1 1-3 0v-6h-10v6a1.5 1.5 0 0 1-3 0V7a1.5 1.5 0 0 1 3 0v6h10V7a1.5 1.5 0 1 1 3 0M30 24.5h-3l3.593-4.791a4.499 4.499 0 1 0-7.837-4.209 1.5 1.5 0 1 0 2.829 1q.076-.218.216-.402a1.5 1.5 0 1 1 2.394 1.807L22.8 25.1a1.5 1.5 0 0 0 1.2 2.4h6a1.5 1.5 0 1 0 0-3" }) });
};
O(DL);
const IL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M29 17v7a3 3 0 0 1-3 3h-2a3 3 0 0 1-3-3v-5a3 3 0 0 1 3-3h2.956A10.964 10.964 0 0 0 16.081 6H16A11 11 0 0 0 5.045 16H8a3 3 0 0 1 3 3v5a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3v-7a13.014 13.014 0 0 1 22.236-9.167A12.93 12.93 0 0 1 29 17" }) });
};
O(IL);
const _L = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M30 11.75c0 8.75-12.974 15.833-13.526 16.125a1 1 0 0 1-.948 0C14.974 27.582 2 20.5 2 11.75A7.76 7.76 0 0 1 9.75 4c2.581 0 4.841 1.11 6.25 2.986C17.409 5.11 19.669 4 22.25 4A7.76 7.76 0 0 1 30 11.75" }) });
};
O(_L);
const LL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M28 14.444V26a2 2 0 0 1-2 2h-5a2 2 0 0 1-2-2v-5a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v5a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V14.444a2 2 0 0 1 .646-1.473l10-9.435.014-.013a2 2 0 0 1 2.705.013l10 9.435A2 2 0 0 1 28 14.444" }) });
};
O(LL);
const BL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M27 5H5a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h22a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2m-7.5 6a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3M5 25v-3.5l6.5-6.5 10 10zm22 0h-2.671l-4.5-4.5 2.5-2.5L27 22.672z" }) });
};
O(BL);
const NL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M27 5H9a2 2 0 0 0-2 2v2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2v-2h2a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2m-5.5 4a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3M23 25H5V11h2v10a2 2 0 0 0 2 2h14zm4-4H9v-4.5l4.5-4.5 6.208 6.208a1 1 0 0 0 1.413 0L24.33 15 27 17.672z" }) });
};
O(NL);
const FL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M28.5 16a1.5 1.5 0 0 1-1.5 1.5H15a1.5 1.5 0 0 1 0-3h12a1.5 1.5 0 0 1 1.5 1.5M15 9.5h12a1.5 1.5 0 0 0 0-3H15a1.5 1.5 0 0 0 0 3m12 13H5a1.5 1.5 0 1 0 0 3h22a1.5 1.5 0 0 0 0-3m-18-4a1.5 1.5 0 0 0 1.061-2.561L6.125 12l3.936-3.94a1.503 1.503 0 1 0-2.125-2.125l-5 5a1.5 1.5 0 0 0 0 2.125l5 5A1.5 1.5 0 0 0 9 18.5" }) });
};
O(FL);
const VL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M28.5 16a1.5 1.5 0 0 1-1.5 1.5H15a1.5 1.5 0 0 1 0-3h12a1.5 1.5 0 0 1 1.5 1.5M15 9.5h12a1.5 1.5 0 0 0 0-3H15a1.5 1.5 0 0 0 0 3m12 13H5a1.5 1.5 0 0 0 0 3h22a1.5 1.5 0 1 0 0-3M3.939 18.06a1.5 1.5 0 0 0 2.125 0l5-5a1.5 1.5 0 0 0 0-2.125l-5-5a1.503 1.503 0 0 0-2.125 2.125L7.875 12l-3.936 3.939a1.5 1.5 0 0 0 0 2.122" }) });
};
O(VL);
const HL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M16 3a13 13 0 1 0 13 13A13.013 13.013 0 0 0 16 3m-.5 6a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3M17 23a2 2 0 0 1-2-2v-5a1 1 0 0 1 0-2 2 2 0 0 1 2 2v5a1 1 0 0 1 0 2" }) });
}, PL = O(HL), WL = PL, zL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M25.5 7A1.5 1.5 0 0 1 24 8.5h-3.919l-5 15H18a1.5 1.5 0 1 1 0 3H8a1.5 1.5 0 1 1 0-3h3.919l5-15H14a1.5 1.5 0 0 1 0-3h10A1.5 1.5 0 0 1 25.5 7" }) });
}, UL = O(zL), hte = UL, KL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M20 2a10.01 10.01 0 0 0-9.511 13.098l-7.196 7.195A1 1 0 0 0 3 23v5a1 1 0 0 0 1 1h5a1 1 0 0 0 1-1v-2h2a1 1 0 0 0 1-1v-2h2a1 1 0 0 0 .707-.293l1.195-1.196A10 10 0 1 0 20 2m2.5 9.5a2 2 0 1 1 0-4 2 2 0 0 1 0 4" }) });
};
O(KL);
const qL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M27 5H5a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h22a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2M5 7h22v5H5zm22 18H14V14h13z" }) });
};
O(qL);
const GL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M22 29a1 1 0 0 1-1 1H11a1 1 0 1 1 0-2h10a1 1 0 0 1 1 1m5-16a10.94 10.94 0 0 1-4.205 8.651A2.03 2.03 0 0 0 22 23.25V24a2 2 0 0 1-2 2h-8a2 2 0 0 1-2-2v-.75a2 2 0 0 0-.779-1.582A10.95 10.95 0 0 1 5 13.06C4.967 7.104 9.782 2.143 15.735 2A11 11 0 0 1 27 13m-4.014-1.168a7.2 7.2 0 0 0-5.82-5.818 1 1 0 1 0-.332 1.972c2.071.349 3.829 2.106 4.18 4.182a1 1 0 0 0 1.972-.335" }) });
};
O(GL);
const YL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "m21.731 14.683-14 15a1 1 0 0 1-1.711-.875l1.832-9.167L.65 16.936a1 1 0 0 1-.375-1.625l14-15a1 1 0 0 1 1.71.875l-1.837 9.177 7.204 2.7a1 1 0 0 1 .375 1.62z" }) });
};
O(YL);
const jL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M17.046 23.441a1.5 1.5 0 0 1 0 2.125l-.742.743a7.502 7.502 0 1 1-10.61-10.61l3.015-3.014A7.5 7.5 0 0 1 19 12.375a1.506 1.506 0 0 1-2 2.25 4.5 4.5 0 0 0-6.171.184l-3.013 3.01a4.5 4.5 0 0 0 6.365 6.365l.743-.743a1.5 1.5 0 0 1 2.122 0m9.26-17.75a7.51 7.51 0 0 0-10.61 0l-.742.743a1.503 1.503 0 1 0 2.125 2.125l.742-.743a4.5 4.5 0 0 1 6.365 6.365l-3.014 3.015a4.5 4.5 0 0 1-6.172.179 1.506 1.506 0 1 0-2 2.25 7.5 7.5 0 0 0 10.288-.304l3.014-3.014a7.51 7.51 0 0 0 .004-10.613z" }) });
}, XL = O(jL), fte = XL, ZL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M28.5 16a1.5 1.5 0 0 1-1.5 1.5H5a1.5 1.5 0 1 1 0-3h22a1.5 1.5 0 0 1 1.5 1.5M5 9.5h22a1.5 1.5 0 0 0 0-3H5a1.5 1.5 0 0 0 0 3m22 13H5a1.5 1.5 0 1 0 0 3h22a1.5 1.5 0 1 0 0-3" }) });
};
O(ZL);
const QL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M3.5 8A1.5 1.5 0 0 1 5 6.5h22a1.5 1.5 0 0 1 0 3H5A1.5 1.5 0 0 1 3.5 8M5 17.5h22a1.5 1.5 0 1 0 0-3H5a1.5 1.5 0 1 0 0 3m13 5H5a1.5 1.5 0 1 0 0 3h13a1.5 1.5 0 1 0 0-3m11 0h-1.5V21a1.5 1.5 0 1 0-3 0v1.5H23a1.5 1.5 0 1 0 0 3h1.5V27a1.5 1.5 0 1 0 3 0v-1.5H29a1.5 1.5 0 1 0 0-3" }) });
};
O(QL);
const JL = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, viewBox: "0 0 256 256", fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M28 64a12 12 0 0 1 12-12h176a12 12 0 0 1 0 24H40a12 12 0 0 1-12-12m12 76h64a12 12 0 0 0 0-24H40a12 12 0 0 0 0 24m80 40H40a12 12 0 0 0 0 24h80a12 12 0 0 0 0-24m120.49 20.49a12 12 0 0 1-17 0l-18.08-18.08a44 44 0 1 1 17-17l18.08 18.07a12 12 0 0 1 0 17.01M184 164a20 20 0 1 0-20-20 20 20 0 0 0 20 20" }) });
};
O(JL);
const eB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M17.5 4v4a1.5 1.5 0 1 1-3 0V4a1.5 1.5 0 1 1 3 0m4.156 7.844a1.5 1.5 0 0 0 1.062-.44l2.828-2.829a1.503 1.503 0 1 0-2.125-2.125l-2.825 2.833a1.5 1.5 0 0 0 1.06 2.56M28 14.5h-4a1.5 1.5 0 1 0 0 3h4a1.5 1.5 0 1 0 0-3m-5.282 6.096a1.501 1.501 0 0 0-2.451 1.638c.075.182.186.348.326.487l2.828 2.829a1.503 1.503 0 0 0 2.125-2.125zM16 22.5a1.5 1.5 0 0 0-1.5 1.5v4a1.5 1.5 0 1 0 3 0v-4a1.5 1.5 0 0 0-1.5-1.5m-6.717-1.904-2.83 2.829A1.503 1.503 0 0 0 8.58 25.55l2.829-2.829a1.503 1.503 0 0 0-2.125-2.125M9.5 16A1.5 1.5 0 0 0 8 14.5H4a1.5 1.5 0 1 0 0 3h4A1.5 1.5 0 0 0 9.5 16m-.925-9.546A1.503 1.503 0 0 0 6.45 8.579l2.833 2.825a1.503 1.503 0 0 0 2.125-2.125z" }) });
}, tB = O(eB), Hx = tB, nB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M26 10h-4V7a6 6 0 1 0-12 0v3H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h20a2 2 0 0 0 2-2V12a2 2 0 0 0-2-2M16 20.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3M20 10h-8V7a4 4 0 1 1 8 0z" }) });
};
O(nB);
const rB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M31 19a1 1 0 0 1-1 1h-2v2a1 1 0 0 1-2 0v-2h-2a1 1 0 0 1 0-2h2v-2a1 1 0 1 1 2 0v2h2a1 1 0 0 1 1 1M7 9h2v2a1 1 0 1 0 2 0V9h2a1 1 0 0 0 0-2h-2V5a1 1 0 0 0-2 0v2H7a1 1 0 0 0 0 2m16 15h-1v-1a1 1 0 0 0-2 0v1h-1a1 1 0 0 0 0 2h1v1a1 1 0 1 0 2 0v-1h1a1 1 0 0 0 0-2m4.414-14L10 27.414a2 2 0 0 1-2.828 0l-2.587-2.585a2 2 0 0 1 0-2.829L22 4.586a2 2 0 0 1 2.829 0l2.585 2.585a2 2 0 0 1 0 2.829M26 8.586 23.414 6l-4 4L22 12.586z" }) });
};
O(rB);
const iB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M28 6H4a1 1 0 0 0-1 1v17a2 2 0 0 0 2 2h22a2 2 0 0 0 2-2V7a1 1 0 0 0-1-1M12.339 16 5 22.726V9.274zm1.48 1.356 1.5 1.381a1 1 0 0 0 1.352 0l1.5-1.38L25.421 24H6.571zM19.66 16 27 9.273v13.455z" }) });
};
O(iB);
const oB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { fillRule: "evenodd", d: "M11 7q0 .432-.088.838L16 10.382l5.088-2.544a4 4 0 1 1 .895 1.789L18.236 11.5l3.747 1.873a4 4 0 1 1 0 5.253L18.236 20.5l3.747 1.874a4 4 0 1 1-.895 1.788L16 21.618l-5.088 2.544Q11 24.567 11 25a4 4 0 1 1-.983-2.626l3.747-1.874-3.747-1.873a4 4 0 1 1 0-5.253l3.747-1.874-3.747-1.874A4 4 0 1 1 11 7M9 7a2 2 0 1 1-4 0 2 2 0 0 1 4 0m2.236 8h9.528L16 12.618zM9 25a2 2 0 1 1-4 0 2 2 0 0 1 4 0m-2-7a2 2 0 1 0 0-4 2 2 0 0 0 0 4M27 7a2 2 0 1 1-4 0 2 2 0 0 1 4 0m-2 20a2 2 0 1 0 0-4 2 2 0 0 0 0 4m2-11a2 2 0 1 1-4 0 2 2 0 0 1 4 0m-11 3.382L20.764 17h-9.528z", clipRule: "evenodd" }) });
};
O(oB);
const sB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { fillRule: "evenodd", d: "M14.8 8.254a4 4 0 1 0-1.082 1.682l7.483 4.81a4 4 0 0 0-.075.254H10.874A4.002 4.002 0 0 0 3 16a4 4 0 0 0 7.874 1h10.252q.033.128.075.254l-7.484 4.81a4 4 0 1 0 1.082 1.682l7.484-4.81a4 4 0 1 0 0-5.871zM11 9a2 2 0 1 0 0-4 2 2 0 0 0 0 4m0 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4M9 16a2 2 0 1 1-4 0 2 2 0 0 1 4 0m16 2a2 2 0 1 0 0-4 2 2 0 0 0 0 4", clipRule: "evenodd" }) });
};
O(sB);
const aB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { fillRule: "evenodd", d: "M18.842 3.227a1 1 0 1 0-.445 1.95l1.747.399L9.6 12.959a4 4 0 1 0 0 6.081l10.546 7.385-1.748.399a1 1 0 1 0 .445 1.95l3.945-.9a1 1 0 0 0 .77-1.1l-.503-4.014a1 1 0 0 0-1.985.248l.223 1.779-10.545-7.384a4 4 0 0 0 .127-.403h14.712l-1.293 1.293a1 1 0 1 0 1.414 1.414l3-3a1 1 0 0 0 0-1.414l-3-3a1 1 0 0 0-1.414 1.414L25.586 15H10.874a4 4 0 0 0-.127-.403l10.544-7.383-.222 1.778a1 1 0 0 0 1.984.249l.503-4.015a1 1 0 0 0-.77-1.099zM9 16a2 2 0 1 1-4 0 2 2 0 0 1 4 0", clipRule: "evenodd" }) });
};
O(aB);
const lB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M27 6H5a2 2 0 0 0-2 2v20a1.98 1.98 0 0 0 1.156 1.813 1.986 1.986 0 0 0 2.141-.299L10.312 26H27a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2M10.5 17.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3m5.5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3m5.5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3" }) });
};
O(lB);
const cB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M10 16V8a6 6 0 1 1 12 0v8a6 6 0 1 1-12 0m16 0a1 1 0 0 0-2 0 8 8 0 0 1-16 0 1 1 0 1 0-2 0 10.014 10.014 0 0 0 9 9.95V29a1 1 0 0 0 2 0v-3.05A10.014 10.014 0 0 0 26 16" }) });
};
O(cB);
const uB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M28.5 16a1.5 1.5 0 0 1-1.5 1.5H5a1.5 1.5 0 1 1 0-3h22a1.5 1.5 0 0 1 1.5 1.5" }) });
}, hB = O(uB), fB = hB, dB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M16 3a13 13 0 1 0 13 13A13.013 13.013 0 0 0 16 3m5 14H11a1 1 0 0 1 0-2h10a1 1 0 0 1 0 2" }) });
};
O(dB);
const gB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M26 5H6a3 3 0 0 0-3 3v14a3 3 0 0 0 3 3h20a3 3 0 0 0 3-3V8a3 3 0 0 0-3-3M20 27h-8a1 1 0 0 0 0 2h8a1 1 0 0 0 0-2" }) });
};
O(gB);
const pB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M29.443 18.776a13.1 13.1 0 0 1-4.626 6.614A13 13 0 0 1 4 15a12.9 12.9 0 0 1 2.61-7.815 13.1 13.1 0 0 1 6.614-4.625 1 1 0 0 1 1.25 1.25 11.01 11.01 0 0 0 13.725 13.725 1 1 0 0 1 1.25 1.25z" }) });
};
O(pB);
const mB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M18 16a2 2 0 1 1-4 0 2 2 0 0 1 4 0M7.5 14a2 2 0 1 0 0 4 2 2 0 0 0 0-4m17 0a2 2 0 1 0 0 4 2 2 0 0 0 0-4" }) });
}, vB = O(mB), dte = vB, bB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M10.939 8.061a1.5 1.5 0 0 1 0-2.125l4-4a1.5 1.5 0 0 1 2.125 0l4 4a1.503 1.503 0 1 1-2.125 2.125L17.5 6.625V12a1.5 1.5 0 1 1-3 0V6.625l-1.439 1.436a1.5 1.5 0 0 1-2.122 0m8 15.875L17.5 25.375V20a1.5 1.5 0 1 0-3 0v5.375l-1.439-1.44a1.504 1.504 0 0 0-2.125 2.125l4 4a1.5 1.5 0 0 0 2.125 0l4-4a1.502 1.502 0 1 0-2.125-2.125zm11.125-9-4-4a1.503 1.503 0 0 0-2.125 2.125l1.436 1.439H20a1.5 1.5 0 0 0 0 3h5.375l-1.44 1.439a1.503 1.503 0 0 0 2.125 2.125l4-4a1.5 1.5 0 0 0 .001-2.125zM6.625 17.5H12a1.5 1.5 0 1 0 0-3H6.625l1.44-1.439a1.503 1.503 0 1 0-2.125-2.125l-4 4a1.5 1.5 0 0 0 0 2.125l4 4a1.503 1.503 0 0 0 2.125-2.125z" }) });
};
O(bB);
const wB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M26.615 3.214a.99.99 0 0 0-.857-.183l-16 4a1 1 0 0 0-.758.97v13.762a4.5 4.5 0 1 0 2 3.737V13.781l14-3.5v7.482a4.5 4.5 0 1 0 2 3.737V4a1 1 0 0 0-.385-.786" }) });
};
O(wB);
const xB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M28.5 16a1.5 1.5 0 0 1-1.5 1.5H14.5a1.5 1.5 0 1 1 0-3H27a1.5 1.5 0 0 1 1.5 1.5m-14-6.5H27a1.5 1.5 0 0 0 0-3H14.5a1.5 1.5 0 0 0 0 3m12.5 13H14.5a1.5 1.5 0 1 0 0 3H27a1.5 1.5 0 1 0 0-3M5.5 7.414V13a1.5 1.5 0 0 0 3 0V5a1.5 1.5 0 0 0-2.17-1.341l-2 1a1.5 1.5 0 0 0 1.17 2.75zm4.966 12.107a3.46 3.46 0 0 0-1.4-2.329 3.61 3.61 0 0 0-4.954.683 3.5 3.5 0 0 0-.52.942 1.5 1.5 0 0 0 2.818 1.027.5.5 0 0 1 .072-.125.6.6 0 0 1 .813-.103.48.48 0 0 1 .201.325.45.45 0 0 1-.096.347l-.016.02-3.585 4.794A1.5 1.5 0 0 0 5 27.5h4a1.5 1.5 0 1 0 0-3H8l1.785-2.389a3.43 3.43 0 0 0 .681-2.59" }) });
}, yB = O(xB), gte = yB, CB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { fillRule: "evenodd", d: "M17.2 8.254a4 4 0 1 1 1.082 1.682l-7.482 4.81q.04.125.074.254h10.252A4.002 4.002 0 0 1 29 16a4 4 0 0 1-7.874 1H10.874q-.033.128-.075.254l7.484 4.81a4 4 0 1 1-1.082 1.682l-7.484-4.81a4 4 0 1 1 0-5.871zM21 9a2 2 0 1 1 0-4 2 2 0 0 1 0 4m0 18a2 2 0 1 1 0-4 2 2 0 0 1 0 4m2-11a2 2 0 1 0 4 0 2 2 0 0 0-4 0M7 18a2 2 0 1 1 0-4 2 2 0 0 1 0 4", clipRule: "evenodd" }) });
};
O(CB);
const $B = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { fillRule: "evenodd", d: "M10.874 17A4.002 4.002 0 0 1 3 16a4 4 0 0 1 7.874-1h10.252A4.002 4.002 0 0 1 29 16a4 4 0 0 1-7.874 1zM7 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4m18 0a2 2 0 1 0 0-4 2 2 0 0 0 0 4", clipRule: "evenodd" }) });
};
O($B);
const SB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { fillRule: "evenodd", d: "M28.924 16.384c-.05.12-.124.231-.217.324l-4 4a1 1 0 0 1-1.632-.324 1 1 0 0 1 .217-1.09L25.585 17H10.875A4.002 4.002 0 0 1 3 16a4 4 0 0 1 7.874-1h14.712l-2.294-2.293a1 1 0 0 1 1.415-1.415l4 4a1 1 0 0 1 .217 1.09M7 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4", clipRule: "evenodd" }) });
};
O(SB);
const AB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M29 4a1 1 0 0 0-1-1c-5.51 0-11.164 6.214-14.304 10.329A7.5 7.5 0 0 0 4 20.5c0 3.86-2.443 5.591-2.559 5.671A1 1 0 0 0 2 28h9.5a7.5 7.5 0 0 0 7.171-9.696C22.788 15.164 29 9.51 29 4M15.553 14.194a48 48 0 0 1 1.26-1.569 9.5 9.5 0 0 1 2.562 2.561q-.738.618-1.569 1.262a7.6 7.6 0 0 0-2.254-2.254m5.337-.335a11.6 11.6 0 0 0-2.75-2.75c3.973-4.316 6.969-5.625 8.738-5.989-.357 1.77-1.672 4.766-5.988 8.739" }) });
};
O(AB);
const kB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M31 13v6.25a2.01 2.01 0 0 1-1.45 1.922L17 24.75V29a1 1 0 0 1-2 0v-4.25a2.01 2.01 0 0 1 1.45-1.922L29 19.25V13h-2v3a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2v-3H2a1 1 0 0 1 0-2h2V8a2 2 0 0 1 2-2h19a2 2 0 0 1 2 2v3h2a2 2 0 0 1 2 2" }) });
};
O(kB);
const MB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M25.096 6.736A12.9 12.9 0 0 0 16 3h-.134A13 13 0 0 0 3 16c0 5.375 3.323 9.883 8.67 11.771A4 4 0 0 0 17 24a2 2 0 0 1 2-2h5.776a3.976 3.976 0 0 0 3.9-3.11c.224-.984.332-1.99.324-3a12.9 12.9 0 0 0-3.904-9.154M10.5 21a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3m0-7a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3m5.5-3a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3m5.5 3a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3" }) });
};
O(MB);
const TB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M28.925 5.543v.018L21.65 29.554A1.985 1.985 0 0 1 19.728 31a1.98 1.98 0 0 1-1.803-1.144l-4.464-9.423a.5.5 0 0 1 .099-.568l7.158-7.159a1 1 0 0 0-1.414-1.413l-7.169 7.157a.5.5 0 0 1-.567.099l-9.376-4.441A2.05 2.05 0 0 1 1 12.17a1.99 1.99 0 0 1 1.446-1.815L26.44 3.08h.018a2 2 0 0 1 2.468 2.463" }) });
};
O(TB);
const RB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "m26.56 17.061-10.257 10.25a7.501 7.501 0 0 1-10.607-10.61l12.27-12.236a5 5 0 0 1 7.07 7.074l-.021.02L13.04 23.086a1.503 1.503 0 0 1-2.121-.041 1.5 1.5 0 0 1 .041-2.121L22.924 9.409a2 2 0 1 0-2.838-2.82L7.816 18.82a4.5 4.5 0 1 0 6.366 6.364l10.258-10.25a1.503 1.503 0 0 1 2.125 2.125z" }) });
};
O(RB);
const EB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M3.5 8A1.5 1.5 0 0 1 5 6.5h22a1.5 1.5 0 0 1 0 3H5A1.5 1.5 0 0 1 3.5 8M5 14.5h16a1.5 1.5 0 1 0 0-3H5a1.5 1.5 0 1 0 0 3m22 2H5a1.5 1.5 0 1 0 0 3h22a1.5 1.5 0 1 0 0-3m-6 5H5a1.5 1.5 0 1 0 0 3h16a1.5 1.5 0 1 0 0-3" }) });
};
O(EB);
const OB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "m28.414 9.171-5.585-5.586a2 2 0 0 0-2.829 0L4.586 19A1.98 1.98 0 0 0 4 20.414V26a2 2 0 0 0 2 2h5.586A1.98 1.98 0 0 0 13 27.414L28.414 12a2 2 0 0 0 0-2.829M24 13.585 18.414 8l3-3L27 10.585z" }) });
}, DB = O(OB), pte = DB, IB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M28.985 21.885A7.03 7.03 0 0 1 22 28c-9.925 0-18-8.075-18-18a7.03 7.03 0 0 1 6.115-6.985 2 2 0 0 1 2.078 1.19l2.64 5.894v.015a2 2 0 0 1-.16 1.886 1 1 0 0 1-.07.096L12 15.181c.936 1.903 2.926 3.875 4.854 4.814l3.042-2.589q.045-.037.094-.07a2 2 0 0 1 1.896-.175l.017.008 5.888 2.639a2 2 0 0 1 1.194 2.077" }) });
};
O(IB);
const _B = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "m29.416 13-6.683 6.706c.57 1.584.806 4.236-1.65 7.5a2 2 0 0 1-1.458.794h-.141a2 2 0 0 1-1.415-.586l-6.033-6.04-5.328 5.333a1 1 0 1 1-1.415-1.415l5.332-5.328-6.037-6.038a2 2 0 0 1 .162-2.972c3.178-2.564 6.219-2.06 7.55-1.643L19 2.587a2 2 0 0 1 2.829 0l7.586 7.585A2 2 0 0 1 29.416 13" }) });
};
O(_B);
const LB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M16 2A11.013 11.013 0 0 0 5 13c0 9.413 10 16.521 10.426 16.819a1 1 0 0 0 1.148 0C17 29.52 27 22.413 27 13A11.01 11.01 0 0 0 16 2m0 7a4 4 0 1 1 0 8 4 4 0 0 1 0-8" }) });
};
O(LB);
const BB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M30 17v4a1 1 0 0 1-1.196.98L19.5 20.125v2.966l2.207 2.206A1 1 0 0 1 22 26v3a1 1 0 0 1-1.375.929L16 28.078l-4.625 1.85A1 1 0 0 1 10 29v-3a1 1 0 0 1 .293-.707l2.207-2.207v-2.961L3.196 21.98A1 1 0 0 1 2 21v-4a1 1 0 0 1 .553-.895l9.947-4.972V5.5a3.5 3.5 0 1 1 7 0v5.633l9.948 4.972A1 1 0 0 1 30 17" }) });
};
O(BB);
const NB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M25.676 18.884a7.6 7.6 0 0 1-3.978 1.107 9 9 0 0 1-3.42-.707A6.94 6.94 0 0 0 17 23.314V27a1 1 0 0 1-1.066 1A1.023 1.023 0 0 1 15 26.969v-1.555l-4.828-4.828A6.6 6.6 0 0 1 7.93 21a5.73 5.73 0 0 1-2.99-.834C2.216 18.511.75 14.702 1.034 9.974a1 1 0 0 1 .94-.94c4.728-.28 8.537 1.182 10.187 3.906a5.75 5.75 0 0 1 .806 3.56.5.5 0 0 1-.86.304l-2.4-2.513a1 1 0 0 0-1.415 1.414l6.736 6.906q.01-.146.026-.291a8.57 8.57 0 0 1 2.33-4.933l6.323-6.682a1 1 0 0 0-1.413-1.415l-6.125 6.477a.5.5 0 0 1-.848-.217c-.592-2.185-.331-4.36.8-6.228 2.233-3.685 7.428-5.657 13.898-5.277a1 1 0 0 1 .94.94c.375 6.471-1.598 11.666-5.283 13.899" }) });
};
O(NB);
const FB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M30 16a1.97 1.97 0 0 1-.95 1.689L11.04 28.706a2 2 0 0 1-2.767-.688A2 2 0 0 1 8 27.016V4.984a1.98 1.98 0 0 1 1.015-1.728 2 2 0 0 1 2.025.038L29.05 14.31A1.97 1.97 0 0 1 30 16" }) });
}, VB = O(FB), mte = VB, HB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M28.5 16a1.5 1.5 0 0 1-1.5 1.5h-9.5V27a1.5 1.5 0 1 1-3 0v-9.5H5a1.5 1.5 0 1 1 0-3h9.5V5a1.5 1.5 0 1 1 3 0v9.5H27a1.5 1.5 0 0 1 1.5 1.5" }) });
}, PB = O(HB), vte = PB, WB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M16 3a13 13 0 1 0 13 13A13.016 13.016 0 0 0 16 3m5 14h-4v4a1 1 0 0 1-2 0v-4h-4a1 1 0 0 1 0-2h4v-4a1 1 0 0 1 2 0v4h4a1 1 0 0 1 0 2" }) });
};
O(WB);
const zB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M27 5H17V3a1 1 0 0 0-2 0v2H5a2 2 0 0 0-2 2v15a2 2 0 0 0 2 2h4.92l-2.701 3.375a1 1 0 0 0 1.562 1.25L12.48 24h7.04l3.699 4.625a1 1 0 1 0 1.562-1.25L22.08 24H27a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2M13 18a1 1 0 0 1-2 0v-3a1 1 0 0 1 2 0zm4 0a1 1 0 0 1-2 0v-5a1 1 0 0 1 2 0zm4 0a1 1 0 0 1-2 0v-7a1 1 0 0 1 2 0z" }) });
};
O(zB);
const UB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M30.414 17 18 4.586A1.98 1.98 0 0 0 16.586 4H5a1 1 0 0 0-1 1v11.586A1.98 1.98 0 0 0 4.586 18L17 30.414a2 2 0 0 0 2.829 0l10.585-10.585a2 2 0 0 0 0-2.829M10.5 12a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3" }) });
};
O(UB);
const KB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M20.723 28H26a2 2 0 0 0 2-2v-4.706a1 1 0 0 0-1.383-.919 2.9 2.9 0 0 1-1.117.221c-1.654 0-3-1.387-3-3.091s1.346-3.091 3-3.091c.383 0 .763.075 1.117.221A1 1 0 0 0 28 13.706V9a2 2 0 0 0-2-2h-4.527a4.5 4.5 0 1 0-8.945 0H8a2 2 0 0 0-2 2v4.028a4.5 4.5 0 1 0 0 8.945V26a2 2 0 0 0 2 2h5.278" }) });
};
O(KB);
const qB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M18 22.5a2 2 0 1 1-4 0 2 2 0 0 1 4 0M29.5 16A13.5 13.5 0 1 1 16 2.5 13.515 13.515 0 0 1 29.5 16m-3 0A10.5 10.5 0 1 0 16 26.5 10.51 10.51 0 0 0 26.5 16M16 8c-3.033 0-5.5 2.242-5.5 5v.5a1.5 1.5 0 1 0 3 0V13c0-1.102 1.125-2 2.5-2s2.5.898 2.5 2-1.125 2-2.5 2a1.5 1.5 0 0 0-1.5 1.5v1a1.5 1.5 0 0 0 2.966.32C19.79 17.235 21.5 15.296 21.5 13c0-2.758-2.468-5-5.5-5" }) });
};
O(qB);
const GB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M14.5 9v11a6.006 6.006 0 0 1-6 6 1 1 0 0 1 0-2 4 4 0 0 0 4-4v-1H5a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h7.5a2 2 0 0 1 2 2M27 7h-7.5a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2H27v1a4 4 0 0 1-4 4 1 1 0 0 0 0 2 6.006 6.006 0 0 0 6-6V9a2 2 0 0 0-2-2" }) });
}, YB = O(GB), bte = YB, jB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M27 5v23a1 1 0 0 1-2 0v-6h-6a1 1 0 0 1-1-1c.046-2.395.349-4.779.902-7.11 1.223-5.061 3.54-8.454 6.704-9.809a1 1 0 0 1 1.394.92m-12.014-.164a.999.999 0 1 0-1.972.33L13.986 11H11V5a1 1 0 0 0-2 0v6H6.014l.972-5.835a1 1 0 1 0-1.972-.329l-1 6A1 1 0 0 0 4 11a6.01 6.01 0 0 0 5 5.915V28a1 1 0 1 0 2 0V16.915A6.01 6.01 0 0 0 16 11q0-.083-.014-.164z" }) });
};
O(jB);
const XB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M19 28a1 1 0 0 1-1 1h-4a1 1 0 0 1 0-2h4a1 1 0 0 1 1 1m8.953-8.521-1.546 6.954a2 2 0 0 1-3.188 1.138l-3.405-2.57h-7.625L8.78 27.57a2 2 0 0 1-3.189-1.138l-1.545-6.954a2.01 2.01 0 0 1 .415-1.714l3.57-4.282c.12-1.574.482-3.12 1.072-4.584 1.612-4.043 4.5-6.579 5.671-7.481a2 2 0 0 1 2.45 0c1.167.902 4.059 3.438 5.671 7.48.59 1.465.952 3.01 1.072 4.585l3.57 4.282a2.01 2.01 0 0 1 .415 1.714m-17.404 4.25q-2.014-3.666-2.445-7.209L6 19.045 7.545 26l.022-.016zM17.5 12.5a1.5 1.5 0 1 0-3 0 1.5 1.5 0 0 0 3 0m8.5 6.545-2.104-2.525q-.428 3.535-2.445 7.211l2.982 2.25.022.017z" }) });
};
O(XB);
const ZB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M19.716 14.141a1 1 0 0 1 .261-1.391l8.458-5.788a1 1 0 0 1 1.125 1.652L21.101 14.4a1 1 0 0 1-1.39-.261zm10.109 10.634a1 1 0 0 1-1.39.261L17 17.211l-5.315 3.636a4.5 4.5 0 1 1-1.125-1.65L15.229 16l-4.673-3.198a4.5 4.5 0 1 1 1.125-1.65l17.875 12.233a1 1 0 0 1 .269 1.39M9 22.5a1.5 1.5 0 1 0-3 0 1.5 1.5 0 0 0 3 0m0-13a1.5 1.5 0 1 0-3 0 1.5 1.5 0 0 0 3 0" }) });
};
O(ZB);
const QB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, viewBox: "0 0 256 256", fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M225.86 102.82c-3.77-3.94-7.67-8-9.14-11.57-1.36-3.27-1.44-8.69-1.52-13.94-.15-9.76-.31-20.82-8-28.51s-18.75-7.85-28.51-8c-5.25-.08-10.67-.16-13.94-1.52-3.56-1.47-7.63-5.37-11.57-9.14C146.28 23.51 138.44 16 128 16s-18.27 7.51-25.18 14.14c-3.94 3.77-8 7.67-11.57 9.14-3.25 1.36-8.69 1.44-13.94 1.52-9.76.15-20.82.31-28.51 8s-7.8 18.75-8 28.51c-.08 5.25-.16 10.67-1.52 13.94-1.47 3.56-5.37 7.63-9.14 11.57C23.51 109.72 16 117.56 16 128s7.51 18.27 14.14 25.18c3.77 3.94 7.67 8 9.14 11.57 1.36 3.27 1.44 8.69 1.52 13.94.15 9.76.31 20.82 8 28.51s18.75 7.85 28.51 8c5.25.08 10.67.16 13.94 1.52 3.56 1.47 7.63 5.37 11.57 9.14 6.9 6.63 14.74 14.14 25.18 14.14s18.27-7.51 25.18-14.14c3.94-3.77 8-7.67 11.57-9.14 3.27-1.36 8.69-1.44 13.94-1.52 9.76-.15 20.82-.31 28.51-8s7.85-18.75 8-28.51c.08-5.25.16-10.67 1.52-13.94 1.47-3.56 5.37-7.63 9.14-11.57 6.63-6.9 14.14-14.74 14.14-25.18s-7.51-18.27-14.14-25.18m-52.2 6.84-56 56a8 8 0 0 1-11.32 0l-24-24a8 8 0 0 1 11.32-11.32L112 148.69l50.34-50.35a8 8 0 0 1 11.32 11.32" }) });
};
O(QB);
const JB = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M29.061 26.939 23.125 21A11.515 11.515 0 1 0 21 23.125l5.941 5.942a1.503 1.503 0 0 0 2.125-2.125zM5.5 14a8.5 8.5 0 1 1 8.5 8.5A8.51 8.51 0 0 1 5.5 14" }) });
}, eN = O(JB), Px = eN, tN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M26 5H6a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h20a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2m-3.5 6.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3M26 17H6a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h20a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2m-3.5 6.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3" }) });
};
O(tN);
const nN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M28 7v7.346c0 11.202-9.477 14.918-11.375 15.549a1.94 1.94 0 0 1-1.25 0C13.475 29.264 4 25.548 4 14.346V7a2 2 0 0 1 2-2h20a2 2 0 0 1 2 2" }) });
}, rN = O(nN), wte = rN, iN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "m30.949 7.653-6.47-3.528A1 1 0 0 0 24 4h-4a1 1 0 0 0-1 1 3 3 0 0 1-6 0 1 1 0 0 0-1-1H8a1 1 0 0 0-.48.125L1.051 7.653a1.97 1.97 0 0 0-.824 2.657l2.41 4.601A2.05 2.05 0 0 0 4.458 16H7v10a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V16h2.543a2.05 2.05 0 0 0 1.822-1.089l2.409-4.601a1.97 1.97 0 0 0-.825-2.658M4.459 14a.08.08 0 0 1-.051-.016L2.01 9.408 7 6.685V14zm23.134-.018a.07.07 0 0 1-.052.018H25V6.685l4.99 2.723z" }) });
};
O(iN);
const oN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M12 27a2 2 0 1 1-4 0 2 2 0 0 1 4 0m11-2a2 2 0 1 0 0 4 2 2 0 0 0 0-4m5.805-16.594A1 1 0 0 0 28 8H6.04L5.026 4.45A2.01 2.01 0 0 0 3.103 3H1a1 1 0 0 0 0 2h2.103l4.522 15.824A3.01 3.01 0 0 0 10.509 23h12.014a2.99 2.99 0 0 0 2.867-2.117l3.566-11.59a1 1 0 0 0-.151-.887" }) });
};
O(oN);
const sN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M14.5 27a1.5 1.5 0 0 1-1.5 1.5H6A2.5 2.5 0 0 1 3.5 26V6A2.5 2.5 0 0 1 6 3.5h7a1.5 1.5 0 0 1 0 3H6.5v19H13a1.5 1.5 0 0 1 1.5 1.5m13.561-12.061-5-5a1.503 1.503 0 0 0-2.125 2.125l2.439 2.436H13a1.5 1.5 0 1 0 0 3h10.375l-2.44 2.439a1.503 1.503 0 0 0 2.125 2.125l5-5a1.5 1.5 0 0 0 .001-2.125" }) });
};
O(sN);
const aN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M4 10a1 1 0 0 1 1-1h4.646a3.5 3.5 0 0 1 6.708 0H27a1 1 0 1 1 0 2H16.354a3.5 3.5 0 0 1-6.708 0H5a1 1 0 0 1-1-1m23 11h-2.646a3.5 3.5 0 0 0-6.708 0H5a1 1 0 0 0 0 2h12.646a3.5 3.5 0 0 0 6.708 0H27a1 1 0 1 0 0-2" }) });
};
O(aN);
const lN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M26 18a1.97 1.97 0 0 1-1.302 1.867l-6.457 2.375-2.375 6.452a1.99 1.99 0 0 1-3.735 0L9.75 22.25l-6.452-2.375a1.99 1.99 0 0 1 0-3.735l6.456-2.375 2.375-6.451a1.99 1.99 0 0 1 3.735 0l2.375 6.456 6.451 2.375A1.97 1.97 0 0 1 26 18M19 6h2v2a1 1 0 0 0 2 0V6h2a1 1 0 1 0 0-2h-2V2a1 1 0 1 0-2 0v2h-2a1 1 0 1 0 0 2m11 4h-1V9a1 1 0 1 0-2 0v1h-1a1 1 0 0 0 0 2h1v1a1 1 0 0 0 2 0v-1h1a1 1 0 0 0 0-2" }) });
};
O(lN);
const cN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M15 7v6a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2m10-2h-6a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2M13 17H7a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2m12 0h-6a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2" }) });
};
O(cN);
const uN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ ae("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: [
    /* @__PURE__ */ m("path", { d: "M27.5 21.136 16 27.843 4.5 21.136a1 1 0 0 0-1 1.728l12 7a1 1 0 0 0 1.008 0l12-7a1 1 0 1 0-1.008-1.728" }),
    /* @__PURE__ */ m("path", { d: "M27.5 15.136 16 21.843 4.5 15.136a1 1 0 0 0-1 1.728l12 7a1 1 0 0 0 1.008 0l12-7a1 1 0 1 0-1.008-1.728" }),
    /* @__PURE__ */ m("path", { d: "m3.5 10.864 12 7a1 1 0 0 0 1.008 0l12-7a1 1 0 0 0 0-1.728l-12-7a1 1 0 0 0-1.008 0l-12 7a1 1 0 0 0 0 1.728" })
  ] });
};
O(uN);
const hN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "m29.313 14.298-5.638 4.92 1.689 7.325a2 2 0 0 1-2.98 2.167l-6.389-3.875L9.62 28.71a2 2 0 0 1-2.98-2.168l1.686-7.317-5.638-4.928a2 2 0 0 1 1.138-3.507l7.433-.644 2.901-6.92a1.994 1.994 0 0 1 3.68 0l2.91 6.92 7.43.644a2 2 0 0 1 1.139 3.508z" }) });
};
O(hN);
const fN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M29 19a4 4 0 1 0-4.991 3.875A1 1 0 0 0 24 23a4 4 0 0 1-4 4h-3a4 4 0 0 1-4-4v-5.065c3.934-.5 7-3.934 7-8.039V5a2 2 0 0 0-2-2h-2a1 1 0 1 0 0 2h2v4.896c0 3.323-2.656 6.061-5.92 6.104A6 6 0 0 1 6 10V5h2a1 1 0 0 0 0-2H6a2 2 0 0 0-2 2v5a8 8 0 0 0 7 7.936V23a6.006 6.006 0 0 0 6 6h3a6.006 6.006 0 0 0 6-6 1 1 0 0 0-.009-.125A4 4 0 0 0 29 19m-4 1a1 1 0 1 1 0-2 1 1 0 0 1 0 2" }) });
};
O(fN);
const dN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 256 256", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M216 56v144a16 16 0 0 1-16 16H56a16 16 0 0 1-16-16V56a16 16 0 0 1 16-16h144a16 16 0 0 1 16 16" }) });
};
O(dN);
const gN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M29 12a1 1 0 0 0-.038-.275L27.17 5.45A2.01 2.01 0 0 0 25.25 4H6.75a2.01 2.01 0 0 0-1.919 1.45L3.04 11.725A1 1 0 0 0 3 12v2a5 5 0 0 0 2 4v8a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2v-8a5 5 0 0 0 2-4zm-18 2a3 3 0 0 1-4.39 2.657 1 1 0 0 0-.228-.132A3 3 0 0 1 5 14v-1h6zm8 0a3 3 0 0 1-6 0v-1h6zm8 0a3 3 0 0 1-1.384 2.525q-.12.051-.225.131A3 3 0 0 1 21 14v-1h6z" }) });
};
O(gN);
const pN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M28.5 16a1.5 1.5 0 0 1-1.5 1.5h-3.767A5.19 5.19 0 0 1 24.5 21c0 1.806-.976 3.54-2.679 4.756C20.25 26.881 18.18 27.5 16 27.5s-4.25-.619-5.821-1.744C8.476 24.54 7.5 22.806 7.5 21a1.5 1.5 0 0 1 3 0c0 1.898 2.519 3.5 5.5 3.5s5.5-1.602 5.5-3.5c0-1.595-1.163-2.523-4.419-3.5H5a1.5 1.5 0 1 1 0-3h22a1.5 1.5 0 0 1 1.5 1.5M9.389 12.5a1.5 1.5 0 0 0 1.5-1.5c0-2 2.197-3.5 5.111-3.5 2.17 0 3.921.831 4.685 2.223a1.5 1.5 0 0 0 2.625-1.446C22.016 5.914 19.281 4.5 16 4.5c-4.625 0-8.111 2.794-8.111 6.5a1.5 1.5 0 0 0 1.5 1.5" }) });
}, mN = O(pN), xte = mN, vN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M15 5V2a1 1 0 0 1 2 0v3a1 1 0 0 1-2 0m1 3a8 8 0 1 0 8 8 8.01 8.01 0 0 0-8-8m-8.707.707a1 1 0 1 0 1.414-1.415l-2-2a1 1 0 1 0-1.414 1.415zm0 14.586-2 2a1 1 0 1 0 1.414 1.415l2-2a1 1 0 1 0-1.415-1.415M24 9a1 1 0 0 0 .707-.293l2-2a1 1 0 0 0-1.415-1.414l-2 2A1 1 0 0 0 24 9m.707 14.293a1 1 0 1 0-1.415 1.415l2 2a1 1 0 0 0 1.415-1.415zM6 16a1 1 0 0 0-1-1H2a1 1 0 0 0 0 2h3a1 1 0 0 0 1-1m10 10a1 1 0 0 0-1 1v3a1 1 0 0 0 2 0v-3a1 1 0 0 0-1-1m14-11h-3a1 1 0 0 0 0 2h3a1 1 0 0 0 0-2" }) });
};
O(vN);
const bN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M27 8h-8.586l4.293-4.292a1 1 0 0 0-1.415-1.415L16 7.586l-5.292-5.293a1 1 0 1 0-1.415 1.415L13.586 8H5a2 2 0 0 0-2 2v15a2 2 0 0 0 2 2h22a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2m0 17h-7V10h7zm-2-10.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0m0 6a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0" }) });
};
O(bN);
const wN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "m29.978 19.625-1.5-12A3 3 0 0 0 25.5 5H4a2 2 0 0 0-2 2v11a2 2 0 0 0 2 2h5.383l4.722 9.448A1 1 0 0 0 15 30a5 5 0 0 0 5-5v-2h7a3 3 0 0 0 2.977-3.375M9 18H4V7h5z" }) });
};
O(wN);
const xN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M29.25 10.015A3 3 0 0 0 27 9h-7V7a5 5 0 0 0-5-5 1 1 0 0 0-.895.553L9.383 12H4a2 2 0 0 0-2 2v11a2 2 0 0 0 2 2h21.5a3 3 0 0 0 2.977-2.625l1.5-12a3 3 0 0 0-.727-2.36M4 14h5v11H4z" }) });
};
O(xN);
const yN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M23 3H9a4 4 0 0 0-4 4v16a4 4 0 0 0 4 4h1l-1.8 2.4a1 1 0 0 0 1.6 1.2l2.7-3.6h7l2.7 3.6a1 1 0 0 0 1.6-1.2L22 27h1a4 4 0 0 0 4-4V7a4 4 0 0 0-4-4M10.5 23a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3m4.5-8H7v-5h8zm6.5 8a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3m3.5-8h-8v-5h8z" }) });
};
O(yN);
const CN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M27 6h-5V5a3 3 0 0 0-3-3h-6a3 3 0 0 0-3 3v1H5a1 1 0 0 0 0 2h1v18a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V8h1a1 1 0 1 0 0-2M14 21a1 1 0 0 1-2 0v-8a1 1 0 0 1 2 0zm6 0a1 1 0 0 1-2 0v-8a1 1 0 0 1 2 0zm0-15h-8V5a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1z" }) });
}, $N = O(CN), yte = $N, SN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "m23.54 2.267-3.711 3.377c1.7.52 3.298 1.397 4.653 2.631 4.684 4.266 4.684 11.184 0 15.45q-5.184 4.72-16.021 6.008l3.71-3.377a12.2 12.2 0 0 1-4.653-2.63c-4.684-4.267-4.712-11.16 0-15.45q5.184-4.721 16.021-6.01m-7.54 8.4c-3.314 0-6 2.388-6 5.333s2.686 5.333 6 5.333 6-2.387 6-5.333c0-2.945-2.686-5.333-6-5.333" }) });
};
O(SN);
const AN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M25.5 28a1.5 1.5 0 0 1-1.5 1.5H8a1.5 1.5 0 1 1 0-3h16a1.5 1.5 0 0 1 1.5 1.5M16 24.5a8.51 8.51 0 0 0 8.5-8.5V7a1.5 1.5 0 1 0-3 0v9a5.5 5.5 0 0 1-11 0V7a1.5 1.5 0 1 0-3 0v9a8.51 8.51 0 0 0 8.5 8.5" }) });
}, kN = O(AN), Cte = kN, MN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M28.5 19v7a2.5 2.5 0 0 1-2.5 2.5H6A2.5 2.5 0 0 1 3.5 26v-7a1.5 1.5 0 0 1 3 0v6.5h19V19a1.5 1.5 0 1 1 3 0m-16.439-7.939L14.5 8.625V19a1.5 1.5 0 1 0 3 0V8.625l2.439 2.44a1.503 1.503 0 0 0 2.125-2.125l-5-5a1.5 1.5 0 0 0-2.125 0l-5 5a1.503 1.503 0 1 0 2.125 2.125z" }) });
};
O(MN);
const TN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M28.866 27.5A1 1 0 0 1 28 28H4a1 1 0 0 1-.865-1.5c1.904-3.291 4.838-5.651 8.261-6.77a9 9 0 1 1 9.208 0c3.424 1.119 6.357 3.479 8.261 6.77a1 1 0 0 1 .001 1" }) });
};
O(TN);
const RN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M19.44 3.101a1 1 0 0 0-1.054.11L9.656 10H4a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h5.656l8.73 6.789A1 1 0 0 0 20 28V4a1 1 0 0 0-.56-.899M28.414 16l2.293-2.292a1.001 1.001 0 0 0-1.415-1.415L27 14.586l-2.293-2.293a1 1 0 1 0-1.415 1.415L25.587 16l-2.293 2.293a1 1 0 0 0 1.415 1.415L27 17.414l2.293 2.294a1 1 0 0 0 1.415-1.415z" }) });
};
O(RN);
const EN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M19.439 3.101a1 1 0 0 0-1.053.11L9.656 10H4a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h5.656l8.73 6.789A1.001 1.001 0 0 0 20 28V4a1 1 0 0 0-.561-.899M9 20H4v-8h5zm15.75-7.305a5 5 0 0 1 0 6.61 1 1 0 0 1-1.5-1.322 3 3 0 0 0 0-3.966 1 1 0 0 1 1.5-1.322M31 16a10 10 0 0 1-2.546 6.668 1 1 0 0 1-1.49-1.334 8 8 0 0 0 0-10.666.998.998 0 0 1 .407-1.624 1 1 0 0 1 1.083.29A9.98 9.98 0 0 1 31 16" }) });
};
O(EN);
const ON = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M15 6a4 4 0 1 1 8 0 4 4 0 0 1-8 0m11 11c-3.58 0-5.226-1.662-6.969-3.421a25 25 0 0 0-1.375-1.323C13.031 8.24 5.63 15.098 5.316 15.391a1 1 0 0 0 1.369 1.458 20.5 20.5 0 0 1 3.815-2.724c1.723-.922 3.174-1.279 4.338-1.072L8.082 28.6a1 1 0 0 0 1.835.798l4.2-9.659L18 22.515V29a1 1 0 1 0 2 0v-7a1 1 0 0 0-.419-.814l-4.65-3.321L16.61 14c.33.305.657.634 1 .98C19.381 16.774 21.586 19 26 19a1 1 0 0 0 0-2" }) });
};
O(ON);
const DN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "M16 3a13 13 0 1 0 13 13A13.013 13.013 0 0 0 16 3m-1 7a1 1 0 0 1 2 0v7a1 1 0 0 1-2 0zm1 13a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3" }) });
}, IN = O(DN), _N = IN, LN = ({
  fill: t = "currentColor",
  stroke: e,
  ...n
}, r) => {
  const {
    colors: i
  } = V(), o = t && t in i ? i[t] : t, s = e && e in i ? i[e] : e;
  return /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", width: 16, height: 16, fill: o, stroke: s, ref: r, ...n, children: /* @__PURE__ */ m("path", { d: "m31.316 24.949-3 1a1 1 0 0 1-1.211-.5l-3.724-7.45H13a1 1 0 0 1-1-1v-3.707A7 7 0 0 0 14 27c3.239 0 6.261-2.256 7.031-5.25a1 1 0 1 1 1.938.5C21.96 26.162 18.19 29 14 29a9 9 0 0 1-2-17.774V8.851a3.5 3.5 0 1 1 2 0V11h7a1 1 0 0 1 0 2h-7v3h10a1 1 0 0 1 .894.552l3.612 7.225 2.178-.726a1 1 0 1 1 .632 1.898" }) });
};
O(LN);
const Wx = "Avatar", [BN, $te] = Tt(Wx), [NN, zx] = BN(Wx), FN = /* @__PURE__ */ O((t, e) => {
  const { __scopeAvatar: n, ...r } = t, [i, o] = De("idle");
  return /* @__PURE__ */ B(NN, {
    scope: n,
    imageLoadingStatus: i,
    onImageLoadingStatusChange: o
  }, /* @__PURE__ */ B(we.span, G({}, r, {
    ref: e
  })));
}), VN = "AvatarImage", HN = /* @__PURE__ */ O((t, e) => {
  const { __scopeAvatar: n, src: r, onLoadingStatusChange: i = () => {
  }, ...o } = t, s = zx(VN, n), a = zN(r), c = Ot((h) => {
    i(h), s.onImageLoadingStatusChange(h);
  });
  return xt(() => {
    a !== "idle" && c(a);
  }, [
    a,
    c
  ]), a === "loaded" ? /* @__PURE__ */ B(we.img, G({}, o, {
    ref: e,
    src: r
  })) : null;
}), PN = "AvatarFallback", WN = /* @__PURE__ */ O((t, e) => {
  const { __scopeAvatar: n, delayMs: r, ...i } = t, o = zx(PN, n), [s, a] = De(r === void 0);
  return Ce(() => {
    if (r !== void 0) {
      const c = window.setTimeout(
        () => a(!0),
        r
      );
      return () => window.clearTimeout(c);
    }
  }, [
    r
  ]), s && o.imageLoadingStatus !== "loaded" ? /* @__PURE__ */ B(we.span, G({}, i, {
    ref: e
  })) : null;
});
function zN(t) {
  const [e, n] = De("idle");
  return xt(() => {
    if (!t) {
      n("error");
      return;
    }
    let r = !0;
    const i = new window.Image(), o = (s) => () => {
      r && n(s);
    };
    return n("loading"), i.onload = o("loaded"), i.onerror = o("error"), i.src = t, () => {
      r = !1;
    };
  }, [
    t
  ]), e;
}
const UN = FN, KN = HN, qN = WN, e0 = "rovingFocusGroup.onEntryFocus", GN = {
  bubbles: !1,
  cancelable: !0
}, hp = "RovingFocusGroup", [i1, Ux, YN] = Bh(hp), [jN, ta] = Tt(hp, [
  YN
]), [XN, ZN] = jN(hp), QN = /* @__PURE__ */ O((t, e) => /* @__PURE__ */ B(i1.Provider, {
  scope: t.__scopeRovingFocusGroup
}, /* @__PURE__ */ B(i1.Slot, {
  scope: t.__scopeRovingFocusGroup
}, /* @__PURE__ */ B(JN, G({}, t, {
  ref: e
}))))), JN = /* @__PURE__ */ O((t, e) => {
  const { __scopeRovingFocusGroup: n, orientation: r, loop: i = !1, dir: o, currentTabStopId: s, defaultCurrentTabStopId: a, onCurrentTabStopIdChange: c, onEntryFocus: h, ...f } = t, d = ue(null), p = ke(e, d), v = Fo(o), [w = null, b] = zt({
    prop: s,
    defaultProp: a,
    onChange: c
  }), [y, $] = De(!1), A = Ot(h), k = Ux(n), T = ue(!1), [R, _] = De(0);
  return Ce(() => {
    const D = d.current;
    if (D)
      return D.addEventListener(e0, A), () => D.removeEventListener(e0, A);
  }, [
    A
  ]), /* @__PURE__ */ B(XN, {
    scope: n,
    orientation: r,
    dir: v,
    loop: i,
    currentTabStopId: w,
    onItemFocus: rt(
      (D) => b(D),
      [
        b
      ]
    ),
    onItemShiftTab: rt(
      () => $(!0),
      []
    ),
    onFocusableItemAdd: rt(
      () => _(
        (D) => D + 1
      ),
      []
    ),
    onFocusableItemRemove: rt(
      () => _(
        (D) => D - 1
      ),
      []
    )
  }, /* @__PURE__ */ B(we.div, G({
    tabIndex: y || R === 0 ? -1 : 0,
    "data-orientation": r
  }, f, {
    ref: p,
    style: {
      outline: "none",
      ...t.style
    },
    onMouseDown: oe(t.onMouseDown, () => {
      T.current = !0;
    }),
    onFocus: oe(t.onFocus, (D) => {
      const P = !T.current;
      if (D.target === D.currentTarget && P && !y) {
        const H = new CustomEvent(e0, GN);
        if (D.currentTarget.dispatchEvent(H), !H.defaultPrevented) {
          const z = k().filter(
            (re) => re.focusable
          ), j = z.find(
            (re) => re.active
          ), K = z.find(
            (re) => re.id === w
          ), ee = [
            j,
            K,
            ...z
          ].filter(Boolean).map(
            (re) => re.ref.current
          );
          Kx(ee);
        }
      }
      T.current = !1;
    }),
    onBlur: oe(
      t.onBlur,
      () => $(!1)
    )
  })));
}), eF = "RovingFocusGroupItem", tF = /* @__PURE__ */ O((t, e) => {
  const { __scopeRovingFocusGroup: n, focusable: r = !0, active: i = !1, tabStopId: o, ...s } = t, a = Ut(), c = o || a, h = ZN(eF, n), f = h.currentTabStopId === c, d = Ux(n), { onFocusableItemAdd: p, onFocusableItemRemove: v } = h;
  return Ce(() => {
    if (r)
      return p(), () => v();
  }, [
    r,
    p,
    v
  ]), /* @__PURE__ */ B(i1.ItemSlot, {
    scope: n,
    id: c,
    focusable: r,
    active: i
  }, /* @__PURE__ */ B(we.span, G({
    tabIndex: f ? 0 : -1,
    "data-orientation": h.orientation
  }, s, {
    ref: e,
    onMouseDown: oe(t.onMouseDown, (w) => {
      r ? h.onItemFocus(c) : w.preventDefault();
    }),
    onFocus: oe(
      t.onFocus,
      () => h.onItemFocus(c)
    ),
    onKeyDown: oe(t.onKeyDown, (w) => {
      if (w.key === "Tab" && w.shiftKey) {
        h.onItemShiftTab();
        return;
      }
      if (w.target !== w.currentTarget) return;
      const b = iF(w, h.orientation, h.dir);
      if (b !== void 0) {
        w.preventDefault();
        let $ = d().filter(
          (A) => A.focusable
        ).map(
          (A) => A.ref.current
        );
        if (b === "last") $.reverse();
        else if (b === "prev" || b === "next") {
          b === "prev" && $.reverse();
          const A = $.indexOf(w.currentTarget);
          $ = h.loop ? oF($, A + 1) : $.slice(A + 1);
        }
        setTimeout(
          () => Kx($)
        );
      }
    })
  })));
}), nF = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function rF(t, e) {
  return e !== "rtl" ? t : t === "ArrowLeft" ? "ArrowRight" : t === "ArrowRight" ? "ArrowLeft" : t;
}
function iF(t, e, n) {
  const r = rF(t.key, n);
  if (!(e === "vertical" && [
    "ArrowLeft",
    "ArrowRight"
  ].includes(r)) && !(e === "horizontal" && [
    "ArrowUp",
    "ArrowDown"
  ].includes(r)))
    return nF[r];
}
function Kx(t) {
  const e = document.activeElement;
  for (const n of t)
    if (n === e || (n.focus(), document.activeElement !== e)) return;
}
function oF(t, e) {
  return t.map(
    (n, r) => t[(e + r) % t.length]
  );
}
const fp = QN, dp = tF;
var sF = function(t) {
  if (typeof document > "u")
    return null;
  var e = Array.isArray(t) ? t[0] : t;
  return e.ownerDocument.body;
}, cs = /* @__PURE__ */ new WeakMap(), Lc = /* @__PURE__ */ new WeakMap(), Bc = {}, t0 = 0, qx = function(t) {
  return t && (t.host || qx(t.parentNode));
}, aF = function(t, e) {
  return e.map(function(n) {
    if (t.contains(n))
      return n;
    var r = qx(n);
    return r && t.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", t, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, lF = function(t, e, n, r) {
  var i = aF(e, Array.isArray(t) ? t : [t]);
  Bc[n] || (Bc[n] = /* @__PURE__ */ new WeakMap());
  var o = Bc[n], s = [], a = /* @__PURE__ */ new Set(), c = new Set(i), h = function(d) {
    !d || a.has(d) || (a.add(d), h(d.parentNode));
  };
  i.forEach(h);
  var f = function(d) {
    !d || c.has(d) || Array.prototype.forEach.call(d.children, function(p) {
      if (a.has(p))
        f(p);
      else
        try {
          var v = p.getAttribute(r), w = v !== null && v !== "false", b = (cs.get(p) || 0) + 1, y = (o.get(p) || 0) + 1;
          cs.set(p, b), o.set(p, y), s.push(p), b === 1 && w && Lc.set(p, !0), y === 1 && p.setAttribute(n, "true"), w || p.setAttribute(r, "true");
        } catch ($) {
          console.error("aria-hidden: cannot operate on ", p, $);
        }
    });
  };
  return f(e), a.clear(), t0++, function() {
    s.forEach(function(d) {
      var p = cs.get(d) - 1, v = o.get(d) - 1;
      cs.set(d, p), o.set(d, v), p || (Lc.has(d) || d.removeAttribute(r), Lc.delete(d)), v || d.removeAttribute(n);
    }), t0--, t0 || (cs = /* @__PURE__ */ new WeakMap(), cs = /* @__PURE__ */ new WeakMap(), Lc = /* @__PURE__ */ new WeakMap(), Bc = {});
  };
}, gp = function(t, e, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(t) ? t : [t]), i = sF(t);
  return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live], script"))), lF(r, i, n, "aria-hidden")) : function() {
    return null;
  };
}, Gx = Oh(), n0 = function() {
}, zh = C.forwardRef(function(t, e) {
  var n = C.useRef(null), r = C.useState({
    onScrollCapture: n0,
    onWheelCapture: n0,
    onTouchMoveCapture: n0
  }), i = r[0], o = r[1], s = t.forwardProps, a = t.children, c = t.className, h = t.removeScrollBar, f = t.enabled, d = t.shards, p = t.sideCar, v = t.noIsolation, w = t.inert, b = t.allowPinchZoom, y = t.as, $ = y === void 0 ? "div" : y, A = xl(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]), k = p, T = Eh([n, e]), R = lt(lt({}, A), i);
  return C.createElement(
    C.Fragment,
    null,
    f && C.createElement(k, { sideCar: Gx, removeScrollBar: h, shards: d, noIsolation: v, inert: w, setCallbacks: o, allowPinchZoom: !!b, lockRef: n }),
    s ? C.cloneElement(C.Children.only(a), lt(lt({}, R), { ref: T })) : C.createElement($, lt({}, R, { className: c, ref: T }), a)
  );
});
zh.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
zh.classNames = {
  fullWidth: wo,
  zeroRight: bo
};
var o1 = !1;
if (typeof window < "u")
  try {
    var Nc = Object.defineProperty({}, "passive", {
      get: function() {
        return o1 = !0, !0;
      }
    });
    window.addEventListener("test", Nc, Nc), window.removeEventListener("test", Nc, Nc);
  } catch {
    o1 = !1;
  }
var us = o1 ? { passive: !1 } : !1, cF = function(t) {
  return t.tagName === "TEXTAREA";
}, Yx = function(t, e) {
  var n = window.getComputedStyle(t);
  return (
    // not-not-scrollable
    n[e] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !cF(t) && n[e] === "visible")
  );
}, uF = function(t) {
  return Yx(t, "overflowY");
}, hF = function(t) {
  return Yx(t, "overflowX");
}, g5 = function(t, e) {
  var n = e;
  do {
    typeof ShadowRoot < "u" && n instanceof ShadowRoot && (n = n.host);
    var r = jx(t, n);
    if (r) {
      var i = Xx(t, n), o = i[1], s = i[2];
      if (o > s)
        return !0;
    }
    n = n.parentNode;
  } while (n && n !== document.body);
  return !1;
}, fF = function(t) {
  var e = t.scrollTop, n = t.scrollHeight, r = t.clientHeight;
  return [
    e,
    n,
    r
  ];
}, dF = function(t) {
  var e = t.scrollLeft, n = t.scrollWidth, r = t.clientWidth;
  return [
    e,
    n,
    r
  ];
}, jx = function(t, e) {
  return t === "v" ? uF(e) : hF(e);
}, Xx = function(t, e) {
  return t === "v" ? fF(e) : dF(e);
}, gF = function(t, e) {
  return t === "h" && e === "rtl" ? -1 : 1;
}, pF = function(t, e, n, r, i) {
  var o = gF(t, window.getComputedStyle(e).direction), s = o * r, a = n.target, c = e.contains(a), h = !1, f = s > 0, d = 0, p = 0;
  do {
    var v = Xx(t, a), w = v[0], b = v[1], y = v[2], $ = b - y - o * w;
    (w || $) && jx(t, a) && (d += $, p += w), a = a.parentNode;
  } while (
    // portaled content
    !c && a !== document.body || // self content
    c && (e.contains(a) || e === a)
  );
  return (f && d === 0 || !f && p === 0) && (h = !0), h;
}, Fc = function(t) {
  return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0];
}, p5 = function(t) {
  return [t.deltaX, t.deltaY];
}, m5 = function(t) {
  return t && "current" in t ? t.current : t;
}, mF = function(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}, vF = function(t) {
  return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`);
}, bF = 0, hs = [];
function wF(t) {
  var e = C.useRef([]), n = C.useRef([0, 0]), r = C.useRef(), i = C.useState(bF++)[0], o = C.useState(function() {
    return yl();
  })[0], s = C.useRef(t);
  C.useEffect(function() {
    s.current = t;
  }, [t]), C.useEffect(function() {
    if (t.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var b = Rh([t.lockRef.current], (t.shards || []).map(m5), !0).filter(Boolean);
      return b.forEach(function(y) {
        return y.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), b.forEach(function(y) {
          return y.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [t.inert, t.lockRef.current, t.shards]);
  var a = C.useCallback(function(b, y) {
    if ("touches" in b && b.touches.length === 2)
      return !s.current.allowPinchZoom;
    var $ = Fc(b), A = n.current, k = "deltaX" in b ? b.deltaX : A[0] - $[0], T = "deltaY" in b ? b.deltaY : A[1] - $[1], R, _ = b.target, D = Math.abs(k) > Math.abs(T) ? "h" : "v";
    if ("touches" in b && D === "h" && _.type === "range")
      return !1;
    var P = g5(D, _);
    if (!P)
      return !0;
    if (P ? R = D : (R = D === "v" ? "h" : "v", P = g5(D, _)), !P)
      return !1;
    if (!r.current && "changedTouches" in b && (k || T) && (r.current = R), !R)
      return !0;
    var H = r.current || R;
    return pF(H, y, b, H === "h" ? k : T);
  }, []), c = C.useCallback(function(b) {
    var y = b;
    if (!(!hs.length || hs[hs.length - 1] !== o)) {
      var $ = "deltaY" in y ? p5(y) : Fc(y), A = e.current.filter(function(R) {
        return R.name === y.type && R.target === y.target && mF(R.delta, $);
      })[0];
      if (A && A.should) {
        y.cancelable && y.preventDefault();
        return;
      }
      if (!A) {
        var k = (s.current.shards || []).map(m5).filter(Boolean).filter(function(R) {
          return R.contains(y.target);
        }), T = k.length > 0 ? a(y, k[0]) : !s.current.noIsolation;
        T && y.cancelable && y.preventDefault();
      }
    }
  }, []), h = C.useCallback(function(b, y, $, A) {
    var k = { name: b, delta: y, target: $, should: A };
    e.current.push(k), setTimeout(function() {
      e.current = e.current.filter(function(T) {
        return T !== k;
      });
    }, 1);
  }, []), f = C.useCallback(function(b) {
    n.current = Fc(b), r.current = void 0;
  }, []), d = C.useCallback(function(b) {
    h(b.type, p5(b), b.target, a(b, t.lockRef.current));
  }, []), p = C.useCallback(function(b) {
    h(b.type, Fc(b), b.target, a(b, t.lockRef.current));
  }, []);
  C.useEffect(function() {
    return hs.push(o), t.setCallbacks({
      onScrollCapture: d,
      onWheelCapture: d,
      onTouchMoveCapture: p
    }), document.addEventListener("wheel", c, us), document.addEventListener("touchmove", c, us), document.addEventListener("touchstart", f, us), function() {
      hs = hs.filter(function(b) {
        return b !== o;
      }), document.removeEventListener("wheel", c, us), document.removeEventListener("touchmove", c, us), document.removeEventListener("touchstart", f, us);
    };
  }, []);
  var v = t.removeScrollBar, w = t.inert;
  return C.createElement(
    C.Fragment,
    null,
    w ? C.createElement(o, { styles: vF(i) }) : null,
    v ? C.createElement(_h, { gapMode: "margin" }) : null
  );
}
const xF = Dh(Gx, wF);
var Zx = C.forwardRef(function(t, e) {
  return C.createElement(zh, lt({}, t, { ref: e, sideCar: xF }));
});
Zx.classNames = zh.classNames;
const s1 = [
  "Enter",
  " "
], yF = [
  "ArrowDown",
  "PageUp",
  "Home"
], Qx = [
  "ArrowUp",
  "PageDown",
  "End"
], CF = [
  ...yF,
  ...Qx
], $F = {
  ltr: [
    ...s1,
    "ArrowRight"
  ],
  rtl: [
    ...s1,
    "ArrowLeft"
  ]
}, SF = {
  ltr: [
    "ArrowLeft"
  ],
  rtl: [
    "ArrowRight"
  ]
}, Uh = "Menu", [ja, AF, kF] = Bh(Uh), [Ho, Jx] = Tt(Uh, [
  kF,
  Yi,
  ta
]), pp = Yi(), ey = ta(), [MF, Po] = Ho(Uh), [TF, Al] = Ho(Uh), RF = (t) => {
  const { __scopeMenu: e, open: n = !1, children: r, dir: i, onOpenChange: o, modal: s = !0 } = t, a = pp(e), [c, h] = De(null), f = ue(!1), d = Ot(o), p = Fo(i);
  return Ce(() => {
    const v = () => {
      f.current = !0, document.addEventListener("pointerdown", w, {
        capture: !0,
        once: !0
      }), document.addEventListener("pointermove", w, {
        capture: !0,
        once: !0
      });
    }, w = () => f.current = !1;
    return document.addEventListener("keydown", v, {
      capture: !0
    }), () => {
      document.removeEventListener("keydown", v, {
        capture: !0
      }), document.removeEventListener("pointerdown", w, {
        capture: !0
      }), document.removeEventListener("pointermove", w, {
        capture: !0
      });
    };
  }, []), /* @__PURE__ */ B(ml, a, /* @__PURE__ */ B(MF, {
    scope: e,
    open: n,
    onOpenChange: d,
    content: c,
    onContentChange: h
  }, /* @__PURE__ */ B(TF, {
    scope: e,
    onClose: rt(
      () => d(!1),
      [
        d
      ]
    ),
    isUsingKeyboardRef: f,
    dir: p,
    modal: s
  }, r)));
}, ty = /* @__PURE__ */ O((t, e) => {
  const { __scopeMenu: n, ...r } = t, i = pp(n);
  return /* @__PURE__ */ B(vl, G({}, i, r, {
    ref: e
  }));
}), ny = "MenuPortal", [EF, ry] = Ho(ny, {
  forceMount: void 0
}), OF = (t) => {
  const { __scopeMenu: e, forceMount: n, children: r, container: i } = t, o = Po(ny, e);
  return /* @__PURE__ */ B(EF, {
    scope: e,
    forceMount: n
  }, /* @__PURE__ */ B(Vt, {
    present: n || o.open
  }, /* @__PURE__ */ B(Zs, {
    asChild: !0,
    container: i
  }, r)));
}, lr = "MenuContent", [DF, mp] = Ho(lr), IF = /* @__PURE__ */ O((t, e) => {
  const n = ry(lr, t.__scopeMenu), { forceMount: r = n.forceMount, ...i } = t, o = Po(lr, t.__scopeMenu), s = Al(lr, t.__scopeMenu);
  return /* @__PURE__ */ B(ja.Provider, {
    scope: t.__scopeMenu
  }, /* @__PURE__ */ B(Vt, {
    present: r || o.open
  }, /* @__PURE__ */ B(ja.Slot, {
    scope: t.__scopeMenu
  }, s.modal ? /* @__PURE__ */ B(_F, G({}, i, {
    ref: e
  })) : /* @__PURE__ */ B(LF, G({}, i, {
    ref: e
  })))));
}), _F = /* @__PURE__ */ O((t, e) => {
  const n = Po(lr, t.__scopeMenu), r = ue(null), i = ke(e, r);
  return Ce(() => {
    const o = r.current;
    if (o) return gp(o);
  }, []), /* @__PURE__ */ B(vp, G({}, t, {
    ref: i,
    trapFocus: n.open,
    disableOutsidePointerEvents: n.open,
    disableOutsideScroll: !0,
    onFocusOutside: oe(
      t.onFocusOutside,
      (o) => o.preventDefault(),
      {
        checkForDefaultPrevented: !1
      }
    ),
    onDismiss: () => n.onOpenChange(!1)
  }));
}), LF = /* @__PURE__ */ O((t, e) => {
  const n = Po(lr, t.__scopeMenu);
  return /* @__PURE__ */ B(vp, G({}, t, {
    ref: e,
    trapFocus: !1,
    disableOutsidePointerEvents: !1,
    disableOutsideScroll: !1,
    onDismiss: () => n.onOpenChange(!1)
  }));
}), vp = /* @__PURE__ */ O((t, e) => {
  const { __scopeMenu: n, loop: r = !1, trapFocus: i, onOpenAutoFocus: o, onCloseAutoFocus: s, disableOutsidePointerEvents: a, onEntryFocus: c, onEscapeKeyDown: h, onPointerDownOutside: f, onFocusOutside: d, onInteractOutside: p, onDismiss: v, disableOutsideScroll: w, ...b } = t, y = Po(lr, n), $ = Al(lr, n), A = pp(n), k = ey(n), T = AF(n), [R, _] = De(null), D = ue(null), P = ke(e, D, y.onContentChange), H = ue(0), z = ue(""), j = ue(0), K = ue(null), te = ue("right"), ee = ue(0), re = w ? Zx : xh, de = w ? {
    as: Dr,
    allowPinchZoom: !0
  } : void 0, ie = (X) => {
    var ce, be;
    const Le = z.current + X, Ae = T().filter(
      (Oe) => !Oe.disabled
    ), qe = document.activeElement, He = (ce = Ae.find(
      (Oe) => Oe.ref.current === qe
    )) === null || ce === void 0 ? void 0 : ce.textValue, Ze = Ae.map(
      (Oe) => Oe.textValue
    ), xe = GF(Ze, Le, He), Ve = (be = Ae.find(
      (Oe) => Oe.textValue === xe
    )) === null || be === void 0 ? void 0 : be.ref.current;
    (function Oe(Ue) {
      z.current = Ue, window.clearTimeout(H.current), Ue !== "" && (H.current = window.setTimeout(
        () => Oe(""),
        1e3
      ));
    })(Le), Ve && setTimeout(
      () => Ve.focus()
    );
  };
  Ce(() => () => window.clearTimeout(H.current), []), Qs();
  const se = rt((X) => {
    var ce, be;
    return te.current === ((ce = K.current) === null || ce === void 0 ? void 0 : ce.side) && jF(X, (be = K.current) === null || be === void 0 ? void 0 : be.area);
  }, []);
  return /* @__PURE__ */ B(DF, {
    scope: n,
    searchRef: z,
    onItemEnter: rt((X) => {
      se(X) && X.preventDefault();
    }, [
      se
    ]),
    onItemLeave: rt((X) => {
      var ce;
      se(X) || ((ce = D.current) === null || ce === void 0 || ce.focus(), _(null));
    }, [
      se
    ]),
    onTriggerLeave: rt((X) => {
      se(X) && X.preventDefault();
    }, [
      se
    ]),
    pointerGraceTimerRef: j,
    onPointerGraceIntentChange: rt((X) => {
      K.current = X;
    }, [])
  }, /* @__PURE__ */ B(re, de, /* @__PURE__ */ B(Js, {
    asChild: !0,
    trapped: i,
    onMountAutoFocus: oe(o, (X) => {
      var ce;
      X.preventDefault(), (ce = D.current) === null || ce === void 0 || ce.focus();
    }),
    onUnmountAutoFocus: s
  }, /* @__PURE__ */ B(No, {
    asChild: !0,
    disableOutsidePointerEvents: a,
    onEscapeKeyDown: h,
    onPointerDownOutside: f,
    onFocusOutside: d,
    onInteractOutside: p,
    onDismiss: v
  }, /* @__PURE__ */ B(fp, G({
    asChild: !0
  }, k, {
    dir: $.dir,
    orientation: "vertical",
    loop: r,
    currentTabStopId: R,
    onCurrentTabStopIdChange: _,
    onEntryFocus: oe(c, (X) => {
      $.isUsingKeyboardRef.current || X.preventDefault();
    })
  }), /* @__PURE__ */ B(bl, G({
    role: "menu",
    "aria-orientation": "vertical",
    "data-state": sy(y.open),
    "data-radix-menu-content": "",
    dir: $.dir
  }, A, b, {
    ref: P,
    style: {
      outline: "none",
      ...b.style
    },
    onKeyDown: oe(b.onKeyDown, (X) => {
      const be = X.target.closest("[data-radix-menu-content]") === X.currentTarget, Le = X.ctrlKey || X.altKey || X.metaKey, Ae = X.key.length === 1;
      be && (X.key === "Tab" && X.preventDefault(), !Le && Ae && ie(X.key));
      const qe = D.current;
      if (X.target !== qe || !CF.includes(X.key)) return;
      X.preventDefault();
      const Ze = T().filter(
        (xe) => !xe.disabled
      ).map(
        (xe) => xe.ref.current
      );
      Qx.includes(X.key) && Ze.reverse(), KF(Ze);
    }),
    onBlur: oe(t.onBlur, (X) => {
      X.currentTarget.contains(X.target) || (window.clearTimeout(H.current), z.current = "");
    }),
    onPointerMove: oe(t.onPointerMove, Xa((X) => {
      const ce = X.target, be = ee.current !== X.clientX;
      if (X.currentTarget.contains(ce) && be) {
        const Le = X.clientX > ee.current ? "right" : "left";
        te.current = Le, ee.current = X.clientX;
      }
    }))
  })))))));
}), BF = /* @__PURE__ */ O((t, e) => {
  const { __scopeMenu: n, ...r } = t;
  return /* @__PURE__ */ B(we.div, G({}, r, {
    ref: e
  }));
}), a1 = "MenuItem", v5 = "menu.itemSelect", NF = /* @__PURE__ */ O((t, e) => {
  const { disabled: n = !1, onSelect: r, ...i } = t, o = ue(null), s = Al(a1, t.__scopeMenu), a = mp(a1, t.__scopeMenu), c = ke(e, o), h = ue(!1), f = () => {
    const d = o.current;
    if (!n && d) {
      const p = new CustomEvent(v5, {
        bubbles: !0,
        cancelable: !0
      });
      d.addEventListener(
        v5,
        (v) => r?.(v),
        {
          once: !0
        }
      ), m3(d, p), p.defaultPrevented ? h.current = !1 : s.onClose();
    }
  };
  return /* @__PURE__ */ B(iy, G({}, i, {
    ref: c,
    disabled: n,
    onClick: oe(t.onClick, f),
    onPointerDown: (d) => {
      var p;
      (p = t.onPointerDown) === null || p === void 0 || p.call(t, d), h.current = !0;
    },
    onPointerUp: oe(t.onPointerUp, (d) => {
      var p;
      h.current || (p = d.currentTarget) === null || p === void 0 || p.click();
    }),
    onKeyDown: oe(t.onKeyDown, (d) => {
      const p = a.searchRef.current !== "";
      n || p && d.key === " " || s1.includes(d.key) && (d.currentTarget.click(), d.preventDefault());
    })
  }));
}), iy = /* @__PURE__ */ O((t, e) => {
  const { __scopeMenu: n, disabled: r = !1, textValue: i, ...o } = t, s = mp(a1, n), a = ey(n), c = ue(null), h = ke(e, c), [f, d] = De(!1), [p, v] = De("");
  return Ce(() => {
    const w = c.current;
    if (w) {
      var b;
      v(((b = w.textContent) !== null && b !== void 0 ? b : "").trim());
    }
  }, [
    o.children
  ]), /* @__PURE__ */ B(ja.ItemSlot, {
    scope: n,
    disabled: r,
    textValue: i ?? p
  }, /* @__PURE__ */ B(dp, G({
    asChild: !0
  }, a, {
    focusable: !r
  }), /* @__PURE__ */ B(we.div, G({
    role: "menuitem",
    "data-highlighted": f ? "" : void 0,
    "aria-disabled": r || void 0,
    "data-disabled": r ? "" : void 0
  }, o, {
    ref: h,
    onPointerMove: oe(t.onPointerMove, Xa((w) => {
      r ? s.onItemLeave(w) : (s.onItemEnter(w), w.defaultPrevented || w.currentTarget.focus());
    })),
    onPointerLeave: oe(t.onPointerLeave, Xa(
      (w) => s.onItemLeave(w)
    )),
    onFocus: oe(
      t.onFocus,
      () => d(!0)
    ),
    onBlur: oe(
      t.onBlur,
      () => d(!1)
    )
  }))));
}), FF = "MenuRadioGroup", [Ste, Ate] = Ho(FF, {
  value: void 0,
  onValueChange: () => {
  }
}), VF = "MenuItemIndicator", [kte, Mte] = Ho(VF, {
  checked: !1
}), HF = /* @__PURE__ */ O((t, e) => {
  const { __scopeMenu: n, ...r } = t;
  return /* @__PURE__ */ B(we.div, G({
    role: "separator",
    "aria-orientation": "horizontal"
  }, r, {
    ref: e
  }));
}), PF = "MenuSub", [Tte, oy] = Ho(PF), Vc = "MenuSubTrigger", WF = /* @__PURE__ */ O((t, e) => {
  const n = Po(Vc, t.__scopeMenu), r = Al(Vc, t.__scopeMenu), i = oy(Vc, t.__scopeMenu), o = mp(Vc, t.__scopeMenu), s = ue(null), { pointerGraceTimerRef: a, onPointerGraceIntentChange: c } = o, h = {
    __scopeMenu: t.__scopeMenu
  }, f = rt(() => {
    s.current && window.clearTimeout(s.current), s.current = null;
  }, []);
  return Ce(
    () => f,
    [
      f
    ]
  ), Ce(() => {
    const d = a.current;
    return () => {
      window.clearTimeout(d), c(null);
    };
  }, [
    a,
    c
  ]), /* @__PURE__ */ B(ty, G({
    asChild: !0
  }, h), /* @__PURE__ */ B(iy, G({
    id: i.triggerId,
    "aria-haspopup": "menu",
    "aria-expanded": n.open,
    "aria-controls": i.contentId,
    "data-state": sy(n.open)
  }, t, {
    ref: $h(e, i.onTriggerChange),
    onClick: (d) => {
      var p;
      (p = t.onClick) === null || p === void 0 || p.call(t, d), !(t.disabled || d.defaultPrevented) && (d.currentTarget.focus(), n.open || n.onOpenChange(!0));
    },
    onPointerMove: oe(t.onPointerMove, Xa((d) => {
      o.onItemEnter(d), !d.defaultPrevented && !t.disabled && !n.open && !s.current && (o.onPointerGraceIntentChange(null), s.current = window.setTimeout(() => {
        n.onOpenChange(!0), f();
      }, 100));
    })),
    onPointerLeave: oe(t.onPointerLeave, Xa((d) => {
      var p;
      f();
      const v = (p = n.content) === null || p === void 0 ? void 0 : p.getBoundingClientRect();
      if (v) {
        var w;
        const b = (w = n.content) === null || w === void 0 ? void 0 : w.dataset.side, y = b === "right", $ = y ? -5 : 5, A = v[y ? "left" : "right"], k = v[y ? "right" : "left"];
        o.onPointerGraceIntentChange({
          area: [
            // consistently within polygon bounds
            {
              x: d.clientX + $,
              y: d.clientY
            },
            {
              x: A,
              y: v.top
            },
            {
              x: k,
              y: v.top
            },
            {
              x: k,
              y: v.bottom
            },
            {
              x: A,
              y: v.bottom
            }
          ],
          side: b
        }), window.clearTimeout(a.current), a.current = window.setTimeout(
          () => o.onPointerGraceIntentChange(null),
          300
        );
      } else {
        if (o.onTriggerLeave(d), d.defaultPrevented) return;
        o.onPointerGraceIntentChange(null);
      }
    })),
    onKeyDown: oe(t.onKeyDown, (d) => {
      const p = o.searchRef.current !== "";
      if (!(t.disabled || p && d.key === " ") && $F[r.dir].includes(d.key)) {
        var v;
        n.onOpenChange(!0), (v = n.content) === null || v === void 0 || v.focus(), d.preventDefault();
      }
    })
  })));
}), zF = "MenuSubContent", UF = /* @__PURE__ */ O((t, e) => {
  const n = ry(lr, t.__scopeMenu), { forceMount: r = n.forceMount, ...i } = t, o = Po(lr, t.__scopeMenu), s = Al(lr, t.__scopeMenu), a = oy(zF, t.__scopeMenu), c = ue(null), h = ke(e, c);
  return /* @__PURE__ */ B(ja.Provider, {
    scope: t.__scopeMenu
  }, /* @__PURE__ */ B(Vt, {
    present: r || o.open
  }, /* @__PURE__ */ B(ja.Slot, {
    scope: t.__scopeMenu
  }, /* @__PURE__ */ B(vp, G({
    id: a.contentId,
    "aria-labelledby": a.triggerId
  }, i, {
    ref: h,
    align: "start",
    side: s.dir === "rtl" ? "left" : "right",
    disableOutsidePointerEvents: !1,
    disableOutsideScroll: !1,
    trapFocus: !1,
    onOpenAutoFocus: (f) => {
      var d;
      s.isUsingKeyboardRef.current && ((d = c.current) === null || d === void 0 || d.focus()), f.preventDefault();
    },
    onCloseAutoFocus: (f) => f.preventDefault(),
    onFocusOutside: oe(t.onFocusOutside, (f) => {
      f.target !== a.trigger && o.onOpenChange(!1);
    }),
    onEscapeKeyDown: oe(t.onEscapeKeyDown, (f) => {
      s.onClose(), f.preventDefault();
    }),
    onKeyDown: oe(t.onKeyDown, (f) => {
      const d = f.currentTarget.contains(f.target), p = SF[s.dir].includes(f.key);
      if (d && p) {
        var v;
        o.onOpenChange(!1), (v = a.trigger) === null || v === void 0 || v.focus(), f.preventDefault();
      }
    })
  })))));
});
function sy(t) {
  return t ? "open" : "closed";
}
function KF(t) {
  const e = document.activeElement;
  for (const n of t)
    if (n === e || (n.focus(), document.activeElement !== e)) return;
}
function qF(t, e) {
  return t.map(
    (n, r) => t[(e + r) % t.length]
  );
}
function GF(t, e, n) {
  const i = e.length > 1 && Array.from(e).every(
    (h) => h === e[0]
  ) ? e[0] : e, o = n ? t.indexOf(n) : -1;
  let s = qF(t, Math.max(o, 0));
  i.length === 1 && (s = s.filter(
    (h) => h !== n
  ));
  const c = s.find(
    (h) => h.toLowerCase().startsWith(i.toLowerCase())
  );
  return c !== n ? c : void 0;
}
function YF(t, e) {
  const { x: n, y: r } = t;
  let i = !1;
  for (let o = 0, s = e.length - 1; o < e.length; s = o++) {
    const a = e[o].x, c = e[o].y, h = e[s].x, f = e[s].y;
    c > r != f > r && n < (h - a) * (r - c) / (f - c) + a && (i = !i);
  }
  return i;
}
function jF(t, e) {
  if (!e) return !1;
  const n = {
    x: t.clientX,
    y: t.clientY
  };
  return YF(n, e);
}
function Xa(t) {
  return (e) => e.pointerType === "mouse" ? t(e) : void 0;
}
const XF = RF, ZF = ty, QF = OF, JF = IF, eV = BF, tV = NF, nV = HF, rV = WF, iV = UF, ay = "DropdownMenu", [oV, Rte] = Tt(ay, [
  Jx
]), vi = Jx(), [sV, ly] = oV(ay), aV = (t) => {
  const { __scopeDropdownMenu: e, children: n, dir: r, open: i, defaultOpen: o, onOpenChange: s, modal: a = !0 } = t, c = vi(e), h = ue(null), [f = !1, d] = zt({
    prop: i,
    defaultProp: o,
    onChange: s
  });
  return /* @__PURE__ */ B(sV, {
    scope: e,
    triggerId: Ut(),
    triggerRef: h,
    contentId: Ut(),
    open: f,
    onOpenChange: d,
    onOpenToggle: rt(
      () => d(
        (p) => !p
      ),
      [
        d
      ]
    ),
    modal: a
  }, /* @__PURE__ */ B(XF, G({}, c, {
    open: f,
    onOpenChange: d,
    dir: r,
    modal: a
  }), n));
}, lV = "DropdownMenuTrigger", cV = /* @__PURE__ */ O((t, e) => {
  const { __scopeDropdownMenu: n, disabled: r = !1, ...i } = t, o = ly(lV, n), s = vi(n);
  return /* @__PURE__ */ B(ZF, G({
    asChild: !0
  }, s), /* @__PURE__ */ B(we.button, G({
    type: "button",
    id: o.triggerId,
    "aria-haspopup": "menu",
    "aria-expanded": o.open,
    "aria-controls": o.open ? o.contentId : void 0,
    "data-state": o.open ? "open" : "closed",
    "data-disabled": r ? "" : void 0,
    disabled: r
  }, i, {
    ref: $h(e, o.triggerRef),
    onPointerDown: oe(t.onPointerDown, (a) => {
      !r && a.button === 0 && a.ctrlKey === !1 && (o.onOpenToggle(), o.open || a.preventDefault());
    }),
    onKeyDown: oe(t.onKeyDown, (a) => {
      r || ([
        "Enter",
        " "
      ].includes(a.key) && o.onOpenToggle(), a.key === "ArrowDown" && o.onOpenChange(!0), [
        "Enter",
        " ",
        "ArrowDown"
      ].includes(a.key) && a.preventDefault());
    })
  })));
}), uV = (t) => {
  const { __scopeDropdownMenu: e, ...n } = t, r = vi(e);
  return /* @__PURE__ */ B(QF, G({}, r, n));
}, hV = "DropdownMenuContent", fV = /* @__PURE__ */ O((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, i = ly(hV, n), o = vi(n), s = ue(!1);
  return /* @__PURE__ */ B(JF, G({
    id: i.contentId,
    "aria-labelledby": i.triggerId
  }, o, r, {
    ref: e,
    onCloseAutoFocus: oe(t.onCloseAutoFocus, (a) => {
      var c;
      s.current || (c = i.triggerRef.current) === null || c === void 0 || c.focus(), s.current = !1, a.preventDefault();
    }),
    onInteractOutside: oe(t.onInteractOutside, (a) => {
      const c = a.detail.originalEvent, h = c.button === 0 && c.ctrlKey === !0, f = c.button === 2 || h;
      (!i.modal || f) && (s.current = !0);
    }),
    style: {
      ...t.style,
      "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }));
}), dV = /* @__PURE__ */ O((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, i = vi(n);
  return /* @__PURE__ */ B(eV, G({}, i, r, {
    ref: e
  }));
}), gV = /* @__PURE__ */ O((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, i = vi(n);
  return /* @__PURE__ */ B(tV, G({}, i, r, {
    ref: e
  }));
}), pV = /* @__PURE__ */ O((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, i = vi(n);
  return /* @__PURE__ */ B(nV, G({}, i, r, {
    ref: e
  }));
}), mV = /* @__PURE__ */ O((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, i = vi(n);
  return /* @__PURE__ */ B(rV, G({}, i, r, {
    ref: e
  }));
}), vV = /* @__PURE__ */ O((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, i = vi(n);
  return /* @__PURE__ */ B(iV, G({}, i, r, {
    ref: e,
    style: {
      ...t.style,
      "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }));
}), bV = aV, wV = cV, cy = uV, xV = fV, yV = dV, CV = gV, $V = pV, SV = mV, AV = vV, uy = "Checkbox", [kV, Ete] = Tt(uy), [MV, TV] = kV(uy), RV = /* @__PURE__ */ O((t, e) => {
  const { __scopeCheckbox: n, name: r, checked: i, defaultChecked: o, required: s, disabled: a, value: c = "on", onCheckedChange: h, ...f } = t, [d, p] = De(null), v = ke(
    e,
    (k) => p(k)
  ), w = ue(!1), b = d ? !!d.closest("form") : !0, [y = !1, $] = zt({
    prop: i,
    defaultProp: o,
    onChange: h
  }), A = ue(y);
  return Ce(() => {
    const k = d?.form;
    if (k) {
      const T = () => $(A.current);
      return k.addEventListener("reset", T), () => k.removeEventListener("reset", T);
    }
  }, [
    d,
    $
  ]), /* @__PURE__ */ B(MV, {
    scope: n,
    state: y,
    disabled: a
  }, /* @__PURE__ */ B(we.button, G({
    type: "button",
    role: "checkbox",
    "aria-checked": yo(y) ? "mixed" : y,
    "aria-required": s,
    "data-state": hy(y),
    "data-disabled": a ? "" : void 0,
    disabled: a,
    value: c
  }, f, {
    ref: v,
    onKeyDown: oe(t.onKeyDown, (k) => {
      k.key === "Enter" && k.preventDefault();
    }),
    onClick: oe(t.onClick, (k) => {
      $(
        (T) => yo(T) ? !0 : !T
      ), b && (w.current = k.isPropagationStopped(), w.current || k.stopPropagation());
    })
  })), b && /* @__PURE__ */ B(DV, {
    control: d,
    bubbles: !w.current,
    name: r,
    value: c,
    checked: y,
    required: s,
    disabled: a,
    style: {
      transform: "translateX(-100%)"
    }
  }));
}), EV = "CheckboxIndicator", OV = /* @__PURE__ */ O((t, e) => {
  const { __scopeCheckbox: n, forceMount: r, ...i } = t, o = TV(EV, n);
  return /* @__PURE__ */ B(Vt, {
    present: r || yo(o.state) || o.state === !0
  }, /* @__PURE__ */ B(we.span, G({
    "data-state": hy(o.state),
    "data-disabled": o.disabled ? "" : void 0
  }, i, {
    ref: e,
    style: {
      pointerEvents: "none",
      ...t.style
    }
  })));
}), DV = (t) => {
  const { control: e, checked: n, bubbles: r = !0, ...i } = t, o = ue(null), s = Nh(n), a = Mh(e);
  return Ce(() => {
    const c = o.current, h = window.HTMLInputElement.prototype, d = Object.getOwnPropertyDescriptor(h, "checked").set;
    if (s !== n && d) {
      const p = new Event("click", {
        bubbles: r
      });
      c.indeterminate = yo(n), d.call(c, yo(n) ? !1 : n), c.dispatchEvent(p);
    }
  }, [
    s,
    n,
    r
  ]), /* @__PURE__ */ B("input", G({
    type: "checkbox",
    "aria-hidden": !0,
    defaultChecked: yo(n) ? !1 : n
  }, i, {
    tabIndex: -1,
    ref: o,
    style: {
      ...t.style,
      ...a,
      position: "absolute",
      pointerEvents: "none",
      opacity: 0,
      margin: 0
    }
  }));
};
function yo(t) {
  return t === "indeterminate";
}
function hy(t) {
  return yo(t) ? "indeterminate" : t ? "checked" : "unchecked";
}
const IV = RV, _V = OV;
function LV(t, e) {
  return Yw((n, r) => {
    const i = e[n][r];
    return i ?? n;
  }, t);
}
const fy = "ScrollArea", [dy, Ote] = Tt(fy), [BV, Nr] = dy(fy), NV = /* @__PURE__ */ O((t, e) => {
  const { __scopeScrollArea: n, type: r = "hover", dir: i, scrollHideDelay: o = 600, ...s } = t, [a, c] = De(null), [h, f] = De(null), [d, p] = De(null), [v, w] = De(null), [b, y] = De(null), [$, A] = De(0), [k, T] = De(0), [R, _] = De(!1), [D, P] = De(!1), H = ke(
    e,
    (j) => c(j)
  ), z = Fo(i);
  return /* @__PURE__ */ B(BV, {
    scope: n,
    type: r,
    dir: z,
    scrollHideDelay: o,
    scrollArea: a,
    viewport: h,
    onViewportChange: f,
    content: d,
    onContentChange: p,
    scrollbarX: v,
    onScrollbarXChange: w,
    scrollbarXEnabled: R,
    onScrollbarXEnabledChange: _,
    scrollbarY: b,
    onScrollbarYChange: y,
    scrollbarYEnabled: D,
    onScrollbarYEnabledChange: P,
    onCornerWidthChange: A,
    onCornerHeightChange: T
  }, /* @__PURE__ */ B(we.div, G({
    dir: z
  }, s, {
    ref: H,
    style: {
      position: "relative",
      // Pass corner sizes as CSS vars to reduce re-renders of context consumers
      "--radix-scroll-area-corner-width": $ + "px",
      "--radix-scroll-area-corner-height": k + "px",
      ...t.style
    }
  })));
}), FV = "ScrollAreaViewport", VV = /* @__PURE__ */ O((t, e) => {
  const { __scopeScrollArea: n, children: r, ...i } = t, o = Nr(FV, n), s = ue(null), a = ke(e, s, o.onViewportChange);
  return /* @__PURE__ */ B(xh, null, /* @__PURE__ */ B("style", {
    dangerouslySetInnerHTML: {
      __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
    }
  }), /* @__PURE__ */ B(we.div, G({
    "data-radix-scroll-area-viewport": ""
  }, i, {
    ref: a,
    style: {
      /**
      * We don't support `visible` because the intention is to have at least one scrollbar
      * if this component is used and `visible` will behave like `auto` in that case
      * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description
      *
      * We don't handle `auto` because the intention is for the native implementation
      * to be hidden if using this component. We just want to ensure the node is scrollable
      * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
      * the browser from having to work out whether to render native scrollbars or not,
      * we tell it to with the intention of hiding them in CSS.
      */
      overflowX: o.scrollbarXEnabled ? "scroll" : "hidden",
      overflowY: o.scrollbarYEnabled ? "scroll" : "hidden",
      ...t.style
    }
  }), /* @__PURE__ */ B("div", {
    ref: o.onContentChange,
    style: {
      minWidth: "100%",
      display: "table"
    }
  }, r)));
}), bi = "ScrollAreaScrollbar", HV = /* @__PURE__ */ O((t, e) => {
  const { forceMount: n, ...r } = t, i = Nr(bi, t.__scopeScrollArea), { onScrollbarXEnabledChange: o, onScrollbarYEnabledChange: s } = i, a = t.orientation === "horizontal";
  return Ce(() => (a ? o(!0) : s(!0), () => {
    a ? o(!1) : s(!1);
  }), [
    a,
    o,
    s
  ]), i.type === "hover" ? /* @__PURE__ */ B(PV, G({}, r, {
    ref: e,
    forceMount: n
  })) : i.type === "scroll" ? /* @__PURE__ */ B(WV, G({}, r, {
    ref: e,
    forceMount: n
  })) : i.type === "auto" ? /* @__PURE__ */ B(gy, G({}, r, {
    ref: e,
    forceMount: n
  })) : i.type === "always" ? /* @__PURE__ */ B(bp, G({}, r, {
    ref: e
  })) : null;
}), PV = /* @__PURE__ */ O((t, e) => {
  const { forceMount: n, ...r } = t, i = Nr(bi, t.__scopeScrollArea), [o, s] = De(!1);
  return Ce(() => {
    const a = i.scrollArea;
    let c = 0;
    if (a) {
      const h = () => {
        window.clearTimeout(c), s(!0);
      }, f = () => {
        c = window.setTimeout(
          () => s(!1),
          i.scrollHideDelay
        );
      };
      return a.addEventListener("pointerenter", h), a.addEventListener("pointerleave", f), () => {
        window.clearTimeout(c), a.removeEventListener("pointerenter", h), a.removeEventListener("pointerleave", f);
      };
    }
  }, [
    i.scrollArea,
    i.scrollHideDelay
  ]), /* @__PURE__ */ B(Vt, {
    present: n || o
  }, /* @__PURE__ */ B(gy, G({
    "data-state": o ? "visible" : "hidden"
  }, r, {
    ref: e
  })));
}), WV = /* @__PURE__ */ O((t, e) => {
  const { forceMount: n, ...r } = t, i = Nr(bi, t.__scopeScrollArea), o = t.orientation === "horizontal", s = qh(
    () => c("SCROLL_END"),
    100
  ), [a, c] = LV("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return Ce(() => {
    if (a === "idle") {
      const h = window.setTimeout(
        () => c("HIDE"),
        i.scrollHideDelay
      );
      return () => window.clearTimeout(h);
    }
  }, [
    a,
    i.scrollHideDelay,
    c
  ]), Ce(() => {
    const h = i.viewport, f = o ? "scrollLeft" : "scrollTop";
    if (h) {
      let d = h[f];
      const p = () => {
        const v = h[f];
        d !== v && (c("SCROLL"), s()), d = v;
      };
      return h.addEventListener("scroll", p), () => h.removeEventListener("scroll", p);
    }
  }, [
    i.viewport,
    o,
    c,
    s
  ]), /* @__PURE__ */ B(Vt, {
    present: n || a !== "hidden"
  }, /* @__PURE__ */ B(bp, G({
    "data-state": a === "hidden" ? "hidden" : "visible"
  }, r, {
    ref: e,
    onPointerEnter: oe(
      t.onPointerEnter,
      () => c("POINTER_ENTER")
    ),
    onPointerLeave: oe(
      t.onPointerLeave,
      () => c("POINTER_LEAVE")
    )
  })));
}), gy = /* @__PURE__ */ O((t, e) => {
  const n = Nr(bi, t.__scopeScrollArea), { forceMount: r, ...i } = t, [o, s] = De(!1), a = t.orientation === "horizontal", c = qh(() => {
    if (n.viewport) {
      const h = n.viewport.offsetWidth < n.viewport.scrollWidth, f = n.viewport.offsetHeight < n.viewport.scrollHeight;
      s(a ? h : f);
    }
  }, 10);
  return Hu(n.viewport, c), Hu(n.content, c), /* @__PURE__ */ B(Vt, {
    present: r || o
  }, /* @__PURE__ */ B(bp, G({
    "data-state": o ? "visible" : "hidden"
  }, i, {
    ref: e
  })));
}), bp = /* @__PURE__ */ O((t, e) => {
  const { orientation: n = "vertical", ...r } = t, i = Nr(bi, t.__scopeScrollArea), o = ue(null), s = ue(0), [a, c] = De({
    content: 0,
    viewport: 0,
    scrollbar: {
      size: 0,
      paddingStart: 0,
      paddingEnd: 0
    }
  }), h = vy(a.viewport, a.content), f = {
    ...r,
    sizes: a,
    onSizesChange: c,
    hasThumb: h > 0 && h < 1,
    onThumbChange: (p) => o.current = p,
    onThumbPointerUp: () => s.current = 0,
    onThumbPointerDown: (p) => s.current = p
  };
  function d(p, v) {
    return YV(p, s.current, a, v);
  }
  return n === "horizontal" ? /* @__PURE__ */ B(zV, G({}, f, {
    ref: e,
    onThumbPositionChange: () => {
      if (i.viewport && o.current) {
        const p = i.viewport.scrollLeft, v = b5(p, a, i.dir);
        o.current.style.transform = `translate3d(${v}px, 0, 0)`;
      }
    },
    onWheelScroll: (p) => {
      i.viewport && (i.viewport.scrollLeft = p);
    },
    onDragScroll: (p) => {
      i.viewport && (i.viewport.scrollLeft = d(p, i.dir));
    }
  })) : n === "vertical" ? /* @__PURE__ */ B(UV, G({}, f, {
    ref: e,
    onThumbPositionChange: () => {
      if (i.viewport && o.current) {
        const p = i.viewport.scrollTop, v = b5(p, a);
        o.current.style.transform = `translate3d(0, ${v}px, 0)`;
      }
    },
    onWheelScroll: (p) => {
      i.viewport && (i.viewport.scrollTop = p);
    },
    onDragScroll: (p) => {
      i.viewport && (i.viewport.scrollTop = d(p));
    }
  })) : null;
}), zV = /* @__PURE__ */ O((t, e) => {
  const { sizes: n, onSizesChange: r, ...i } = t, o = Nr(bi, t.__scopeScrollArea), [s, a] = De(), c = ue(null), h = ke(e, c, o.onScrollbarXChange);
  return Ce(() => {
    c.current && a(getComputedStyle(c.current));
  }, [
    c
  ]), /* @__PURE__ */ B(my, G({
    "data-orientation": "horizontal"
  }, i, {
    ref: h,
    sizes: n,
    style: {
      bottom: 0,
      left: o.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
      right: o.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
      "--radix-scroll-area-thumb-width": Kh(n) + "px",
      ...t.style
    },
    onThumbPointerDown: (f) => t.onThumbPointerDown(f.x),
    onDragScroll: (f) => t.onDragScroll(f.x),
    onWheelScroll: (f, d) => {
      if (o.viewport) {
        const p = o.viewport.scrollLeft + f.deltaX;
        t.onWheelScroll(p), wy(p, d) && f.preventDefault();
      }
    },
    onResize: () => {
      c.current && o.viewport && s && r({
        content: o.viewport.scrollWidth,
        viewport: o.viewport.offsetWidth,
        scrollbar: {
          size: c.current.clientWidth,
          paddingStart: Vu(s.paddingLeft),
          paddingEnd: Vu(s.paddingRight)
        }
      });
    }
  }));
}), UV = /* @__PURE__ */ O((t, e) => {
  const { sizes: n, onSizesChange: r, ...i } = t, o = Nr(bi, t.__scopeScrollArea), [s, a] = De(), c = ue(null), h = ke(e, c, o.onScrollbarYChange);
  return Ce(() => {
    c.current && a(getComputedStyle(c.current));
  }, [
    c
  ]), /* @__PURE__ */ B(my, G({
    "data-orientation": "vertical"
  }, i, {
    ref: h,
    sizes: n,
    style: {
      top: 0,
      right: o.dir === "ltr" ? 0 : void 0,
      left: o.dir === "rtl" ? 0 : void 0,
      bottom: "var(--radix-scroll-area-corner-height)",
      "--radix-scroll-area-thumb-height": Kh(n) + "px",
      ...t.style
    },
    onThumbPointerDown: (f) => t.onThumbPointerDown(f.y),
    onDragScroll: (f) => t.onDragScroll(f.y),
    onWheelScroll: (f, d) => {
      if (o.viewport) {
        const p = o.viewport.scrollTop + f.deltaY;
        t.onWheelScroll(p), wy(p, d) && f.preventDefault();
      }
    },
    onResize: () => {
      c.current && o.viewport && s && r({
        content: o.viewport.scrollHeight,
        viewport: o.viewport.offsetHeight,
        scrollbar: {
          size: c.current.clientHeight,
          paddingStart: Vu(s.paddingTop),
          paddingEnd: Vu(s.paddingBottom)
        }
      });
    }
  }));
}), [KV, py] = dy(bi), my = /* @__PURE__ */ O((t, e) => {
  const { __scopeScrollArea: n, sizes: r, hasThumb: i, onThumbChange: o, onThumbPointerUp: s, onThumbPointerDown: a, onThumbPositionChange: c, onDragScroll: h, onWheelScroll: f, onResize: d, ...p } = t, v = Nr(bi, n), [w, b] = De(null), y = ke(
    e,
    (H) => b(H)
  ), $ = ue(null), A = ue(""), k = v.viewport, T = r.content - r.viewport, R = Ot(f), _ = Ot(c), D = qh(d, 10);
  function P(H) {
    if ($.current) {
      const z = H.clientX - $.current.left, j = H.clientY - $.current.top;
      h({
        x: z,
        y: j
      });
    }
  }
  return Ce(() => {
    const H = (z) => {
      const j = z.target;
      w?.contains(j) && R(z, T);
    };
    return document.addEventListener("wheel", H, {
      passive: !1
    }), () => document.removeEventListener("wheel", H, {
      passive: !1
    });
  }, [
    k,
    w,
    T,
    R
  ]), Ce(_, [
    r,
    _
  ]), Hu(w, D), Hu(v.content, D), /* @__PURE__ */ B(KV, {
    scope: n,
    scrollbar: w,
    hasThumb: i,
    onThumbChange: Ot(o),
    onThumbPointerUp: Ot(s),
    onThumbPositionChange: _,
    onThumbPointerDown: Ot(a)
  }, /* @__PURE__ */ B(we.div, G({}, p, {
    ref: y,
    style: {
      position: "absolute",
      ...p.style
    },
    onPointerDown: oe(t.onPointerDown, (H) => {
      H.button === 0 && (H.target.setPointerCapture(H.pointerId), $.current = w.getBoundingClientRect(), A.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", v.viewport && (v.viewport.style.scrollBehavior = "auto"), P(H));
    }),
    onPointerMove: oe(t.onPointerMove, P),
    onPointerUp: oe(t.onPointerUp, (H) => {
      const z = H.target;
      z.hasPointerCapture(H.pointerId) && z.releasePointerCapture(H.pointerId), document.body.style.webkitUserSelect = A.current, v.viewport && (v.viewport.style.scrollBehavior = ""), $.current = null;
    })
  })));
}), l1 = "ScrollAreaThumb", qV = /* @__PURE__ */ O((t, e) => {
  const { forceMount: n, ...r } = t, i = py(l1, t.__scopeScrollArea);
  return /* @__PURE__ */ B(Vt, {
    present: n || i.hasThumb
  }, /* @__PURE__ */ B(GV, G({
    ref: e
  }, r)));
}), GV = /* @__PURE__ */ O((t, e) => {
  const { __scopeScrollArea: n, style: r, ...i } = t, o = Nr(l1, n), s = py(l1, n), { onThumbPositionChange: a } = s, c = ke(
    e,
    (d) => s.onThumbChange(d)
  ), h = ue(), f = qh(() => {
    h.current && (h.current(), h.current = void 0);
  }, 100);
  return Ce(() => {
    const d = o.viewport;
    if (d) {
      const p = () => {
        if (f(), !h.current) {
          const v = jV(d, a);
          h.current = v, a();
        }
      };
      return a(), d.addEventListener("scroll", p), () => d.removeEventListener("scroll", p);
    }
  }, [
    o.viewport,
    f,
    a
  ]), /* @__PURE__ */ B(we.div, G({
    "data-state": s.hasThumb ? "visible" : "hidden"
  }, i, {
    ref: c,
    style: {
      width: "var(--radix-scroll-area-thumb-width)",
      height: "var(--radix-scroll-area-thumb-height)",
      ...r
    },
    onPointerDownCapture: oe(t.onPointerDownCapture, (d) => {
      const v = d.target.getBoundingClientRect(), w = d.clientX - v.left, b = d.clientY - v.top;
      s.onThumbPointerDown({
        x: w,
        y: b
      });
    }),
    onPointerUp: oe(t.onPointerUp, s.onThumbPointerUp)
  }));
});
function Vu(t) {
  return t ? parseInt(t, 10) : 0;
}
function vy(t, e) {
  const n = t / e;
  return isNaN(n) ? 0 : n;
}
function Kh(t) {
  const e = vy(t.viewport, t.content), n = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, r = (t.scrollbar.size - n) * e;
  return Math.max(r, 18);
}
function YV(t, e, n, r = "ltr") {
  const i = Kh(n), o = i / 2, s = e || o, a = i - s, c = n.scrollbar.paddingStart + s, h = n.scrollbar.size - n.scrollbar.paddingEnd - a, f = n.content - n.viewport, d = r === "ltr" ? [
    0,
    f
  ] : [
    f * -1,
    0
  ];
  return by([
    c,
    h
  ], d)(t);
}
function b5(t, e, n = "ltr") {
  const r = Kh(e), i = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, o = e.scrollbar.size - i, s = e.content - e.viewport, a = o - r, c = n === "ltr" ? [
    0,
    s
  ] : [
    s * -1,
    0
  ], h = X0(t, c);
  return by([
    0,
    s
  ], [
    0,
    a
  ])(h);
}
function by(t, e) {
  return (n) => {
    if (t[0] === t[1] || e[0] === e[1]) return e[0];
    const r = (e[1] - e[0]) / (t[1] - t[0]);
    return e[0] + r * (n - t[0]);
  };
}
function wy(t, e) {
  return t > 0 && t < e;
}
const jV = (t, e = () => {
}) => {
  let n = {
    left: t.scrollLeft,
    top: t.scrollTop
  }, r = 0;
  return function i() {
    const o = {
      left: t.scrollLeft,
      top: t.scrollTop
    }, s = n.left !== o.left, a = n.top !== o.top;
    (s || a) && e(), n = o, r = window.requestAnimationFrame(i);
  }(), () => window.cancelAnimationFrame(r);
};
function qh(t, e) {
  const n = Ot(t), r = ue(0);
  return Ce(
    () => () => window.clearTimeout(r.current),
    []
  ), rt(() => {
    window.clearTimeout(r.current), r.current = window.setTimeout(n, e);
  }, [
    n,
    e
  ]);
}
function Hu(t, e) {
  const n = Ot(e);
  xt(() => {
    let r = 0;
    if (t) {
      const i = new ResizeObserver(() => {
        cancelAnimationFrame(r), r = window.requestAnimationFrame(n);
      });
      return i.observe(t), () => {
        window.cancelAnimationFrame(r), i.unobserve(t);
      };
    }
  }, [
    t,
    n
  ]);
}
const XV = NV, ZV = VV, QV = HV, JV = qV;
var xy = Oh(), r0 = function() {
}, Gh = C.forwardRef(function(t, e) {
  var n = C.useRef(null), r = C.useState({
    onScrollCapture: r0,
    onWheelCapture: r0,
    onTouchMoveCapture: r0
  }), i = r[0], o = r[1], s = t.forwardProps, a = t.children, c = t.className, h = t.removeScrollBar, f = t.enabled, d = t.shards, p = t.sideCar, v = t.noIsolation, w = t.inert, b = t.allowPinchZoom, y = t.as, $ = y === void 0 ? "div" : y, A = xl(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]), k = p, T = Eh([n, e]), R = lt(lt({}, A), i);
  return C.createElement(
    C.Fragment,
    null,
    f && C.createElement(k, { sideCar: xy, removeScrollBar: h, shards: d, noIsolation: v, inert: w, setCallbacks: o, allowPinchZoom: !!b, lockRef: n }),
    s ? C.cloneElement(C.Children.only(a), lt(lt({}, R), { ref: T })) : C.createElement($, lt({}, R, { className: c, ref: T }), a)
  );
});
Gh.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
Gh.classNames = {
  fullWidth: wo,
  zeroRight: bo
};
var c1 = !1;
if (typeof window < "u")
  try {
    var Hc = Object.defineProperty({}, "passive", {
      get: function() {
        return c1 = !0, !0;
      }
    });
    window.addEventListener("test", Hc, Hc), window.removeEventListener("test", Hc, Hc);
  } catch {
    c1 = !1;
  }
var fs = c1 ? { passive: !1 } : !1, eH = function(t) {
  return t.tagName === "TEXTAREA";
}, yy = function(t, e) {
  var n = window.getComputedStyle(t);
  return (
    // not-not-scrollable
    n[e] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !eH(t) && n[e] === "visible")
  );
}, tH = function(t) {
  return yy(t, "overflowY");
}, nH = function(t) {
  return yy(t, "overflowX");
}, w5 = function(t, e) {
  var n = e;
  do {
    typeof ShadowRoot < "u" && n instanceof ShadowRoot && (n = n.host);
    var r = Cy(t, n);
    if (r) {
      var i = $y(t, n), o = i[1], s = i[2];
      if (o > s)
        return !0;
    }
    n = n.parentNode;
  } while (n && n !== document.body);
  return !1;
}, rH = function(t) {
  var e = t.scrollTop, n = t.scrollHeight, r = t.clientHeight;
  return [
    e,
    n,
    r
  ];
}, iH = function(t) {
  var e = t.scrollLeft, n = t.scrollWidth, r = t.clientWidth;
  return [
    e,
    n,
    r
  ];
}, Cy = function(t, e) {
  return t === "v" ? tH(e) : nH(e);
}, $y = function(t, e) {
  return t === "v" ? rH(e) : iH(e);
}, oH = function(t, e) {
  return t === "h" && e === "rtl" ? -1 : 1;
}, sH = function(t, e, n, r, i) {
  var o = oH(t, window.getComputedStyle(e).direction), s = o * r, a = n.target, c = e.contains(a), h = !1, f = s > 0, d = 0, p = 0;
  do {
    var v = $y(t, a), w = v[0], b = v[1], y = v[2], $ = b - y - o * w;
    (w || $) && Cy(t, a) && (d += $, p += w), a = a.parentNode;
  } while (
    // portaled content
    !c && a !== document.body || // self content
    c && (e.contains(a) || e === a)
  );
  return (f && d === 0 || !f && p === 0) && (h = !0), h;
}, Pc = function(t) {
  return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0];
}, x5 = function(t) {
  return [t.deltaX, t.deltaY];
}, y5 = function(t) {
  return t && "current" in t ? t.current : t;
}, aH = function(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}, lH = function(t) {
  return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`);
}, cH = 0, ds = [];
function uH(t) {
  var e = C.useRef([]), n = C.useRef([0, 0]), r = C.useRef(), i = C.useState(cH++)[0], o = C.useState(function() {
    return yl();
  })[0], s = C.useRef(t);
  C.useEffect(function() {
    s.current = t;
  }, [t]), C.useEffect(function() {
    if (t.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var b = Rh([t.lockRef.current], (t.shards || []).map(y5), !0).filter(Boolean);
      return b.forEach(function(y) {
        return y.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), b.forEach(function(y) {
          return y.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [t.inert, t.lockRef.current, t.shards]);
  var a = C.useCallback(function(b, y) {
    if ("touches" in b && b.touches.length === 2)
      return !s.current.allowPinchZoom;
    var $ = Pc(b), A = n.current, k = "deltaX" in b ? b.deltaX : A[0] - $[0], T = "deltaY" in b ? b.deltaY : A[1] - $[1], R, _ = b.target, D = Math.abs(k) > Math.abs(T) ? "h" : "v";
    if ("touches" in b && D === "h" && _.type === "range")
      return !1;
    var P = w5(D, _);
    if (!P)
      return !0;
    if (P ? R = D : (R = D === "v" ? "h" : "v", P = w5(D, _)), !P)
      return !1;
    if (!r.current && "changedTouches" in b && (k || T) && (r.current = R), !R)
      return !0;
    var H = r.current || R;
    return sH(H, y, b, H === "h" ? k : T);
  }, []), c = C.useCallback(function(b) {
    var y = b;
    if (!(!ds.length || ds[ds.length - 1] !== o)) {
      var $ = "deltaY" in y ? x5(y) : Pc(y), A = e.current.filter(function(R) {
        return R.name === y.type && R.target === y.target && aH(R.delta, $);
      })[0];
      if (A && A.should) {
        y.cancelable && y.preventDefault();
        return;
      }
      if (!A) {
        var k = (s.current.shards || []).map(y5).filter(Boolean).filter(function(R) {
          return R.contains(y.target);
        }), T = k.length > 0 ? a(y, k[0]) : !s.current.noIsolation;
        T && y.cancelable && y.preventDefault();
      }
    }
  }, []), h = C.useCallback(function(b, y, $, A) {
    var k = { name: b, delta: y, target: $, should: A };
    e.current.push(k), setTimeout(function() {
      e.current = e.current.filter(function(T) {
        return T !== k;
      });
    }, 1);
  }, []), f = C.useCallback(function(b) {
    n.current = Pc(b), r.current = void 0;
  }, []), d = C.useCallback(function(b) {
    h(b.type, x5(b), b.target, a(b, t.lockRef.current));
  }, []), p = C.useCallback(function(b) {
    h(b.type, Pc(b), b.target, a(b, t.lockRef.current));
  }, []);
  C.useEffect(function() {
    return ds.push(o), t.setCallbacks({
      onScrollCapture: d,
      onWheelCapture: d,
      onTouchMoveCapture: p
    }), document.addEventListener("wheel", c, fs), document.addEventListener("touchmove", c, fs), document.addEventListener("touchstart", f, fs), function() {
      ds = ds.filter(function(b) {
        return b !== o;
      }), document.removeEventListener("wheel", c, fs), document.removeEventListener("touchmove", c, fs), document.removeEventListener("touchstart", f, fs);
    };
  }, []);
  var v = t.removeScrollBar, w = t.inert;
  return C.createElement(
    C.Fragment,
    null,
    w ? C.createElement(o, { styles: lH(i) }) : null,
    v ? C.createElement(_h, { gapMode: "margin" }) : null
  );
}
const hH = Dh(xy, uH);
var Sy = C.forwardRef(function(t, e) {
  return C.createElement(Gh, lt({}, t, { ref: e, sideCar: hH }));
});
Sy.classNames = Gh.classNames;
const Ay = "Dialog", [ky, My] = Tt(Ay), [fH, gr] = ky(Ay), dH = (t) => {
  const { __scopeDialog: e, children: n, open: r, defaultOpen: i, onOpenChange: o, modal: s = !0 } = t, a = ue(null), c = ue(null), [h = !1, f] = zt({
    prop: r,
    defaultProp: i,
    onChange: o
  });
  return /* @__PURE__ */ B(fH, {
    scope: e,
    triggerRef: a,
    contentRef: c,
    contentId: Ut(),
    titleId: Ut(),
    descriptionId: Ut(),
    open: h,
    onOpenChange: f,
    onOpenToggle: rt(
      () => f(
        (d) => !d
      ),
      [
        f
      ]
    ),
    modal: s
  }, n);
}, gH = "DialogTrigger", pH = /* @__PURE__ */ O((t, e) => {
  const { __scopeDialog: n, ...r } = t, i = gr(gH, n), o = ke(e, i.triggerRef);
  return /* @__PURE__ */ B(we.button, G({
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": i.open,
    "aria-controls": i.contentId,
    "data-state": wp(i.open)
  }, r, {
    ref: o,
    onClick: oe(t.onClick, i.onOpenToggle)
  }));
}), Ty = "DialogPortal", [mH, Ry] = ky(Ty, {
  forceMount: void 0
}), vH = (t) => {
  const { __scopeDialog: e, forceMount: n, children: r, container: i } = t, o = gr(Ty, e);
  return /* @__PURE__ */ B(mH, {
    scope: e,
    forceMount: n
  }, vo.map(
    r,
    (s) => /* @__PURE__ */ B(Vt, {
      present: n || o.open
    }, /* @__PURE__ */ B(Zs, {
      asChild: !0,
      container: i
    }, s))
  ));
}, u1 = "DialogOverlay", bH = /* @__PURE__ */ O((t, e) => {
  const n = Ry(u1, t.__scopeDialog), { forceMount: r = n.forceMount, ...i } = t, o = gr(u1, t.__scopeDialog);
  return o.modal ? /* @__PURE__ */ B(Vt, {
    present: r || o.open
  }, /* @__PURE__ */ B(wH, G({}, i, {
    ref: e
  }))) : null;
}), wH = /* @__PURE__ */ O((t, e) => {
  const { __scopeDialog: n, ...r } = t, i = gr(u1, n);
  return (
    // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
    // ie. when `Overlay` and `Content` are siblings
    /* @__PURE__ */ B(Sy, {
      as: Dr,
      allowPinchZoom: !0,
      shards: [
        i.contentRef
      ]
    }, /* @__PURE__ */ B(we.div, G({
      "data-state": wp(i.open)
    }, r, {
      ref: e,
      style: {
        pointerEvents: "auto",
        ...r.style
      }
    })))
  );
}), Bs = "DialogContent", xH = /* @__PURE__ */ O((t, e) => {
  const n = Ry(Bs, t.__scopeDialog), { forceMount: r = n.forceMount, ...i } = t, o = gr(Bs, t.__scopeDialog);
  return /* @__PURE__ */ B(Vt, {
    present: r || o.open
  }, o.modal ? /* @__PURE__ */ B(yH, G({}, i, {
    ref: e
  })) : /* @__PURE__ */ B(CH, G({}, i, {
    ref: e
  })));
}), yH = /* @__PURE__ */ O((t, e) => {
  const n = gr(Bs, t.__scopeDialog), r = ue(null), i = ke(e, n.contentRef, r);
  return Ce(() => {
    const o = r.current;
    if (o) return gp(o);
  }, []), /* @__PURE__ */ B(Ey, G({}, t, {
    ref: i,
    trapFocus: n.open,
    disableOutsidePointerEvents: !0,
    onCloseAutoFocus: oe(t.onCloseAutoFocus, (o) => {
      var s;
      o.preventDefault(), (s = n.triggerRef.current) === null || s === void 0 || s.focus();
    }),
    onPointerDownOutside: oe(t.onPointerDownOutside, (o) => {
      const s = o.detail.originalEvent, a = s.button === 0 && s.ctrlKey === !0;
      (s.button === 2 || a) && o.preventDefault();
    }),
    onFocusOutside: oe(
      t.onFocusOutside,
      (o) => o.preventDefault()
    )
  }));
}), CH = /* @__PURE__ */ O((t, e) => {
  const n = gr(Bs, t.__scopeDialog), r = ue(!1), i = ue(!1);
  return /* @__PURE__ */ B(Ey, G({}, t, {
    ref: e,
    trapFocus: !1,
    disableOutsidePointerEvents: !1,
    onCloseAutoFocus: (o) => {
      var s;
      if ((s = t.onCloseAutoFocus) === null || s === void 0 || s.call(t, o), !o.defaultPrevented) {
        var a;
        r.current || (a = n.triggerRef.current) === null || a === void 0 || a.focus(), o.preventDefault();
      }
      r.current = !1, i.current = !1;
    },
    onInteractOutside: (o) => {
      var s, a;
      (s = t.onInteractOutside) === null || s === void 0 || s.call(t, o), o.defaultPrevented || (r.current = !0, o.detail.originalEvent.type === "pointerdown" && (i.current = !0));
      const c = o.target;
      ((a = n.triggerRef.current) === null || a === void 0 ? void 0 : a.contains(c)) && o.preventDefault(), o.detail.originalEvent.type === "focusin" && i.current && o.preventDefault();
    }
  }));
}), Ey = /* @__PURE__ */ O((t, e) => {
  const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: o, ...s } = t, a = gr(Bs, n), c = ue(null), h = ke(e, c);
  return Qs(), /* @__PURE__ */ B(xh, null, /* @__PURE__ */ B(Js, {
    asChild: !0,
    loop: !0,
    trapped: r,
    onMountAutoFocus: i,
    onUnmountAutoFocus: o
  }, /* @__PURE__ */ B(No, G({
    role: "dialog",
    id: a.contentId,
    "aria-describedby": a.descriptionId,
    "aria-labelledby": a.titleId,
    "data-state": wp(a.open)
  }, s, {
    ref: h,
    onDismiss: () => a.onOpenChange(!1)
  }))), !1);
}), Oy = "DialogTitle", $H = /* @__PURE__ */ O((t, e) => {
  const { __scopeDialog: n, ...r } = t, i = gr(Oy, n);
  return /* @__PURE__ */ B(we.h2, G({
    id: i.titleId
  }, r, {
    ref: e
  }));
}), SH = "DialogDescription", AH = /* @__PURE__ */ O((t, e) => {
  const { __scopeDialog: n, ...r } = t, i = gr(SH, n);
  return /* @__PURE__ */ B(we.p, G({
    id: i.descriptionId
  }, r, {
    ref: e
  }));
}), kH = "DialogClose", MH = /* @__PURE__ */ O((t, e) => {
  const { __scopeDialog: n, ...r } = t, i = gr(kH, n);
  return /* @__PURE__ */ B(we.button, G({
    type: "button"
  }, r, {
    ref: e,
    onClick: oe(
      t.onClick,
      () => i.onOpenChange(!1)
    )
  }));
});
function wp(t) {
  return t ? "open" : "closed";
}
const TH = "DialogTitleWarning", [RH, Dte] = $g(TH, {
  contentName: Bs,
  titleName: Oy,
  docsSlug: "dialog"
}), Dy = dH, Iy = pH, _y = vH, Ly = bH, By = xH, Ny = $H, EH = AH, xp = MH, OH = "AlertDialog", [DH, Ite] = Tt(OH, [
  My
]), wi = My(), IH = (t) => {
  const { __scopeAlertDialog: e, ...n } = t, r = wi(e);
  return /* @__PURE__ */ B(Dy, G({}, r, n, {
    modal: !0
  }));
}, _H = /* @__PURE__ */ O((t, e) => {
  const { __scopeAlertDialog: n, ...r } = t, i = wi(n);
  return /* @__PURE__ */ B(Iy, G({}, i, r, {
    ref: e
  }));
}), LH = (t) => {
  const { __scopeAlertDialog: e, ...n } = t, r = wi(e);
  return /* @__PURE__ */ B(_y, G({}, r, n));
}, BH = /* @__PURE__ */ O((t, e) => {
  const { __scopeAlertDialog: n, ...r } = t, i = wi(n);
  return /* @__PURE__ */ B(Ly, G({}, i, r, {
    ref: e
  }));
}), Fy = "AlertDialogContent", [NH, FH] = DH(Fy), VH = /* @__PURE__ */ O((t, e) => {
  const { __scopeAlertDialog: n, children: r, ...i } = t, o = wi(n), s = ue(null), a = ke(e, s), c = ue(null);
  return /* @__PURE__ */ B(RH, {
    contentName: Fy,
    titleName: HH,
    docsSlug: "alert-dialog"
  }, /* @__PURE__ */ B(NH, {
    scope: n,
    cancelRef: c
  }, /* @__PURE__ */ B(By, G({
    role: "alertdialog"
  }, o, i, {
    ref: a,
    onOpenAutoFocus: oe(i.onOpenAutoFocus, (h) => {
      var f;
      h.preventDefault(), (f = c.current) === null || f === void 0 || f.focus({
        preventScroll: !0
      });
    }),
    onPointerDownOutside: (h) => h.preventDefault(),
    onInteractOutside: (h) => h.preventDefault()
  }), /* @__PURE__ */ B(Sg, null, r), !1)));
}), HH = "AlertDialogTitle", PH = /* @__PURE__ */ O((t, e) => {
  const { __scopeAlertDialog: n, ...r } = t, i = wi(n);
  return /* @__PURE__ */ B(Ny, G({}, i, r, {
    ref: e
  }));
}), WH = /* @__PURE__ */ O((t, e) => {
  const { __scopeAlertDialog: n, ...r } = t, i = wi(n);
  return /* @__PURE__ */ B(EH, G({}, i, r, {
    ref: e
  }));
}), zH = /* @__PURE__ */ O((t, e) => {
  const { __scopeAlertDialog: n, ...r } = t, i = wi(n);
  return /* @__PURE__ */ B(xp, G({}, i, r, {
    ref: e
  }));
}), UH = "AlertDialogCancel", KH = /* @__PURE__ */ O((t, e) => {
  const { __scopeAlertDialog: n, ...r } = t, { cancelRef: i } = FH(UH, n), o = wi(n), s = ke(e, i);
  return /* @__PURE__ */ B(xp, G({}, o, r, {
    ref: s
  }));
}), qH = IH, GH = _H, YH = LH, jH = BH, XH = VH, ZH = zH, QH = KH, JH = PH, eP = WH;
var vu = typeof document < "u" ? yh : Ce;
function Pu(t, e) {
  if (t === e)
    return !0;
  if (typeof t != typeof e)
    return !1;
  if (typeof t == "function" && t.toString() === e.toString())
    return !0;
  let n, r, i;
  if (t && e && typeof t == "object") {
    if (Array.isArray(t)) {
      if (n = t.length, n !== e.length) return !1;
      for (r = n; r-- !== 0; )
        if (!Pu(t[r], e[r]))
          return !1;
      return !0;
    }
    if (i = Object.keys(t), n = i.length, n !== Object.keys(e).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(e, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const o = i[r];
      if (!(o === "_owner" && t.$$typeof) && !Pu(t[o], e[o]))
        return !1;
    }
    return !0;
  }
  return t !== t && e !== e;
}
function Vy(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function C5(t, e) {
  const n = Vy(t);
  return Math.round(e * n) / n;
}
function $5(t) {
  const e = C.useRef(t);
  return vu(() => {
    e.current = t;
  }), e;
}
function tP(t) {
  t === void 0 && (t = {});
  const {
    placement: e = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: i,
    elements: {
      reference: o,
      floating: s
    } = {},
    transform: a = !0,
    whileElementsMounted: c,
    open: h
  } = t, [f, d] = C.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: e,
    middlewareData: {},
    isPositioned: !1
  }), [p, v] = C.useState(r);
  Pu(p, r) || v(r);
  const [w, b] = C.useState(null), [y, $] = C.useState(null), A = C.useCallback((ie) => {
    ie !== _.current && (_.current = ie, b(ie));
  }, []), k = C.useCallback((ie) => {
    ie !== D.current && (D.current = ie, $(ie));
  }, []), T = o || w, R = s || y, _ = C.useRef(null), D = C.useRef(null), P = C.useRef(f), H = c != null, z = $5(c), j = $5(i), K = C.useCallback(() => {
    if (!_.current || !D.current)
      return;
    const ie = {
      placement: e,
      strategy: n,
      middleware: p
    };
    j.current && (ie.platform = j.current), O3(_.current, D.current, ie).then((se) => {
      const X = {
        ...se,
        isPositioned: !0
      };
      te.current && !Pu(P.current, X) && (P.current = X, Ys.flushSync(() => {
        d(X);
      }));
    });
  }, [p, e, n, j]);
  vu(() => {
    h === !1 && P.current.isPositioned && (P.current.isPositioned = !1, d((ie) => ({
      ...ie,
      isPositioned: !1
    })));
  }, [h]);
  const te = C.useRef(!1);
  vu(() => (te.current = !0, () => {
    te.current = !1;
  }), []), vu(() => {
    if (T && (_.current = T), R && (D.current = R), T && R) {
      if (z.current)
        return z.current(T, R, K);
      K();
    }
  }, [T, R, K, z, H]);
  const ee = C.useMemo(() => ({
    reference: _,
    floating: D,
    setReference: A,
    setFloating: k
  }), [A, k]), re = C.useMemo(() => ({
    reference: T,
    floating: R
  }), [T, R]), de = C.useMemo(() => {
    const ie = {
      position: n,
      left: 0,
      top: 0
    };
    if (!re.floating)
      return ie;
    const se = C5(re.floating, f.x), X = C5(re.floating, f.y);
    return a ? {
      ...ie,
      transform: "translate(" + se + "px, " + X + "px)",
      ...Vy(re.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: se,
      top: X
    };
  }, [n, a, re.floating, f.x, f.y]);
  return C.useMemo(() => ({
    ...f,
    update: K,
    refs: ee,
    elements: re,
    floatingStyles: de
  }), [f, K, ee, re, de]);
}
const nP = (t, e) => ({
  ...T3(t),
  options: [t, e]
}), rP = (t, e) => ({
  ...R3(t),
  options: [t, e]
}), iP = (t, e) => ({
  ...E3(t),
  options: [t, e]
}), Hy = 1024;
let oP = 0, i0 = class {
  constructor(e, n) {
    this.from = e, this.to = n;
  }
};
class Ge {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = oP++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = Sn.match(e)), (n) => {
      let r = e(n);
      return r === void 0 ? null : [this, r];
    };
  }
}
Ge.closedBy = new Ge({ deserialize: (t) => t.split(" ") });
Ge.openedBy = new Ge({ deserialize: (t) => t.split(" ") });
Ge.group = new Ge({ deserialize: (t) => t.split(" ") });
Ge.isolate = new Ge({ deserialize: (t) => {
  if (t && t != "rtl" && t != "ltr" && t != "auto")
    throw new RangeError("Invalid value for isolate: " + t);
  return t || "auto";
} });
Ge.contextHash = new Ge({ perNode: !0 });
Ge.lookAhead = new Ge({ perNode: !0 });
Ge.mounted = new Ge({ perNode: !0 });
class Wu {
  constructor(e, n, r) {
    this.tree = e, this.overlay = n, this.parser = r;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[Ge.mounted.id];
  }
}
const sP = /* @__PURE__ */ Object.create(null);
class Sn {
  /**
  @internal
  */
  constructor(e, n, r, i = 0) {
    this.name = e, this.props = n, this.id = r, this.flags = i;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let n = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : sP, r = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), i = new Sn(e.name || "", n, e.id, r);
    if (e.props) {
      for (let o of e.props)
        if (Array.isArray(o) || (o = o(i)), o) {
          if (o[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          n[o[0].id] = o[1];
        }
    }
    return i;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let n = this.prop(Ge.group);
      return n ? n.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let r in e)
      for (let i of r.split(" "))
        n[i] = e[r];
    return (r) => {
      for (let i = r.prop(Ge.group), o = -1; o < (i ? i.length : 0); o++) {
        let s = n[o < 0 ? r.name : i[o]];
        if (s)
          return s;
      }
    };
  }
}
Sn.none = new Sn(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class yp {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].id != n)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let n = [];
    for (let r of this.types) {
      let i = null;
      for (let o of e) {
        let s = o(r);
        s && (i || (i = Object.assign({}, r.props)), i[s[0].id] = s[1]);
      }
      n.push(i ? new Sn(r.name, i, r.id, r.flags) : r);
    }
    return new yp(n);
  }
}
const Wc = /* @__PURE__ */ new WeakMap(), S5 = /* @__PURE__ */ new WeakMap();
var Pt;
(function(t) {
  t[t.ExcludeBuffers = 1] = "ExcludeBuffers", t[t.IncludeAnonymous = 2] = "IncludeAnonymous", t[t.IgnoreMounts = 4] = "IgnoreMounts", t[t.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Pt || (Pt = {}));
class Dt {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, n, r, i, o) {
    if (this.type = e, this.children = n, this.positions = r, this.length = i, this.props = null, o && o.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [s, a] of o)
        this.props[typeof s == "number" ? s : s.id] = a;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = Wu.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let n = "";
    for (let r of this.children) {
      let i = r.toString();
      i && (n && (n += ","), n += i);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (n.length ? "(" + n + ")" : "") : n;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new f1(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, n = 0, r = 0) {
    let i = Wc.get(this) || this.topNode, o = new f1(i);
    return o.moveTo(e, n), Wc.set(this, o._tree), o;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new Xn(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, n = 0) {
    let r = Za(Wc.get(this) || this.topNode, e, n, !1);
    return Wc.set(this, r), r;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, n = 0) {
    let r = Za(S5.get(this) || this.topNode, e, n, !0);
    return S5.set(this, r), r;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, n = 0) {
    return cP(this, e, n);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: n, leave: r, from: i = 0, to: o = this.length } = e, s = e.mode || 0, a = (s & Pt.IncludeAnonymous) > 0;
    for (let c = this.cursor(s | Pt.IncludeAnonymous); ; ) {
      let h = !1;
      if (c.from <= o && c.to >= i && (!a && c.type.isAnonymous || n(c) !== !1)) {
        if (c.firstChild())
          continue;
        h = !0;
      }
      for (; h && r && (a || !c.type.isAnonymous) && r(c), !c.nextSibling(); ) {
        if (!c.parent())
          return;
        h = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let n in this.props)
        e.push([+n, this.props[n]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : Sp(Sn.none, this.children, this.positions, 0, this.children.length, 0, this.length, (n, r, i) => new Dt(this.type, n, r, i, this.propValues), e.makeTree || ((n, r, i) => new Dt(Sn.none, n, r, i)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return uP(e);
  }
}
Dt.empty = new Dt(Sn.none, [], [], 0);
class Cp {
  constructor(e, n) {
    this.buffer = e, this.index = n;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new Cp(this.buffer, this.index);
  }
}
class zi {
  /**
  Create a tree buffer.
  */
  constructor(e, n, r) {
    this.buffer = e, this.length = n, this.set = r;
  }
  /**
  @internal
  */
  get type() {
    return Sn.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let n = 0; n < this.buffer.length; )
      e.push(this.childString(n)), n = this.buffer[n + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let n = this.buffer[e], r = this.buffer[e + 3], i = this.set.types[n], o = i.name;
    if (/\W/.test(o) && !i.isError && (o = JSON.stringify(o)), e += 4, r == e)
      return o;
    let s = [];
    for (; e < r; )
      s.push(this.childString(e)), e = this.buffer[e + 3];
    return o + "(" + s.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, n, r, i, o) {
    let { buffer: s } = this, a = -1;
    for (let c = e; c != n && !(Py(o, i, s[c + 1], s[c + 2]) && (a = c, r > 0)); c = s[c + 3])
      ;
    return a;
  }
  /**
  @internal
  */
  slice(e, n, r) {
    let i = this.buffer, o = new Uint16Array(n - e), s = 0;
    for (let a = e, c = 0; a < n; ) {
      o[c++] = i[a++], o[c++] = i[a++] - r;
      let h = o[c++] = i[a++] - r;
      o[c++] = i[a++] - e, s = Math.max(s, h);
    }
    return new zi(o, s, this.set);
  }
}
function Py(t, e, n, r) {
  switch (t) {
    case -2:
      return n < e;
    case -1:
      return r >= e && n < e;
    case 0:
      return n < e && r > e;
    case 1:
      return n <= e && r > e;
    case 2:
      return r > e;
    case 4:
      return !0;
  }
}
function Za(t, e, n, r) {
  for (var i; t.from == t.to || (n < 1 ? t.from >= e : t.from > e) || (n > -1 ? t.to <= e : t.to < e); ) {
    let s = !r && t instanceof Xn && t.index < 0 ? null : t.parent;
    if (!s)
      return t;
    t = s;
  }
  let o = r ? 0 : Pt.IgnoreOverlays;
  if (r)
    for (let s = t, a = s.parent; a; s = a, a = s.parent)
      s instanceof Xn && s.index < 0 && ((i = a.enter(e, n, o)) === null || i === void 0 ? void 0 : i.from) != s.from && (t = a);
  for (; ; ) {
    let s = t.enter(e, n, o);
    if (!s)
      return t;
    t = s;
  }
}
class Wy {
  cursor(e = 0) {
    return new f1(this, e);
  }
  getChild(e, n = null, r = null) {
    let i = A5(this, e, n, r);
    return i.length ? i[0] : null;
  }
  getChildren(e, n = null, r = null) {
    return A5(this, e, n, r);
  }
  resolve(e, n = 0) {
    return Za(this, e, n, !1);
  }
  resolveInner(e, n = 0) {
    return Za(this, e, n, !0);
  }
  matchContext(e) {
    return h1(this.parent, e);
  }
  enterUnfinishedNodesBefore(e) {
    let n = this.childBefore(e), r = this;
    for (; n; ) {
      let i = n.lastChild;
      if (!i || i.to != n.to)
        break;
      i.type.isError && i.from == i.to ? (r = n, n = i.prevSibling) : n = i;
    }
    return r;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class Xn extends Wy {
  constructor(e, n, r, i) {
    super(), this._tree = e, this.from = n, this.index = r, this._parent = i;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, n, r, i, o = 0) {
    for (let s = this; ; ) {
      for (let { children: a, positions: c } = s._tree, h = n > 0 ? a.length : -1; e != h; e += n) {
        let f = a[e], d = c[e] + s.from;
        if (Py(i, r, d, d + f.length)) {
          if (f instanceof zi) {
            if (o & Pt.ExcludeBuffers)
              continue;
            let p = f.findChild(0, f.buffer.length, n, r - d, i);
            if (p > -1)
              return new Li(new aP(s, f, e, d), null, p);
          } else if (o & Pt.IncludeAnonymous || !f.type.isAnonymous || $p(f)) {
            let p;
            if (!(o & Pt.IgnoreMounts) && (p = Wu.get(f)) && !p.overlay)
              return new Xn(p.tree, d, e, s);
            let v = new Xn(f, d, e, s);
            return o & Pt.IncludeAnonymous || !v.type.isAnonymous ? v : v.nextChild(n < 0 ? f.children.length - 1 : 0, n, r, i);
          }
        }
      }
      if (o & Pt.IncludeAnonymous || !s.type.isAnonymous || (s.index >= 0 ? e = s.index + n : e = n < 0 ? -1 : s._parent._tree.children.length, s = s._parent, !s))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, n, r = 0) {
    let i;
    if (!(r & Pt.IgnoreOverlays) && (i = Wu.get(this._tree)) && i.overlay) {
      let o = e - this.from;
      for (let { from: s, to: a } of i.overlay)
        if ((n > 0 ? s <= o : s < o) && (n < 0 ? a >= o : a > o))
          return new Xn(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, n, r);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function A5(t, e, n, r) {
  let i = t.cursor(), o = [];
  if (!i.firstChild())
    return o;
  if (n != null) {
    for (let s = !1; !s; )
      if (s = i.type.is(n), !i.nextSibling())
        return o;
  }
  for (; ; ) {
    if (r != null && i.type.is(r))
      return o;
    if (i.type.is(e) && o.push(i.node), !i.nextSibling())
      return r == null ? o : [];
  }
}
function h1(t, e, n = e.length - 1) {
  for (let r = t; n >= 0; r = r.parent) {
    if (!r)
      return !1;
    if (!r.type.isAnonymous) {
      if (e[n] && e[n] != r.name)
        return !1;
      n--;
    }
  }
  return !0;
}
class aP {
  constructor(e, n, r, i) {
    this.parent = e, this.buffer = n, this.index = r, this.start = i;
  }
}
class Li extends Wy {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, n, r) {
    super(), this.context = e, this._parent = n, this.index = r, this.type = e.buffer.set.types[e.buffer.buffer[r]];
  }
  child(e, n, r) {
    let { buffer: i } = this.context, o = i.findChild(this.index + 4, i.buffer[this.index + 3], e, n - this.context.start, r);
    return o < 0 ? null : new Li(this.context, this, o);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, n, r = 0) {
    if (r & Pt.ExcludeBuffers)
      return null;
    let { buffer: i } = this.context, o = i.findChild(this.index + 4, i.buffer[this.index + 3], n > 0 ? 1 : -1, e - this.context.start, n);
    return o < 0 ? null : new Li(this.context, this, o);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, n = e.buffer[this.index + 3];
    return n < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Li(this.context, this._parent, n) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, n = this._parent ? this._parent.index + 4 : 0;
    return this.index == n ? this.externalSibling(-1) : new Li(this.context, this._parent, e.findChild(
      n,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], n = [], { buffer: r } = this.context, i = this.index + 4, o = r.buffer[this.index + 3];
    if (o > i) {
      let s = r.buffer[this.index + 1];
      e.push(r.slice(i, o, s)), n.push(0);
    }
    return new Dt(this.type, e, n, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function zy(t) {
  if (!t.length)
    return null;
  let e = 0, n = t[0];
  for (let o = 1; o < t.length; o++) {
    let s = t[o];
    (s.from > n.from || s.to < n.to) && (n = s, e = o);
  }
  let r = n instanceof Xn && n.index < 0 ? null : n.parent, i = t.slice();
  return r ? i[e] = r : i.splice(e, 1), new lP(i, n);
}
class lP {
  constructor(e, n) {
    this.heads = e, this.node = n;
  }
  get next() {
    return zy(this.heads);
  }
}
function cP(t, e, n) {
  let r = t.resolveInner(e, n), i = null;
  for (let o = r instanceof Xn ? r : r.context.parent; o; o = o.parent)
    if (o.index < 0) {
      let s = o.parent;
      (i || (i = [r])).push(s.resolve(e, n)), o = s;
    } else {
      let s = Wu.get(o.tree);
      if (s && s.overlay && s.overlay[0].from <= e && s.overlay[s.overlay.length - 1].to >= e) {
        let a = new Xn(s.tree, s.overlay[0].from + o.from, -1, o);
        (i || (i = [r])).push(Za(a, e, n, !1));
      }
    }
  return i ? zy(i) : r;
}
class f1 {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, n = 0) {
    if (this.mode = n, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Xn)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let r = e._parent; r; r = r._parent)
        this.stack.unshift(r.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, n) {
    this.index = e;
    let { start: r, buffer: i } = this.buffer;
    return this.type = n || i.set.types[i.buffer[e]], this.from = r + i.buffer[e + 1], this.to = r + i.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof Xn ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, n, r) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, n, r, this.mode));
    let { buffer: i } = this.buffer, o = i.findChild(this.index + 4, i.buffer[this.index + 3], e, n - this.buffer.start, r);
    return o < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(o));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, n, r = this.mode) {
    return this.buffer ? r & Pt.ExcludeBuffers ? !1 : this.enterChild(1, e, n) : this.yield(this._tree.enter(e, n, r));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Pt.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Pt.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: n } = this.buffer, r = this.stack.length - 1;
    if (e < 0) {
      let i = r < 0 ? 0 : this.stack[r] + 4;
      if (this.index != i)
        return this.yieldBuf(n.findChild(
          i,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let i = n.buffer[this.index + 3];
      if (i < (r < 0 ? n.buffer.length : n.buffer[this.stack[r] + 3]))
        return this.yieldBuf(i);
    }
    return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let n, r, { buffer: i } = this;
    if (i) {
      if (e > 0) {
        if (this.index < i.buffer.buffer.length)
          return !1;
      } else
        for (let o = 0; o < this.index; o++)
          if (i.buffer.buffer[o + 3] < this.index)
            return !1;
      ({ index: n, parent: r } = i);
    } else
      ({ index: n, _parent: r } = this._tree);
    for (; r; { index: n, _parent: r } = r)
      if (n > -1)
        for (let o = n + e, s = e < 0 ? -1 : r._tree.children.length; o != s; o += e) {
          let a = r._tree.children[o];
          if (this.mode & Pt.IncludeAnonymous || a instanceof zi || !a.type.isAnonymous || $p(a))
            return !1;
        }
    return !0;
  }
  move(e, n) {
    if (n && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, n = 0) {
    for (; (this.from == this.to || (n < 1 ? this.from >= e : this.from > e) || (n > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, n); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, n = null, r = 0;
    if (e && e.context == this.buffer)
      e: for (let i = this.index, o = this.stack.length; o >= 0; ) {
        for (let s = e; s; s = s._parent)
          if (s.index == i) {
            if (i == this.index)
              return s;
            n = s, r = o + 1;
            break e;
          }
        i = this.stack[--o];
      }
    for (let i = r; i < this.stack.length; i++)
      n = new Li(this.buffer, n, this.stack[i]);
    return this.bufferNode = new Li(this.buffer, n, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, n) {
    for (let r = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          r++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; ; ) {
        if (i && n && n(this), i = this.type.isAnonymous, !r)
          return;
        if (this.nextSibling())
          break;
        this.parent(), r--, i = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return h1(this.node.parent, e);
    let { buffer: n } = this.buffer, { types: r } = n.set;
    for (let i = e.length - 1, o = this.stack.length - 1; i >= 0; o--) {
      if (o < 0)
        return h1(this._tree, e, i);
      let s = r[n.buffer[this.stack[o]]];
      if (!s.isAnonymous) {
        if (e[i] && e[i] != s.name)
          return !1;
        i--;
      }
    }
    return !0;
  }
}
function $p(t) {
  return t.children.some((e) => e instanceof zi || !e.type.isAnonymous || $p(e));
}
function uP(t) {
  var e;
  let { buffer: n, nodeSet: r, maxBufferLength: i = Hy, reused: o = [], minRepeatType: s = r.types.length } = t, a = Array.isArray(n) ? new Cp(n, n.length) : n, c = r.types, h = 0, f = 0;
  function d(R, _, D, P, H, z) {
    let { id: j, start: K, end: te, size: ee } = a, re = f, de = h;
    for (; ee < 0; )
      if (a.next(), ee == -1) {
        let be = o[j];
        D.push(be), P.push(K - R);
        return;
      } else if (ee == -3) {
        h = j;
        return;
      } else if (ee == -4) {
        f = j;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${ee}`);
    let ie = c[j], se, X, ce = K - R;
    if (te - K <= i && (X = y(a.pos - _, H))) {
      let be = new Uint16Array(X.size - X.skip), Le = a.pos - X.size, Ae = be.length;
      for (; a.pos > Le; )
        Ae = $(X.start, be, Ae);
      se = new zi(be, te - X.start, r), ce = X.start - R;
    } else {
      let be = a.pos - ee;
      a.next();
      let Le = [], Ae = [], qe = j >= s ? j : -1, He = 0, Ze = te;
      for (; a.pos > be; )
        qe >= 0 && a.id == qe && a.size >= 0 ? (a.end <= Ze - i && (w(Le, Ae, K, He, a.end, Ze, qe, re, de), He = Le.length, Ze = a.end), a.next()) : z > 2500 ? p(K, be, Le, Ae) : d(K, be, Le, Ae, qe, z + 1);
      if (qe >= 0 && He > 0 && He < Le.length && w(Le, Ae, K, He, K, Ze, qe, re, de), Le.reverse(), Ae.reverse(), qe > -1 && He > 0) {
        let xe = v(ie, de);
        se = Sp(ie, Le, Ae, 0, Le.length, 0, te - K, xe, xe);
      } else
        se = b(ie, Le, Ae, te - K, re - te, de);
    }
    D.push(se), P.push(ce);
  }
  function p(R, _, D, P) {
    let H = [], z = 0, j = -1;
    for (; a.pos > _; ) {
      let { id: K, start: te, end: ee, size: re } = a;
      if (re > 4)
        a.next();
      else {
        if (j > -1 && te < j)
          break;
        j < 0 && (j = ee - i), H.push(K, te, ee), z++, a.next();
      }
    }
    if (z) {
      let K = new Uint16Array(z * 4), te = H[H.length - 2];
      for (let ee = H.length - 3, re = 0; ee >= 0; ee -= 3)
        K[re++] = H[ee], K[re++] = H[ee + 1] - te, K[re++] = H[ee + 2] - te, K[re++] = re;
      D.push(new zi(K, H[2] - te, r)), P.push(te - R);
    }
  }
  function v(R, _) {
    return (D, P, H) => {
      let z = 0, j = D.length - 1, K, te;
      if (j >= 0 && (K = D[j]) instanceof Dt) {
        if (!j && K.type == R && K.length == H)
          return K;
        (te = K.prop(Ge.lookAhead)) && (z = P[j] + K.length + te);
      }
      return b(R, D, P, H, z, _);
    };
  }
  function w(R, _, D, P, H, z, j, K, te) {
    let ee = [], re = [];
    for (; R.length > P; )
      ee.push(R.pop()), re.push(_.pop() + D - H);
    R.push(b(r.types[j], ee, re, z - H, K - z, te)), _.push(H - D);
  }
  function b(R, _, D, P, H, z, j) {
    if (z) {
      let K = [Ge.contextHash, z];
      j = j ? [K].concat(j) : [K];
    }
    if (H > 25) {
      let K = [Ge.lookAhead, H];
      j = j ? [K].concat(j) : [K];
    }
    return new Dt(R, _, D, P, j);
  }
  function y(R, _) {
    let D = a.fork(), P = 0, H = 0, z = 0, j = D.end - i, K = { size: 0, start: 0, skip: 0 };
    e: for (let te = D.pos - R; D.pos > te; ) {
      let ee = D.size;
      if (D.id == _ && ee >= 0) {
        K.size = P, K.start = H, K.skip = z, z += 4, P += 4, D.next();
        continue;
      }
      let re = D.pos - ee;
      if (ee < 0 || re < te || D.start < j)
        break;
      let de = D.id >= s ? 4 : 0, ie = D.start;
      for (D.next(); D.pos > re; ) {
        if (D.size < 0)
          if (D.size == -3)
            de += 4;
          else
            break e;
        else D.id >= s && (de += 4);
        D.next();
      }
      H = ie, P += ee, z += de;
    }
    return (_ < 0 || P == R) && (K.size = P, K.start = H, K.skip = z), K.size > 4 ? K : void 0;
  }
  function $(R, _, D) {
    let { id: P, start: H, end: z, size: j } = a;
    if (a.next(), j >= 0 && P < s) {
      let K = D;
      if (j > 4) {
        let te = a.pos - (j - 4);
        for (; a.pos > te; )
          D = $(R, _, D);
      }
      _[--D] = K, _[--D] = z - R, _[--D] = H - R, _[--D] = P;
    } else j == -3 ? h = P : j == -4 && (f = P);
    return D;
  }
  let A = [], k = [];
  for (; a.pos > 0; )
    d(t.start || 0, t.bufferStart || 0, A, k, -1, 0);
  let T = (e = t.length) !== null && e !== void 0 ? e : A.length ? k[0] + A[0].length : 0;
  return new Dt(c[t.topID], A.reverse(), k.reverse(), T);
}
const k5 = /* @__PURE__ */ new WeakMap();
function bu(t, e) {
  if (!t.isAnonymous || e instanceof zi || e.type != t)
    return 1;
  let n = k5.get(e);
  if (n == null) {
    n = 1;
    for (let r of e.children) {
      if (r.type != t || !(r instanceof Dt)) {
        n = 1;
        break;
      }
      n += bu(t, r);
    }
    k5.set(e, n);
  }
  return n;
}
function Sp(t, e, n, r, i, o, s, a, c) {
  let h = 0;
  for (let w = r; w < i; w++)
    h += bu(t, e[w]);
  let f = Math.ceil(
    h * 1.5 / 8
    /* Balance.BranchFactor */
  ), d = [], p = [];
  function v(w, b, y, $, A) {
    for (let k = y; k < $; ) {
      let T = k, R = b[k], _ = bu(t, w[k]);
      for (k++; k < $; k++) {
        let D = bu(t, w[k]);
        if (_ + D >= f)
          break;
        _ += D;
      }
      if (k == T + 1) {
        if (_ > f) {
          let D = w[T];
          v(D.children, D.positions, 0, D.children.length, b[T] + A);
          continue;
        }
        d.push(w[T]);
      } else {
        let D = b[k - 1] + w[k - 1].length - R;
        d.push(Sp(t, w, b, T, k, R, D, null, c));
      }
      p.push(R + A - o);
    }
  }
  return v(e, n, r, i, 0), (a || c)(d, p, s);
}
class Co {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, n, r, i, o = !1, s = !1) {
    this.from = e, this.to = n, this.tree = r, this.offset = i, this.open = (o ? 1 : 0) | (s ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, n = [], r = !1) {
    let i = [new Co(0, e.length, e, 0, !1, r)];
    for (let o of n)
      o.to > e.length && i.push(o);
    return i;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, n, r = 128) {
    if (!n.length)
      return e;
    let i = [], o = 1, s = e.length ? e[0] : null;
    for (let a = 0, c = 0, h = 0; ; a++) {
      let f = a < n.length ? n[a] : null, d = f ? f.fromA : 1e9;
      if (d - c >= r)
        for (; s && s.from < d; ) {
          let p = s;
          if (c >= p.from || d <= p.to || h) {
            let v = Math.max(p.from, c) - h, w = Math.min(p.to, d) - h;
            p = v >= w ? null : new Co(v, w, p.tree, p.offset + h, a > 0, !!f);
          }
          if (p && i.push(p), s.to > d)
            break;
          s = o < e.length ? e[o++] : null;
        }
      if (!f)
        break;
      c = f.toA, h = f.toA - f.toB;
    }
    return i;
  }
}
class Uy {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, n, r) {
    return typeof e == "string" && (e = new hP(e)), r = r ? r.length ? r.map((i) => new i0(i.from, i.to)) : [new i0(0, 0)] : [new i0(0, e.length)], this.createParse(e, n || [], r);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, n, r) {
    let i = this.startParse(e, n, r);
    for (; ; ) {
      let o = i.advance();
      if (o)
        return o;
    }
  }
}
class hP {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, n) {
    return this.string.slice(e, n);
  }
}
new Ge({ perNode: !0 });
class zu {
  /**
  @internal
  */
  constructor(e, n, r, i, o, s, a, c, h, f = 0, d) {
    this.p = e, this.stack = n, this.state = r, this.reducePos = i, this.pos = o, this.score = s, this.buffer = a, this.bufferBase = c, this.curContext = h, this.lookAhead = f, this.parent = d;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, n) => n % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, n, r = 0) {
    let i = e.parser.context;
    return new zu(e, [], n, r, r, 0, [], 0, i ? new M5(i, i.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, n) {
    this.stack.push(this.state, n, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var n;
    let r = e >> 19, i = e & 65535, { parser: o } = this.p, s = this.reducePos < this.pos - 25;
    s && this.setLookAhead(this.pos);
    let a = o.dynamicPrecedence(i);
    if (a && (this.score += a), r == 0) {
      this.pushState(o.getGoto(this.state, i, !0), this.reducePos), i < o.minRepeatTerm && this.storeNode(i, this.reducePos, this.reducePos, s ? 8 : 4, !0), this.reduceContext(i, this.reducePos);
      return;
    }
    let c = this.stack.length - (r - 1) * 3 - (e & 262144 ? 6 : 0), h = c ? this.stack[c - 2] : this.p.ranges[0].from, f = this.reducePos - h;
    f >= 2e3 && !(!((n = this.p.parser.nodeSet.types[i]) === null || n === void 0) && n.isAnonymous) && (h == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = f) : this.p.lastBigReductionSize < f && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = h, this.p.lastBigReductionSize = f));
    let d = c ? this.stack[c - 1] : 0, p = this.bufferBase + this.buffer.length - d;
    if (i < o.minRepeatTerm || e & 131072) {
      let v = o.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(i, h, v, p + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[c];
    else {
      let v = this.stack[c - 3];
      this.state = o.getGoto(v, i, !0);
    }
    for (; this.stack.length > c; )
      this.stack.pop();
    this.reduceContext(i, h);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, n, r, i = 4, o = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let s = this, a = this.buffer.length;
      if (a == 0 && s.parent && (a = s.bufferBase - s.parent.bufferBase, s = s.parent), a > 0 && s.buffer[a - 4] == 0 && s.buffer[a - 1] > -1) {
        if (n == r)
          return;
        if (s.buffer[a - 2] >= n) {
          s.buffer[a - 2] = r;
          return;
        }
      }
    }
    if (!o || this.pos == r)
      this.buffer.push(e, n, r, i);
    else {
      let s = this.buffer.length;
      if (s > 0 && this.buffer[s - 4] != 0) {
        let a = !1;
        for (let c = s; c > 0 && this.buffer[c - 2] > r; c -= 4)
          if (this.buffer[c - 1] >= 0) {
            a = !0;
            break;
          }
        if (a)
          for (; s > 0 && this.buffer[s - 2] > r; )
            this.buffer[s] = this.buffer[s - 4], this.buffer[s + 1] = this.buffer[s - 3], this.buffer[s + 2] = this.buffer[s - 2], this.buffer[s + 3] = this.buffer[s - 1], s -= 4, i > 4 && (i -= 4);
      }
      this.buffer[s] = e, this.buffer[s + 1] = n, this.buffer[s + 2] = r, this.buffer[s + 3] = i;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, n, r, i) {
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if (e & 262144)
      this.pos = i, this.shiftContext(n, r), n <= this.p.parser.maxNode && this.buffer.push(n, r, i, 4);
    else {
      let o = e, { parser: s } = this.p;
      (i > this.pos || n <= s.maxNode) && (this.pos = i, s.stateFlag(
        o,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = i)), this.pushState(o, r), this.shiftContext(n, r), n <= s.maxNode && this.buffer.push(n, r, i, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, n, r, i) {
    e & 65536 ? this.reduce(e) : this.shift(e, n, r, i);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, n) {
    let r = this.p.reused.length - 1;
    (r < 0 || this.p.reused[r] != e) && (this.p.reused.push(e), r++);
    let i = this.pos;
    this.reducePos = this.pos = i + e.length, this.pushState(n, i), this.buffer.push(
      r,
      i,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, n = e.buffer.length;
    for (; n > 0 && e.buffer[n - 2] > e.reducePos; )
      n -= 4;
    let r = e.buffer.slice(n), i = e.bufferBase + n;
    for (; e && i == e.bufferBase; )
      e = e.parent;
    return new zu(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, r, i, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, n) {
    let r = e <= this.p.parser.maxNode;
    r && this.storeNode(e, this.pos, n, 4), this.storeNode(0, this.pos, n, r ? 8 : 4), this.pos = this.reducePos = n, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let n = new fP(this); ; ) {
      let r = this.p.parser.stateSlot(
        n.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(n.state, e);
      if (r == 0)
        return !1;
      if (!(r & 65536))
        return !0;
      n.reduce(r);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let n = this.p.parser.nextStates(this.state);
    if (n.length > 8 || this.stack.length >= 120) {
      let i = [];
      for (let o = 0, s; o < n.length; o += 2)
        (s = n[o + 1]) != this.state && this.p.parser.hasAction(s, e) && i.push(n[o], s);
      if (this.stack.length < 120)
        for (let o = 0; i.length < 8 && o < n.length; o += 2) {
          let s = n[o + 1];
          i.some((a, c) => c & 1 && a == s) || i.push(n[o], s);
        }
      n = i;
    }
    let r = [];
    for (let i = 0; i < n.length && r.length < 4; i += 2) {
      let o = n[i + 1];
      if (o == this.state)
        continue;
      let s = this.split();
      s.pushState(o, this.pos), s.storeNode(0, s.pos, s.pos, 4, !0), s.shiftContext(n[i], this.pos), s.reducePos = this.pos, s.score -= 200, r.push(s);
    }
    return r;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, n = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(n & 65536))
      return !1;
    if (!e.validAction(this.state, n)) {
      let r = n >> 19, i = n & 65535, o = this.stack.length - r * 3;
      if (o < 0 || e.getGoto(this.stack[o], i, !1) < 0) {
        let s = this.findForcedReduction();
        if (s == null)
          return !1;
        n = s;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(n), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, n = [], r = (i, o) => {
      if (!n.includes(i))
        return n.push(i), e.allActions(i, (s) => {
          if (!(s & 393216)) if (s & 65536) {
            let a = (s >> 19) - o;
            if (a > 1) {
              let c = s & 65535, h = this.stack.length - a * 3;
              if (h >= 0 && e.getGoto(this.stack[h], c, !1) >= 0)
                return a << 19 | 65536 | c;
            }
          } else {
            let a = r(s, o + 1);
            if (a != null)
              return a;
          }
        });
    };
    return r(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let n = 0; n < this.stack.length; n += 3)
      if (this.stack[n] != e.stack[n])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, n) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(n)));
  }
  reduceContext(e, n) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(n)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let n = new M5(this.curContext.tracker, e);
      n.hash != this.curContext.hash && this.emitContext(), this.curContext = n;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class M5 {
  constructor(e, n) {
    this.tracker = e, this.context = n, this.hash = e.strict ? e.hash(n) : 0;
  }
}
class fP {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let n = e & 65535, r = e >> 19;
    r == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (r - 1) * 3;
    let i = this.start.p.parser.getGoto(this.stack[this.base - 3], n, !0);
    this.state = i;
  }
}
class Uu {
  constructor(e, n, r) {
    this.stack = e, this.pos = n, this.index = r, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, n = e.bufferBase + e.buffer.length) {
    return new Uu(e, n, n - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new Uu(this.stack, this.pos, this.index);
  }
}
function zc(t, e = Uint16Array) {
  if (typeof t != "string")
    return t;
  let n = null;
  for (let r = 0, i = 0; r < t.length; ) {
    let o = 0;
    for (; ; ) {
      let s = t.charCodeAt(r++), a = !1;
      if (s == 126) {
        o = 65535;
        break;
      }
      s >= 92 && s--, s >= 34 && s--;
      let c = s - 32;
      if (c >= 46 && (c -= 46, a = !0), o += c, a)
        break;
      o *= 46;
    }
    n ? n[i++] = o : n = new e(o);
  }
  return n;
}
class wu {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const T5 = new wu();
class dP {
  /**
  @internal
  */
  constructor(e, n) {
    this.input = e, this.ranges = n, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = T5, this.rangeIndex = 0, this.pos = this.chunkPos = n[0].from, this.range = n[0], this.end = n[n.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, n) {
    let r = this.range, i = this.rangeIndex, o = this.pos + e;
    for (; o < r.from; ) {
      if (!i)
        return null;
      let s = this.ranges[--i];
      o -= r.from - s.to, r = s;
    }
    for (; n < 0 ? o > r.to : o >= r.to; ) {
      if (i == this.ranges.length - 1)
        return null;
      let s = this.ranges[++i];
      o += s.from - r.to, r = s;
    }
    return o;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let n of this.ranges)
      if (n.to > e)
        return Math.max(e, n.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let n = this.chunkOff + e, r, i;
    if (n >= 0 && n < this.chunk.length)
      r = this.pos + e, i = this.chunk.charCodeAt(n);
    else {
      let o = this.resolveOffset(e, 1);
      if (o == null)
        return -1;
      if (r = o, r >= this.chunk2Pos && r < this.chunk2Pos + this.chunk2.length)
        i = this.chunk2.charCodeAt(r - this.chunk2Pos);
      else {
        let s = this.rangeIndex, a = this.range;
        for (; a.to <= r; )
          a = this.ranges[++s];
        this.chunk2 = this.input.chunk(this.chunk2Pos = r), r + this.chunk2.length > a.to && (this.chunk2 = this.chunk2.slice(0, a.to - r)), i = this.chunk2.charCodeAt(0);
      }
    }
    return r >= this.token.lookAhead && (this.token.lookAhead = r + 1), i;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, n = 0) {
    let r = n ? this.resolveOffset(n, -1) : this.pos;
    if (r == null || r < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = r;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(e, n) {
    this.token.value = e, this.token.end = n;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: n } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = n, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), n = this.pos + e.length;
      this.chunk = n > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, n) {
    if (n ? (this.token = n, n.start = e, n.lookAhead = e + 1, n.value = n.extended = -1) : this.token = T5, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, n) {
    if (e >= this.chunkPos && n <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, n - this.chunkPos);
    if (e >= this.chunk2Pos && n <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, n - this.chunk2Pos);
    if (e >= this.range.from && n <= this.range.to)
      return this.input.read(e, n);
    let r = "";
    for (let i of this.ranges) {
      if (i.from >= n)
        break;
      i.to > e && (r += this.input.read(Math.max(i.from, e), Math.min(i.to, n)));
    }
    return r;
  }
}
class Ss {
  constructor(e, n) {
    this.data = e, this.id = n;
  }
  token(e, n) {
    let { parser: r } = n.p;
    gP(this.data, e, n, this.id, r.data, r.tokenPrecTable);
  }
}
Ss.prototype.contextual = Ss.prototype.fallback = Ss.prototype.extend = !1;
Ss.prototype.fallback = Ss.prototype.extend = !1;
function gP(t, e, n, r, i, o) {
  let s = 0, a = 1 << r, { dialect: c } = n.p.parser;
  e: for (; a & t[s]; ) {
    let h = t[s + 1];
    for (let v = s + 3; v < h; v += 2)
      if ((t[v + 1] & a) > 0) {
        let w = t[v];
        if (c.allows(w) && (e.token.value == -1 || e.token.value == w || pP(w, e.token.value, i, o))) {
          e.acceptToken(w);
          break;
        }
      }
    let f = e.next, d = 0, p = t[s + 2];
    if (e.next < 0 && p > d && t[h + p * 3 - 3] == 65535) {
      s = t[h + p * 3 - 1];
      continue e;
    }
    for (; d < p; ) {
      let v = d + p >> 1, w = h + v + (v << 1), b = t[w], y = t[w + 1] || 65536;
      if (f < b)
        p = v;
      else if (f >= y)
        d = v + 1;
      else {
        s = t[w + 2], e.advance();
        continue e;
      }
    }
    break;
  }
}
function R5(t, e, n) {
  for (let r = e, i; (i = t[r]) != 65535; r++)
    if (i == n)
      return r - e;
  return -1;
}
function pP(t, e, n, r) {
  let i = R5(n, r, e);
  return i < 0 || R5(n, r, t) < i;
}
const In = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let o0 = null;
function E5(t, e, n) {
  let r = t.cursor(Pt.IncludeAnonymous);
  for (r.moveTo(e); ; )
    if (!(n < 0 ? r.childBefore(e) : r.childAfter(e)))
      for (; ; ) {
        if ((n < 0 ? r.to < e : r.from > e) && !r.type.isError)
          return n < 0 ? Math.max(0, Math.min(
            r.to - 1,
            e - 25
            /* Lookahead.Margin */
          )) : Math.min(t.length, Math.max(
            r.from + 1,
            e + 25
            /* Lookahead.Margin */
          ));
        if (n < 0 ? r.prevSibling() : r.nextSibling())
          break;
        if (!r.parent())
          return n < 0 ? 0 : t.length;
      }
}
class mP {
  constructor(e, n) {
    this.fragments = e, this.nodeSet = n, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? E5(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? E5(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let n = this.trees.length - 1;
      if (n < 0)
        return this.nextFragment(), null;
      let r = this.trees[n], i = this.index[n];
      if (i == r.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let o = r.children[i], s = this.start[n] + r.positions[i];
      if (s > e)
        return this.nextStart = s, null;
      if (o instanceof Dt) {
        if (s == e) {
          if (s < this.safeFrom)
            return null;
          let a = s + o.length;
          if (a <= this.safeTo) {
            let c = o.prop(Ge.lookAhead);
            if (!c || a + c < this.fragment.to)
              return o;
          }
        }
        this.index[n]++, s + o.length >= Math.max(this.safeFrom, e) && (this.trees.push(o), this.start.push(s), this.index.push(0));
      } else
        this.index[n]++, this.nextStart = s + o.length;
    }
  }
}
class vP {
  constructor(e, n) {
    this.stream = n, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((r) => new wu());
  }
  getActions(e) {
    let n = 0, r = null, { parser: i } = e.p, { tokenizers: o } = i, s = i.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), a = e.curContext ? e.curContext.hash : 0, c = 0;
    for (let h = 0; h < o.length; h++) {
      if (!(1 << h & s))
        continue;
      let f = o[h], d = this.tokens[h];
      if (!(r && !f.fallback) && ((f.contextual || d.start != e.pos || d.mask != s || d.context != a) && (this.updateCachedToken(d, f, e), d.mask = s, d.context = a), d.lookAhead > d.end + 25 && (c = Math.max(d.lookAhead, c)), d.value != 0)) {
        let p = n;
        if (d.extended > -1 && (n = this.addActions(e, d.extended, d.end, n)), n = this.addActions(e, d.value, d.end, n), !f.extend && (r = d, n > p))
          break;
      }
    }
    for (; this.actions.length > n; )
      this.actions.pop();
    return c && e.setLookAhead(c), !r && e.pos == this.stream.end && (r = new wu(), r.value = e.p.parser.eofTerm, r.start = r.end = e.pos, n = this.addActions(e, r.value, r.end, n)), this.mainToken = r, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let n = new wu(), { pos: r, p: i } = e;
    return n.start = r, n.end = Math.min(r + 1, i.stream.end), n.value = r == i.stream.end ? i.parser.eofTerm : 0, n;
  }
  updateCachedToken(e, n, r) {
    let i = this.stream.clipPos(r.pos);
    if (n.token(this.stream.reset(i, e), r), e.value > -1) {
      let { parser: o } = r.p;
      for (let s = 0; s < o.specialized.length; s++)
        if (o.specialized[s] == e.value) {
          let a = o.specializers[s](this.stream.read(e.start, e.end), r);
          if (a >= 0 && r.p.parser.dialect.allows(a >> 1)) {
            a & 1 ? e.extended = a >> 1 : e.value = a >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(i + 1);
  }
  putAction(e, n, r, i) {
    for (let o = 0; o < i; o += 3)
      if (this.actions[o] == e)
        return i;
    return this.actions[i++] = e, this.actions[i++] = n, this.actions[i++] = r, i;
  }
  addActions(e, n, r, i) {
    let { state: o } = e, { parser: s } = e.p, { data: a } = s;
    for (let c = 0; c < 2; c++)
      for (let h = s.stateSlot(
        o,
        c ? 2 : 1
        /* ParseState.Actions */
      ); ; h += 3) {
        if (a[h] == 65535)
          if (a[h + 1] == 1)
            h = ni(a, h + 2);
          else {
            i == 0 && a[h + 1] == 2 && (i = this.putAction(ni(a, h + 2), n, r, i));
            break;
          }
        a[h] == n && (i = this.putAction(ni(a, h + 1), n, r, i));
      }
    return i;
  }
}
class bP {
  constructor(e, n, r, i) {
    this.parser = e, this.input = n, this.ranges = i, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new dP(n, i), this.tokens = new vP(e, this.stream), this.topTerm = e.top[1];
    let { from: o } = i[0];
    this.stacks = [zu.start(this, e.top[0], o)], this.fragments = r.length && this.stream.end - o > e.bufferLength * 4 ? new mP(r, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, n = this.minStackPos, r = this.stacks = [], i, o;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [s] = e;
      for (; s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let s = 0; s < e.length; s++) {
      let a = e[s];
      for (; ; ) {
        if (this.tokens.mainToken = null, a.pos > n)
          r.push(a);
        else {
          if (this.advanceStack(a, r, e))
            continue;
          {
            i || (i = [], o = []), i.push(a);
            let c = this.tokens.getMainToken(a);
            o.push(c.value, c.end);
          }
        }
        break;
      }
    }
    if (!r.length) {
      let s = i && xP(i);
      if (s)
        return In && console.log("Finish with " + this.stackID(s)), this.stackToTree(s);
      if (this.parser.strict)
        throw In && i && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + n);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && i) {
      let s = this.stoppedAt != null && i[0].pos > this.stoppedAt ? i[0] : this.runRecovery(i, o, r);
      if (s)
        return In && console.log("Force-finish " + this.stackID(s)), this.stackToTree(s.forceAll());
    }
    if (this.recovering) {
      let s = this.recovering == 1 ? 1 : this.recovering * 3;
      if (r.length > s)
        for (r.sort((a, c) => c.score - a.score); r.length > s; )
          r.pop();
      r.some((a) => a.reducePos > n) && this.recovering--;
    } else if (r.length > 1) {
      e: for (let s = 0; s < r.length - 1; s++) {
        let a = r[s];
        for (let c = s + 1; c < r.length; c++) {
          let h = r[c];
          if (a.sameState(h) || a.buffer.length > 500 && h.buffer.length > 500)
            if ((a.score - h.score || a.buffer.length - h.buffer.length) > 0)
              r.splice(c--, 1);
            else {
              r.splice(s--, 1);
              continue e;
            }
        }
      }
      r.length > 12 && r.splice(
        12,
        r.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = r[0].pos;
    for (let s = 1; s < r.length; s++)
      r[s].pos < this.minStackPos && (this.minStackPos = r[s].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, n, r) {
    let i = e.pos, { parser: o } = this, s = In ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && i > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let h = e.curContext && e.curContext.tracker.strict, f = h ? e.curContext.hash : 0;
      for (let d = this.fragments.nodeAt(i); d; ) {
        let p = this.parser.nodeSet.types[d.type.id] == d.type ? o.getGoto(e.state, d.type.id) : -1;
        if (p > -1 && d.length && (!h || (d.prop(Ge.contextHash) || 0) == f))
          return e.useNode(d, p), In && console.log(s + this.stackID(e) + ` (via reuse of ${o.getName(d.type.id)})`), !0;
        if (!(d instanceof Dt) || d.children.length == 0 || d.positions[0] > 0)
          break;
        let v = d.children[0];
        if (v instanceof Dt && d.positions[0] == 0)
          d = v;
        else
          break;
      }
    }
    let a = o.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (a > 0)
      return e.reduce(a), In && console.log(s + this.stackID(e) + ` (via always-reduce ${o.getName(
        a & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); )
        ;
    let c = this.tokens.getActions(e);
    for (let h = 0; h < c.length; ) {
      let f = c[h++], d = c[h++], p = c[h++], v = h == c.length || !r, w = v ? e : e.split(), b = this.tokens.mainToken;
      if (w.apply(f, d, b ? b.start : w.pos, p), In && console.log(s + this.stackID(w) + ` (via ${f & 65536 ? `reduce of ${o.getName(
        f & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${o.getName(d)} @ ${i}${w == e ? "" : ", split"})`), v)
        return !0;
      w.pos > i ? n.push(w) : r.push(w);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, n) {
    let r = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > r)
        return O5(e, n), !0;
    }
  }
  runRecovery(e, n, r) {
    let i = null, o = !1;
    for (let s = 0; s < e.length; s++) {
      let a = e[s], c = n[s << 1], h = n[(s << 1) + 1], f = In ? this.stackID(a) + " -> " : "";
      if (a.deadEnd && (o || (o = !0, a.restart(), In && console.log(f + this.stackID(a) + " (restarted)"), this.advanceFully(a, r))))
        continue;
      let d = a.split(), p = f;
      for (let v = 0; d.forceReduce() && v < 10 && (In && console.log(p + this.stackID(d) + " (via force-reduce)"), !this.advanceFully(d, r)); v++)
        In && (p = this.stackID(d) + " -> ");
      for (let v of a.recoverByInsert(c))
        In && console.log(f + this.stackID(v) + " (via recover-insert)"), this.advanceFully(v, r);
      this.stream.end > a.pos ? (h == a.pos && (h++, c = 0), a.recoverByDelete(c, h), In && console.log(f + this.stackID(a) + ` (via recover-delete ${this.parser.getName(c)})`), O5(a, r)) : (!i || i.score < a.score) && (i = a);
    }
    return i;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), Dt.build({
      buffer: Uu.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let n = (o0 || (o0 = /* @__PURE__ */ new WeakMap())).get(e);
    return n || o0.set(e, n = String.fromCodePoint(this.nextStackID++)), n + e;
  }
}
function O5(t, e) {
  for (let n = 0; n < e.length; n++) {
    let r = e[n];
    if (r.pos == t.pos && r.sameState(t)) {
      e[n].score < t.score && (e[n] = t);
      return;
    }
  }
  e.push(t);
}
class wP {
  constructor(e, n, r) {
    this.source = e, this.flags = n, this.disabled = r;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
class Ku extends Uy {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let n = e.nodeNames.split(" ");
    this.minRepeatTerm = n.length;
    for (let a = 0; a < e.repeatNodeCount; a++)
      n.push("");
    let r = Object.keys(e.topRules).map((a) => e.topRules[a][1]), i = [];
    for (let a = 0; a < n.length; a++)
      i.push([]);
    function o(a, c, h) {
      i[a].push([c, c.deserialize(String(h))]);
    }
    if (e.nodeProps)
      for (let a of e.nodeProps) {
        let c = a[0];
        typeof c == "string" && (c = Ge[c]);
        for (let h = 1; h < a.length; ) {
          let f = a[h++];
          if (f >= 0)
            o(f, c, a[h++]);
          else {
            let d = a[h + -f];
            for (let p = -f; p > 0; p--)
              o(a[h++], c, d);
            h++;
          }
        }
      }
    this.nodeSet = new yp(n.map((a, c) => Sn.define({
      name: c >= this.minRepeatTerm ? void 0 : a,
      id: c,
      props: i[c],
      top: r.indexOf(c) > -1,
      error: c == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(c) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = Hy;
    let s = zc(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let a = 0; a < this.specializerSpecs.length; a++)
      this.specialized[a] = this.specializerSpecs[a].term;
    this.specializers = this.specializerSpecs.map(D5), this.states = zc(e.states, Uint32Array), this.data = zc(e.stateData), this.goto = zc(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((a) => typeof a == "number" ? new Ss(s, a) : a), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, n, r) {
    let i = new bP(this, e, n, r);
    for (let o of this.wrappers)
      i = o(i, e, n, r);
    return i;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, n, r = !1) {
    let i = this.goto;
    if (n >= i[0])
      return -1;
    for (let o = i[n + 1]; ; ) {
      let s = i[o++], a = s & 1, c = i[o++];
      if (a && r)
        return c;
      for (let h = o + (s >> 1); o < h; o++)
        if (i[o] == e)
          return c;
      if (a)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, n) {
    let r = this.data;
    for (let i = 0; i < 2; i++)
      for (let o = this.stateSlot(
        e,
        i ? 2 : 1
        /* ParseState.Actions */
      ), s; ; o += 3) {
        if ((s = r[o]) == 65535)
          if (r[o + 1] == 1)
            s = r[o = ni(r, o + 2)];
          else {
            if (r[o + 1] == 2)
              return ni(r, o + 2);
            break;
          }
        if (s == n || s == 0)
          return ni(r, o + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, n) {
    return this.states[e * 6 + n];
  }
  /**
  @internal
  */
  stateFlag(e, n) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & n) > 0;
  }
  /**
  @internal
  */
  validAction(e, n) {
    return !!this.allActions(e, (r) => r == n ? !0 : null);
  }
  /**
  @internal
  */
  allActions(e, n) {
    let r = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), i = r ? n(r) : void 0;
    for (let o = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); i == null; o += 3) {
      if (this.data[o] == 65535)
        if (this.data[o + 1] == 1)
          o = ni(this.data, o + 2);
        else
          break;
      i = n(ni(this.data, o + 1));
    }
    return i;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let n = [];
    for (let r = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; r += 3) {
      if (this.data[r] == 65535)
        if (this.data[r + 1] == 1)
          r = ni(this.data, r + 2);
        else
          break;
      if (!(this.data[r + 2] & 1)) {
        let i = this.data[r + 1];
        n.some((o, s) => s & 1 && o == i) || n.push(this.data[r], i);
      }
    }
    return n;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let n = Object.assign(Object.create(Ku.prototype), this);
    if (e.props && (n.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let r = this.topRules[e.top];
      if (!r)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      n.top = r;
    }
    return e.tokenizers && (n.tokenizers = this.tokenizers.map((r) => {
      let i = e.tokenizers.find((o) => o.from == r);
      return i ? i.to : r;
    })), e.specializers && (n.specializers = this.specializers.slice(), n.specializerSpecs = this.specializerSpecs.map((r, i) => {
      let o = e.specializers.find((a) => a.from == r.external);
      if (!o)
        return r;
      let s = Object.assign(Object.assign({}, r), { external: o.to });
      return n.specializers[i] = D5(s), s;
    })), e.contextTracker && (n.context = e.contextTracker), e.dialect && (n.dialect = this.parseDialect(e.dialect)), e.strict != null && (n.strict = e.strict), e.wrap && (n.wrappers = n.wrappers.concat(e.wrap)), e.bufferLength != null && (n.bufferLength = e.bufferLength), n;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let n = this.dynamicPrecedences;
    return n == null ? 0 : n[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let n = Object.keys(this.dialects), r = n.map(() => !1);
    if (e)
      for (let o of e.split(" ")) {
        let s = n.indexOf(o);
        s >= 0 && (r[s] = !0);
      }
    let i = null;
    for (let o = 0; o < n.length; o++)
      if (!r[o])
        for (let s = this.dialects[n[o]], a; (a = this.data[s++]) != 65535; )
          (i || (i = new Uint8Array(this.maxTerm + 1)))[a] = 1;
    return new wP(e, r, i);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new Ku(e);
  }
}
function ni(t, e) {
  return t[e] | t[e + 1] << 16;
}
function xP(t) {
  let e = null;
  for (let n of t) {
    let r = n.p.stoppedAt;
    (n.pos == n.p.stream.end || r != null && n.pos > r) && n.p.parser.stateFlag(
      n.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < n.score) && (e = n);
  }
  return e;
}
function D5(t) {
  if (t.external) {
    let e = t.extend ? 1 : 0;
    return (n, r) => t.external(n, r) << 1 | e;
  }
  return t.get;
}
let yP = 0, ri = class d1 {
  /**
  @internal
  */
  constructor(e, n, r, i) {
    this.name = e, this.set = n, this.base = r, this.modified = i, this.id = yP++;
  }
  toString() {
    let { name: e } = this;
    for (let n of this.modified)
      n.name && (e = `${n.name}(${e})`);
    return e;
  }
  static define(e, n) {
    let r = typeof e == "string" ? e : "?";
    if (e instanceof d1 && (n = e), n?.base)
      throw new Error("Can not derive from a modified tag");
    let i = new d1(r, [], null, []);
    if (i.set.push(i), n)
      for (let o of n.set)
        i.set.push(o);
    return i;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(e) {
    let n = new qu(e);
    return (r) => r.modified.indexOf(n) > -1 ? r : qu.get(r.base || r, r.modified.concat(n).sort((i, o) => i.id - o.id));
  }
}, CP = 0;
class qu {
  constructor(e) {
    this.name = e, this.instances = [], this.id = CP++;
  }
  static get(e, n) {
    if (!n.length)
      return e;
    let r = n[0].instances.find((a) => a.base == e && $P(n, a.modified));
    if (r)
      return r;
    let i = [], o = new ri(e.name, i, e, n);
    for (let a of n)
      a.instances.push(o);
    let s = SP(n);
    for (let a of e.set)
      if (!a.modified.length)
        for (let c of s)
          i.push(qu.get(a, c));
    return o;
  }
}
function $P(t, e) {
  return t.length == e.length && t.every((n, r) => n == e[r]);
}
function SP(t) {
  let e = [[]];
  for (let n = 0; n < t.length; n++)
    for (let r = 0, i = e.length; r < i; r++)
      e.push(e[r].concat(t[n]));
  return e.sort((n, r) => r.length - n.length);
}
function Ky(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t) {
    let r = t[n];
    Array.isArray(r) || (r = [r]);
    for (let i of n.split(" "))
      if (i) {
        let o = [], s = 2, a = i;
        for (let d = 0; ; ) {
          if (a == "..." && d > 0 && d + 3 == i.length) {
            s = 1;
            break;
          }
          let p = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
          if (!p)
            throw new RangeError("Invalid path: " + i);
          if (o.push(p[0] == "*" ? "" : p[0][0] == '"' ? JSON.parse(p[0]) : p[0]), d += p[0].length, d == i.length)
            break;
          let v = i[d++];
          if (d == i.length && v == "!") {
            s = 0;
            break;
          }
          if (v != "/")
            throw new RangeError("Invalid path: " + i);
          a = i.slice(d);
        }
        let c = o.length - 1, h = o[c];
        if (!h)
          throw new RangeError("Invalid path: " + i);
        let f = new Gu(r, s, c > 0 ? o.slice(0, c) : null);
        e[h] = f.sort(e[h]);
      }
  }
  return qy.add(e);
}
const qy = new Ge();
class Gu {
  constructor(e, n, r, i) {
    this.tags = e, this.mode = n, this.context = r, this.next = i;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
Gu.empty = new Gu([], 2, null);
function Gy(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let o of t)
    if (!Array.isArray(o.tag))
      n[o.tag.id] = o.class;
    else
      for (let s of o.tag)
        n[s.id] = o.class;
  let { scope: r, all: i = null } = e || {};
  return {
    style: (o) => {
      let s = i;
      for (let a of o)
        for (let c of a.set) {
          let h = n[c.id];
          if (h) {
            s = s ? s + " " + h : h;
            break;
          }
        }
      return s;
    },
    scope: r
  };
}
function AP(t, e) {
  let n = null;
  for (let r of t) {
    let i = r.style(e);
    i && (n = n ? n + " " + i : i);
  }
  return n;
}
function kP(t, e, n, r = 0, i = t.length) {
  let o = new MP(r, Array.isArray(e) ? e : [e], n);
  o.highlightRange(t.cursor(), r, i, "", o.highlighters), o.flush(i);
}
class MP {
  constructor(e, n, r) {
    this.at = e, this.highlighters = n, this.span = r, this.class = "";
  }
  startSpan(e, n) {
    n != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = n);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, n, r, i, o) {
    let { type: s, from: a, to: c } = e;
    if (a >= r || c <= n)
      return;
    s.isTop && (o = this.highlighters.filter((v) => !v.scope || v.scope(s)));
    let h = i, f = TP(e) || Gu.empty, d = AP(o, f.tags);
    if (d && (h && (h += " "), h += d, f.mode == 1 && (i += (i ? " " : "") + d)), this.startSpan(Math.max(n, a), h), f.opaque)
      return;
    let p = e.tree && e.tree.prop(Ge.mounted);
    if (p && p.overlay) {
      let v = e.node.enter(p.overlay[0].from + a, 1), w = this.highlighters.filter((y) => !y.scope || y.scope(p.tree.type)), b = e.firstChild();
      for (let y = 0, $ = a; ; y++) {
        let A = y < p.overlay.length ? p.overlay[y] : null, k = A ? A.from + a : c, T = Math.max(n, $), R = Math.min(r, k);
        if (T < R && b)
          for (; e.from < R && (this.highlightRange(e, T, R, i, o), this.startSpan(Math.min(R, e.to), h), !(e.to >= k || !e.nextSibling())); )
            ;
        if (!A || k > r)
          break;
        $ = A.to + a, $ > n && (this.highlightRange(v.cursor(), Math.max(n, A.from + a), Math.min(r, $), "", w), this.startSpan(Math.min(r, $), h));
      }
      b && e.parent();
    } else if (e.firstChild()) {
      p && (i = "");
      do
        if (!(e.to <= n)) {
          if (e.from >= r)
            break;
          this.highlightRange(e, n, r, i, o), this.startSpan(Math.min(r, e.to), h);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function TP(t) {
  let e = t.type.prop(qy);
  for (; e && e.context && !t.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const le = ri.define, Uc = le(), Di = le(), I5 = le(Di), _5 = le(Di), Ii = le(), Kc = le(Ii), s0 = le(Ii), $r = le(), co = le($r), xr = le(), yr = le(), g1 = le(), $a = le(g1), qc = le(), q = {
  /**
  A comment.
  */
  comment: Uc,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: le(Uc),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: le(Uc),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: le(Uc),
  /**
  Any kind of identifier.
  */
  name: Di,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: le(Di),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: I5,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: le(I5),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: _5,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: le(_5),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: le(Di),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: le(Di),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: le(Di),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: le(Di),
  /**
  A literal value.
  */
  literal: Ii,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: Kc,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: le(Kc),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: le(Kc),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: le(Kc),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: s0,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: le(s0),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: le(s0),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: le(Ii),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: le(Ii),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: le(Ii),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: le(Ii),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: le(Ii),
  /**
  A language keyword.
  */
  keyword: xr,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: le(xr),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: le(xr),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: le(xr),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: le(xr),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: le(xr),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: le(xr),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: le(xr),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: le(xr),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: le(xr),
  /**
  An operator.
  */
  operator: yr,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: le(yr),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: le(yr),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: le(yr),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: le(yr),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: le(yr),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: le(yr),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: le(yr),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: le(yr),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: le(yr),
  /**
  Program or markup punctuation.
  */
  punctuation: g1,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: le(g1),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: $a,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: le($a),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: le($a),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: le($a),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: le($a),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: $r,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: co,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: le(co),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: le(co),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: le(co),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: le(co),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: le(co),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: le(co),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: le($r),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: le($r),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: le($r),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: le($r),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: le($r),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: le($r),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: le($r),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: le($r),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: le(),
  /**
  Deleted text.
  */
  deleted: le(),
  /**
  Changed text.
  */
  changed: le(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: le(),
  /**
  Metadata or meta-instruction.
  */
  meta: qc,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: le(qc),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: le(qc),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: le(qc),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: ri.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: ri.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: ri.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: ri.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: ri.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: ri.defineModifier("special")
};
for (let t in q) {
  let e = q[t];
  e instanceof ri && (e.name = t);
}
Gy([
  { tag: q.link, class: "tok-link" },
  { tag: q.heading, class: "tok-heading" },
  { tag: q.emphasis, class: "tok-emphasis" },
  { tag: q.strong, class: "tok-strong" },
  { tag: q.keyword, class: "tok-keyword" },
  { tag: q.atom, class: "tok-atom" },
  { tag: q.bool, class: "tok-bool" },
  { tag: q.url, class: "tok-url" },
  { tag: q.labelName, class: "tok-labelName" },
  { tag: q.inserted, class: "tok-inserted" },
  { tag: q.deleted, class: "tok-deleted" },
  { tag: q.literal, class: "tok-literal" },
  { tag: q.string, class: "tok-string" },
  { tag: q.number, class: "tok-number" },
  { tag: [q.regexp, q.escape, q.special(q.string)], class: "tok-string2" },
  { tag: q.variableName, class: "tok-variableName" },
  { tag: q.local(q.variableName), class: "tok-variableName tok-local" },
  { tag: q.definition(q.variableName), class: "tok-variableName tok-definition" },
  { tag: q.special(q.variableName), class: "tok-variableName2" },
  { tag: q.definition(q.propertyName), class: "tok-propertyName tok-definition" },
  { tag: q.typeName, class: "tok-typeName" },
  { tag: q.namespace, class: "tok-namespace" },
  { tag: q.className, class: "tok-className" },
  { tag: q.macroName, class: "tok-macroName" },
  { tag: q.propertyName, class: "tok-propertyName" },
  { tag: q.operator, class: "tok-operator" },
  { tag: q.comment, class: "tok-comment" },
  { tag: q.meta, class: "tok-meta" },
  { tag: q.invalid, class: "tok-invalid" },
  { tag: q.punctuation, class: "tok-punctuation" }
]);
const RP = Ky({
  String: q.string,
  Number: q.number,
  "True False": q.bool,
  PropertyName: q.propertyName,
  Null: q.null,
  ", :": q.separator,
  "[ ]": q.squareBracket,
  "{ }": q.brace
}), EP = Ku.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#ClOOQO'#Cr'#CrQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CtOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59W,59WO!iQPO,59WOVQPO,59QOqQPO'#CmO!nQPO,59`OOQO1G.k1G.kOVQPO'#CnO!vQPO,59aOOQO1G.r1G.rOOQO1G.l1G.lOOQO,59X,59XOOQO-E6k-E6kOOQO,59Y,59YOOQO-E6l-E6l",
  stateData: "#O~OeOS~OQSORSOSSOTSOWQO_ROgPO~OVXOgUO~O^[O~PVO[^O~O]_OVhX~OVaO~O]bO^iX~O^dO~O]_OVha~O]bO^ia~O",
  goto: "!kjPPPPPPkPPkqwPPPPk{!RPPP!XP!e!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "⚠ JsonText True False Null Number String } { Object Property PropertyName : , ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["isolate", -2, 6, 11, ""],
    ["openedBy", 7, "{", 14, "["],
    ["closedBy", 8, "}", 15, "]"]
  ],
  propSources: [RP],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oe~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Og~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zO]~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yO[~~'OO_~~'TO^~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
});
let p1 = [], Yy = [];
(() => {
  let t = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
  for (let e = 0, n = 0; e < t.length; e++)
    (e % 2 ? Yy : p1).push(n = n + t[e]);
})();
function OP(t) {
  if (t < 768) return !1;
  for (let e = 0, n = p1.length; ; ) {
    let r = e + n >> 1;
    if (t < p1[r]) n = r;
    else if (t >= Yy[r]) e = r + 1;
    else return !0;
    if (e == n) return !1;
  }
}
function L5(t) {
  return t >= 127462 && t <= 127487;
}
const B5 = 8205;
function DP(t, e, n = !0, r = !0) {
  return (n ? jy : IP)(t, e, r);
}
function jy(t, e, n) {
  if (e == t.length) return e;
  e && Xy(t.charCodeAt(e)) && Zy(t.charCodeAt(e - 1)) && e--;
  let r = a0(t, e);
  for (e += N5(r); e < t.length; ) {
    let i = a0(t, e);
    if (r == B5 || i == B5 || n && OP(i))
      e += N5(i), r = i;
    else if (L5(i)) {
      let o = 0, s = e - 2;
      for (; s >= 0 && L5(a0(t, s)); )
        o++, s -= 2;
      if (o % 2 == 0) break;
      e += 2;
    } else
      break;
  }
  return e;
}
function IP(t, e, n) {
  for (; e > 0; ) {
    let r = jy(t, e - 2, n);
    if (r < e) return r;
    e--;
  }
  return 0;
}
function a0(t, e) {
  let n = t.charCodeAt(e);
  if (!Zy(n) || e + 1 == t.length) return n;
  let r = t.charCodeAt(e + 1);
  return Xy(r) ? (n - 55296 << 10) + (r - 56320) + 65536 : n;
}
function Xy(t) {
  return t >= 56320 && t < 57344;
}
function Zy(t) {
  return t >= 55296 && t < 56320;
}
function N5(t) {
  return t < 65536 ? 1 : 2;
}
class nt {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, n, r) {
    [e, n] = Ns(this, e, n);
    let i = [];
    return this.decompose(
      0,
      e,
      i,
      2
      /* Open.To */
    ), r.length && r.decompose(
      0,
      r.length,
      i,
      3
      /* Open.To */
    ), this.decompose(
      n,
      this.length,
      i,
      1
      /* Open.From */
    ), Sr.from(i, this.length - (n - e) + r.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, n = this.length) {
    [e, n] = Ns(this, e, n);
    let r = [];
    return this.decompose(e, n, r, 0), Sr.from(r, n - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let n = this.scanIdentical(e, 1), r = this.length - this.scanIdentical(e, -1), i = new Fa(this), o = new Fa(e);
    for (let s = n, a = n; ; ) {
      if (i.next(s), o.next(s), s = 0, i.lineBreak != o.lineBreak || i.done != o.done || i.value != o.value)
        return !1;
      if (a += i.value.length, i.done || a >= r)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new Fa(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, n = this.length) {
    return new Qy(this, e, n);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, n) {
    let r;
    if (e == null)
      r = this.iter();
    else {
      n == null && (n = this.lines + 1);
      let i = this.line(e).from;
      r = this.iterRange(i, Math.max(i, n == this.lines + 1 ? this.length : n <= 1 ? 0 : this.line(n - 1).to));
    }
    return new Jy(r);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? nt.empty : e.length <= 32 ? new At(e) : Sr.from(At.split(e, []));
  }
}
class At extends nt {
  constructor(e, n = _P(e)) {
    super(), this.text = e, this.length = n;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, n, r, i) {
    for (let o = 0; ; o++) {
      let s = this.text[o], a = i + s.length;
      if ((n ? r : a) >= e)
        return new LP(i, a, r, s);
      i = a + 1, r++;
    }
  }
  decompose(e, n, r, i) {
    let o = e <= 0 && n >= this.length ? this : new At(F5(this.text, e, n), Math.min(n, this.length) - Math.max(0, e));
    if (i & 1) {
      let s = r.pop(), a = xu(o.text, s.text.slice(), 0, o.length);
      if (a.length <= 32)
        r.push(new At(a, s.length + o.length));
      else {
        let c = a.length >> 1;
        r.push(new At(a.slice(0, c)), new At(a.slice(c)));
      }
    } else
      r.push(o);
  }
  replace(e, n, r) {
    if (!(r instanceof At))
      return super.replace(e, n, r);
    [e, n] = Ns(this, e, n);
    let i = xu(this.text, xu(r.text, F5(this.text, 0, e)), n), o = this.length + r.length - (n - e);
    return i.length <= 32 ? new At(i, o) : Sr.from(At.split(i, []), o);
  }
  sliceString(e, n = this.length, r = `
`) {
    [e, n] = Ns(this, e, n);
    let i = "";
    for (let o = 0, s = 0; o <= n && s < this.text.length; s++) {
      let a = this.text[s], c = o + a.length;
      o > e && s && (i += r), e < c && n > o && (i += a.slice(Math.max(0, e - o), n - o)), o = c + 1;
    }
    return i;
  }
  flatten(e) {
    for (let n of this.text)
      e.push(n);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, n) {
    let r = [], i = -1;
    for (let o of e)
      r.push(o), i += o.length + 1, r.length == 32 && (n.push(new At(r, i)), r = [], i = -1);
    return i > -1 && n.push(new At(r, i)), n;
  }
}
class Sr extends nt {
  constructor(e, n) {
    super(), this.children = e, this.length = n, this.lines = 0;
    for (let r of e)
      this.lines += r.lines;
  }
  lineInner(e, n, r, i) {
    for (let o = 0; ; o++) {
      let s = this.children[o], a = i + s.length, c = r + s.lines - 1;
      if ((n ? c : a) >= e)
        return s.lineInner(e, n, r, i);
      i = a + 1, r = c + 1;
    }
  }
  decompose(e, n, r, i) {
    for (let o = 0, s = 0; s <= n && o < this.children.length; o++) {
      let a = this.children[o], c = s + a.length;
      if (e <= c && n >= s) {
        let h = i & ((s <= e ? 1 : 0) | (c >= n ? 2 : 0));
        s >= e && c <= n && !h ? r.push(a) : a.decompose(e - s, n - s, r, h);
      }
      s = c + 1;
    }
  }
  replace(e, n, r) {
    if ([e, n] = Ns(this, e, n), r.lines < this.lines)
      for (let i = 0, o = 0; i < this.children.length; i++) {
        let s = this.children[i], a = o + s.length;
        if (e >= o && n <= a) {
          let c = s.replace(e - o, n - o, r), h = this.lines - s.lines + c.lines;
          if (c.lines < h >> 4 && c.lines > h >> 6) {
            let f = this.children.slice();
            return f[i] = c, new Sr(f, this.length - (n - e) + r.length);
          }
          return super.replace(o, a, c);
        }
        o = a + 1;
      }
    return super.replace(e, n, r);
  }
  sliceString(e, n = this.length, r = `
`) {
    [e, n] = Ns(this, e, n);
    let i = "";
    for (let o = 0, s = 0; o < this.children.length && s <= n; o++) {
      let a = this.children[o], c = s + a.length;
      s > e && o && (i += r), e < c && n > s && (i += a.sliceString(e - s, n - s, r)), s = c + 1;
    }
    return i;
  }
  flatten(e) {
    for (let n of this.children)
      n.flatten(e);
  }
  scanIdentical(e, n) {
    if (!(e instanceof Sr))
      return 0;
    let r = 0, [i, o, s, a] = n > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; i += n, o += n) {
      if (i == s || o == a)
        return r;
      let c = this.children[i], h = e.children[o];
      if (c != h)
        return r + c.scanIdentical(h, n);
      r += c.length + 1;
    }
  }
  static from(e, n = e.reduce((r, i) => r + i.length + 1, -1)) {
    let r = 0;
    for (let v of e)
      r += v.lines;
    if (r < 32) {
      let v = [];
      for (let w of e)
        w.flatten(v);
      return new At(v, n);
    }
    let i = Math.max(
      32,
      r >> 5
      /* Tree.BranchShift */
    ), o = i << 1, s = i >> 1, a = [], c = 0, h = -1, f = [];
    function d(v) {
      let w;
      if (v.lines > o && v instanceof Sr)
        for (let b of v.children)
          d(b);
      else v.lines > s && (c > s || !c) ? (p(), a.push(v)) : v instanceof At && c && (w = f[f.length - 1]) instanceof At && v.lines + w.lines <= 32 ? (c += v.lines, h += v.length + 1, f[f.length - 1] = new At(w.text.concat(v.text), w.length + 1 + v.length)) : (c + v.lines > i && p(), c += v.lines, h += v.length + 1, f.push(v));
    }
    function p() {
      c != 0 && (a.push(f.length == 1 ? f[0] : Sr.from(f, h)), h = -1, c = f.length = 0);
    }
    for (let v of e)
      d(v);
    return p(), a.length == 1 ? a[0] : new Sr(a, n);
  }
}
nt.empty = /* @__PURE__ */ new At([""], 0);
function _P(t) {
  let e = -1;
  for (let n of t)
    e += n.length + 1;
  return e;
}
function xu(t, e, n = 0, r = 1e9) {
  for (let i = 0, o = 0, s = !0; o < t.length && i <= r; o++) {
    let a = t[o], c = i + a.length;
    c >= n && (c > r && (a = a.slice(0, r - i)), i < n && (a = a.slice(n - i)), s ? (e[e.length - 1] += a, s = !1) : e.push(a)), i = c + 1;
  }
  return e;
}
function F5(t, e, n) {
  return xu(t, [""], e, n);
}
class Fa {
  constructor(e, n = 1) {
    this.dir = n, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [n > 0 ? 1 : (e instanceof At ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, n) {
    for (this.done = this.lineBreak = !1; ; ) {
      let r = this.nodes.length - 1, i = this.nodes[r], o = this.offsets[r], s = o >> 1, a = i instanceof At ? i.text.length : i.children.length;
      if (s == (n > 0 ? a : 0)) {
        if (r == 0)
          return this.done = !0, this.value = "", this;
        n > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((o & 1) == (n > 0 ? 0 : 1)) {
        if (this.offsets[r] += n, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (i instanceof At) {
        let c = i.text[s + (n < 0 ? -1 : 0)];
        if (this.offsets[r] += n, c.length > Math.max(0, e))
          return this.value = e == 0 ? c : n > 0 ? c.slice(e) : c.slice(0, c.length - e), this;
        e -= c.length;
      } else {
        let c = i.children[s + (n < 0 ? -1 : 0)];
        e > c.length ? (e -= c.length, this.offsets[r] += n) : (n < 0 && this.offsets[r]--, this.nodes.push(c), this.offsets.push(n > 0 ? 1 : (c instanceof At ? c.text.length : c.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class Qy {
  constructor(e, n, r) {
    this.value = "", this.done = !1, this.cursor = new Fa(e, n > r ? -1 : 1), this.pos = n > r ? e.length : 0, this.from = Math.min(n, r), this.to = Math.max(n, r);
  }
  nextInner(e, n) {
    if (n < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, n < 0 ? this.pos - this.to : this.from - this.pos);
    let r = n < 0 ? this.pos - this.from : this.to - this.pos;
    e > r && (e = r), r -= e;
    let { value: i } = this.cursor.next(e);
    return this.pos += (i.length + e) * n, this.value = i.length <= r ? i : n < 0 ? i.slice(i.length - r) : i.slice(0, r), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class Jy {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: n, lineBreak: r, value: i } = this.inner.next(e);
    return n && this.afterBreak ? (this.value = "", this.afterBreak = !1) : n ? (this.done = !0, this.value = "") : r ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (nt.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Fa.prototype[Symbol.iterator] = Qy.prototype[Symbol.iterator] = Jy.prototype[Symbol.iterator] = function() {
  return this;
});
class LP {
  /**
  @internal
  */
  constructor(e, n, r, i) {
    this.from = e, this.to = n, this.number = r, this.text = i;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function Ns(t, e, n) {
  return e = Math.max(0, Math.min(t.length, e)), [e, Math.max(e, Math.min(t.length, n))];
}
function Zt(t, e, n = !0, r = !0) {
  return DP(t, e, n, r);
}
function BP(t) {
  return t >= 56320 && t < 57344;
}
function NP(t) {
  return t >= 55296 && t < 56320;
}
function wn(t, e) {
  let n = t.charCodeAt(e);
  if (!NP(n) || e + 1 == t.length)
    return n;
  let r = t.charCodeAt(e + 1);
  return BP(r) ? (n - 55296 << 10) + (r - 56320) + 65536 : n;
}
function Ap(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
function Ar(t) {
  return t < 65536 ? 1 : 2;
}
const m1 = /\r\n?|\n/;
var hn = /* @__PURE__ */ function(t) {
  return t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t;
}(hn || (hn = {}));
class Er {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let n = 0; n < this.sections.length; n += 2)
      e += this.sections[n];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let n = 0; n < this.sections.length; n += 2) {
      let r = this.sections[n + 1];
      e += r < 0 ? this.sections[n] : r;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let n = 0, r = 0, i = 0; n < this.sections.length; ) {
      let o = this.sections[n++], s = this.sections[n++];
      s < 0 ? (e(r, i, o), i += o) : i += s, r += o;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, n = !1) {
    v1(this, e, n);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let n = 0; n < this.sections.length; ) {
      let r = this.sections[n++], i = this.sections[n++];
      i < 0 ? e.push(r, i) : e.push(i, r);
    }
    return new Er(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : e6(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(e, n = !1) {
    return e.empty ? this : b1(this, e, n);
  }
  mapPos(e, n = -1, r = hn.Simple) {
    let i = 0, o = 0;
    for (let s = 0; s < this.sections.length; ) {
      let a = this.sections[s++], c = this.sections[s++], h = i + a;
      if (c < 0) {
        if (h > e)
          return o + (e - i);
        o += a;
      } else {
        if (r != hn.Simple && h >= e && (r == hn.TrackDel && i < e && h > e || r == hn.TrackBefore && i < e || r == hn.TrackAfter && h > e))
          return null;
        if (h > e || h == e && n < 0 && !a)
          return e == i || n < 0 ? o : o + c;
        o += c;
      }
      i = h;
    }
    if (e > i)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
    return o;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, n = e) {
    for (let r = 0, i = 0; r < this.sections.length && i <= n; ) {
      let o = this.sections[r++], s = this.sections[r++], a = i + o;
      if (s >= 0 && i <= n && a >= e)
        return i < e && a > n ? "cover" : !0;
      i = a;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 0; n < this.sections.length; ) {
      let r = this.sections[n++], i = this.sections[n++];
      e += (e ? " " : "") + r + (i >= 0 ? ":" + i : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((n) => typeof n != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new Er(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new Er(e);
  }
}
class Nt extends Er {
  constructor(e, n) {
    super(e), this.inserted = n;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return v1(this, (n, r, i, o, s) => e = e.replace(i, i + (r - n), s), !1), e;
  }
  mapDesc(e, n = !1) {
    return b1(this, e, n, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let n = this.sections.slice(), r = [];
    for (let i = 0, o = 0; i < n.length; i += 2) {
      let s = n[i], a = n[i + 1];
      if (a >= 0) {
        n[i] = a, n[i + 1] = s;
        let c = i >> 1;
        for (; r.length < c; )
          r.push(nt.empty);
        r.push(s ? e.slice(o, o + s) : nt.empty);
      }
      o += s;
    }
    return new Nt(n, r);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : e6(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, n = !1) {
    return e.empty ? this : b1(this, e, n, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, n = !1) {
    v1(this, e, n);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return Er.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let n = [], r = [], i = [], o = new Qa(this);
    e: for (let s = 0, a = 0; ; ) {
      let c = s == e.length ? 1e9 : e[s++];
      for (; a < c || a == c && o.len == 0; ) {
        if (o.done)
          break e;
        let f = Math.min(o.len, c - a);
        nn(i, f, -1);
        let d = o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0;
        nn(n, f, d), d > 0 && Bi(r, n, o.text), o.forward(f), a += f;
      }
      let h = e[s++];
      for (; a < h; ) {
        if (o.done)
          break e;
        let f = Math.min(o.len, h - a);
        nn(n, f, -1), nn(i, f, o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0), o.forward(f), a += f;
      }
    }
    return {
      changes: new Nt(n, r),
      filtered: Er.create(i)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let n = 0; n < this.sections.length; n += 2) {
      let r = this.sections[n], i = this.sections[n + 1];
      i < 0 ? e.push(r) : i == 0 ? e.push([r]) : e.push([r].concat(this.inserted[n >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, n, r) {
    let i = [], o = [], s = 0, a = null;
    function c(f = !1) {
      if (!f && !i.length)
        return;
      s < n && nn(i, n - s, -1);
      let d = new Nt(i, o);
      a = a ? a.compose(d.map(a)) : d, i = [], o = [], s = 0;
    }
    function h(f) {
      if (Array.isArray(f))
        for (let d of f)
          h(d);
      else if (f instanceof Nt) {
        if (f.length != n)
          throw new RangeError(`Mismatched change set length (got ${f.length}, expected ${n})`);
        c(), a = a ? a.compose(f.map(a)) : f;
      } else {
        let { from: d, to: p = d, insert: v } = f;
        if (d > p || d < 0 || p > n)
          throw new RangeError(`Invalid change range ${d} to ${p} (in doc of length ${n})`);
        let w = v ? typeof v == "string" ? nt.of(v.split(r || m1)) : v : nt.empty, b = w.length;
        if (d == p && b == 0)
          return;
        d < s && c(), d > s && nn(i, d - s, -1), nn(i, p - d, b), Bi(o, i, w), s = p;
      }
    }
    return h(e), c(!a), a;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new Nt(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let n = [], r = [];
    for (let i = 0; i < e.length; i++) {
      let o = e[i];
      if (typeof o == "number")
        n.push(o, -1);
      else {
        if (!Array.isArray(o) || typeof o[0] != "number" || o.some((s, a) => a && typeof s != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (o.length == 1)
          n.push(o[0], 0);
        else {
          for (; r.length < i; )
            r.push(nt.empty);
          r[i] = nt.of(o.slice(1)), n.push(o[0], r[i].length);
        }
      }
    }
    return new Nt(n, r);
  }
  /**
  @internal
  */
  static createSet(e, n) {
    return new Nt(e, n);
  }
}
function nn(t, e, n, r = !1) {
  if (e == 0 && n <= 0)
    return;
  let i = t.length - 2;
  i >= 0 && n <= 0 && n == t[i + 1] ? t[i] += e : i >= 0 && e == 0 && t[i] == 0 ? t[i + 1] += n : r ? (t[i] += e, t[i + 1] += n) : t.push(e, n);
}
function Bi(t, e, n) {
  if (n.length == 0)
    return;
  let r = e.length - 2 >> 1;
  if (r < t.length)
    t[t.length - 1] = t[t.length - 1].append(n);
  else {
    for (; t.length < r; )
      t.push(nt.empty);
    t.push(n);
  }
}
function v1(t, e, n) {
  let r = t.inserted;
  for (let i = 0, o = 0, s = 0; s < t.sections.length; ) {
    let a = t.sections[s++], c = t.sections[s++];
    if (c < 0)
      i += a, o += a;
    else {
      let h = i, f = o, d = nt.empty;
      for (; h += a, f += c, c && r && (d = d.append(r[s - 2 >> 1])), !(n || s == t.sections.length || t.sections[s + 1] < 0); )
        a = t.sections[s++], c = t.sections[s++];
      e(i, h, o, f, d), i = h, o = f;
    }
  }
}
function b1(t, e, n, r = !1) {
  let i = [], o = r ? [] : null, s = new Qa(t), a = new Qa(e);
  for (let c = -1; ; ) {
    if (s.done && a.len || a.done && s.len)
      throw new Error("Mismatched change set lengths");
    if (s.ins == -1 && a.ins == -1) {
      let h = Math.min(s.len, a.len);
      nn(i, h, -1), s.forward(h), a.forward(h);
    } else if (a.ins >= 0 && (s.ins < 0 || c == s.i || s.off == 0 && (a.len < s.len || a.len == s.len && !n))) {
      let h = a.len;
      for (nn(i, a.ins, -1); h; ) {
        let f = Math.min(s.len, h);
        s.ins >= 0 && c < s.i && s.len <= f && (nn(i, 0, s.ins), o && Bi(o, i, s.text), c = s.i), s.forward(f), h -= f;
      }
      a.next();
    } else if (s.ins >= 0) {
      let h = 0, f = s.len;
      for (; f; )
        if (a.ins == -1) {
          let d = Math.min(f, a.len);
          h += d, f -= d, a.forward(d);
        } else if (a.ins == 0 && a.len < f)
          f -= a.len, a.next();
        else
          break;
      nn(i, h, c < s.i ? s.ins : 0), o && c < s.i && Bi(o, i, s.text), c = s.i, s.forward(s.len - f);
    } else {
      if (s.done && a.done)
        return o ? Nt.createSet(i, o) : Er.create(i);
      throw new Error("Mismatched change set lengths");
    }
  }
}
function e6(t, e, n = !1) {
  let r = [], i = n ? [] : null, o = new Qa(t), s = new Qa(e);
  for (let a = !1; ; ) {
    if (o.done && s.done)
      return i ? Nt.createSet(r, i) : Er.create(r);
    if (o.ins == 0)
      nn(r, o.len, 0, a), o.next();
    else if (s.len == 0 && !s.done)
      nn(r, 0, s.ins, a), i && Bi(i, r, s.text), s.next();
    else {
      if (o.done || s.done)
        throw new Error("Mismatched change set lengths");
      {
        let c = Math.min(o.len2, s.len), h = r.length;
        if (o.ins == -1) {
          let f = s.ins == -1 ? -1 : s.off ? 0 : s.ins;
          nn(r, c, f, a), i && f && Bi(i, r, s.text);
        } else s.ins == -1 ? (nn(r, o.off ? 0 : o.len, c, a), i && Bi(i, r, o.textBit(c))) : (nn(r, o.off ? 0 : o.len, s.off ? 0 : s.ins, a), i && !s.off && Bi(i, r, s.text));
        a = (o.ins > c || s.ins >= 0 && s.len > c) && (a || r.length > h), o.forward2(c), s.forward(c);
      }
    }
  }
}
class Qa {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, n = this.i - 2 >> 1;
    return n >= e.length ? nt.empty : e[n];
  }
  textBit(e) {
    let { inserted: n } = this.set, r = this.i - 2 >> 1;
    return r >= n.length && !e ? nt.empty : n[r].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class po {
  constructor(e, n, r) {
    this.from = e, this.to = n, this.flags = r;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, n = -1) {
    let r, i;
    return this.empty ? r = i = e.mapPos(this.from, n) : (r = e.mapPos(this.from, 1), i = e.mapPos(this.to, -1)), r == this.from && i == this.to ? this : new po(r, i, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, n = e) {
    if (e <= this.anchor && n >= this.anchor)
      return J.range(e, n);
    let r = Math.abs(e - this.anchor) > Math.abs(n - this.anchor) ? e : n;
    return J.range(this.anchor, r);
  }
  /**
  Compare this range to another range.
  */
  eq(e, n = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!n || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return J.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, n, r) {
    return new po(e, n, r);
  }
}
class J {
  constructor(e, n) {
    this.ranges = e, this.mainIndex = n;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, n = -1) {
    return e.empty ? this : J.create(this.ranges.map((r) => r.map(e, n)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, n = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let r = 0; r < this.ranges.length; r++)
      if (!this.ranges[r].eq(e.ranges[r], n))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new J([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, n = !0) {
    return J.create([e].concat(this.ranges), n ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, n = this.mainIndex) {
    let r = this.ranges.slice();
    return r[n] = e, J.create(r, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new J(e.ranges.map((n) => po.fromJSON(n)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, n = e) {
    return new J([J.range(e, n)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, n = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let r = 0, i = 0; i < e.length; i++) {
      let o = e[i];
      if (o.empty ? o.from <= r : o.from < r)
        return J.normalized(e.slice(), n);
      r = o.to;
    }
    return new J(e, n);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, n = 0, r, i) {
    return po.create(e, e, (n == 0 ? 0 : n < 0 ? 8 : 16) | (r == null ? 7 : Math.min(6, r)) | (i ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, n, r, i) {
    let o = (r ?? 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
    return n < e ? po.create(n, e, 48 | o) : po.create(e, n, (n > e ? 8 : 0) | o);
  }
  /**
  @internal
  */
  static normalized(e, n = 0) {
    let r = e[n];
    e.sort((i, o) => i.from - o.from), n = e.indexOf(r);
    for (let i = 1; i < e.length; i++) {
      let o = e[i], s = e[i - 1];
      if (o.empty ? o.from <= s.to : o.from < s.to) {
        let a = s.from, c = Math.max(o.to, s.to);
        i <= n && n--, e.splice(--i, 2, o.anchor > o.head ? J.range(c, a) : J.range(a, c));
      }
    }
    return new J(e, n);
  }
}
function t6(t, e) {
  for (let n of t.ranges)
    if (n.to > e)
      throw new RangeError("Selection points outside of document");
}
let kp = 0;
class pe {
  constructor(e, n, r, i, o) {
    this.combine = e, this.compareInput = n, this.compare = r, this.isStatic = i, this.id = kp++, this.default = e([]), this.extensions = typeof o == "function" ? o(this) : o;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new pe(e.combine || ((n) => n), e.compareInput || ((n, r) => n === r), e.compare || (e.combine ? (n, r) => n === r : Mp), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new yu([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new yu(e, this, 1, n);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new yu(e, this, 2, n);
  }
  from(e, n) {
    return n || (n = (r) => r), this.compute([e], (r) => n(r.field(e)));
  }
}
function Mp(t, e) {
  return t == e || t.length == e.length && t.every((n, r) => n === e[r]);
}
class yu {
  constructor(e, n, r, i) {
    this.dependencies = e, this.facet = n, this.type = r, this.value = i, this.id = kp++;
  }
  dynamicSlot(e) {
    var n;
    let r = this.value, i = this.facet.compareInput, o = this.id, s = e[o] >> 1, a = this.type == 2, c = !1, h = !1, f = [];
    for (let d of this.dependencies)
      d == "doc" ? c = !0 : d == "selection" ? h = !0 : ((n = e[d.id]) !== null && n !== void 0 ? n : 1) & 1 || f.push(e[d.id]);
    return {
      create(d) {
        return d.values[s] = r(d), 1;
      },
      update(d, p) {
        if (c && p.docChanged || h && (p.docChanged || p.selection) || w1(d, f)) {
          let v = r(d);
          if (a ? !V5(v, d.values[s], i) : !i(v, d.values[s]))
            return d.values[s] = v, 1;
        }
        return 0;
      },
      reconfigure: (d, p) => {
        let v, w = p.config.address[o];
        if (w != null) {
          let b = ju(p, w);
          if (this.dependencies.every((y) => y instanceof pe ? p.facet(y) === d.facet(y) : y instanceof Kt ? p.field(y, !1) == d.field(y, !1) : !0) || (a ? V5(v = r(d), b, i) : i(v = r(d), b)))
            return d.values[s] = b, 0;
        } else
          v = r(d);
        return d.values[s] = v, 1;
      }
    };
  }
}
function V5(t, e, n) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (!n(t[r], e[r]))
      return !1;
  return !0;
}
function w1(t, e) {
  let n = !1;
  for (let r of e)
    Va(t, r) & 1 && (n = !0);
  return n;
}
function FP(t, e, n) {
  let r = n.map((c) => t[c.id]), i = n.map((c) => c.type), o = r.filter((c) => !(c & 1)), s = t[e.id] >> 1;
  function a(c) {
    let h = [];
    for (let f = 0; f < r.length; f++) {
      let d = ju(c, r[f]);
      if (i[f] == 2)
        for (let p of d)
          h.push(p);
      else
        h.push(d);
    }
    return e.combine(h);
  }
  return {
    create(c) {
      for (let h of r)
        Va(c, h);
      return c.values[s] = a(c), 1;
    },
    update(c, h) {
      if (!w1(c, o))
        return 0;
      let f = a(c);
      return e.compare(f, c.values[s]) ? 0 : (c.values[s] = f, 1);
    },
    reconfigure(c, h) {
      let f = w1(c, r), d = h.config.facets[e.id], p = h.facet(e);
      if (d && !f && Mp(n, d))
        return c.values[s] = p, 0;
      let v = a(c);
      return e.compare(v, p) ? (c.values[s] = p, 0) : (c.values[s] = v, 1);
    }
  };
}
const Gc = /* @__PURE__ */ pe.define({ static: !0 });
class Kt {
  constructor(e, n, r, i, o) {
    this.id = e, this.createF = n, this.updateF = r, this.compareF = i, this.spec = o, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let n = new Kt(kp++, e.create, e.update, e.compare || ((r, i) => r === i), e);
    return e.provide && (n.provides = e.provide(n)), n;
  }
  create(e) {
    let n = e.facet(Gc).find((r) => r.field == this);
    return (n?.create || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let n = e[this.id] >> 1;
    return {
      create: (r) => (r.values[n] = this.create(r), 1),
      update: (r, i) => {
        let o = r.values[n], s = this.updateF(o, i);
        return this.compareF(o, s) ? 0 : (r.values[n] = s, 1);
      },
      reconfigure: (r, i) => {
        let o = r.facet(Gc), s = i.facet(Gc), a;
        return (a = o.find((c) => c.field == this)) && a != s.find((c) => c.field == this) ? (r.values[n] = a.create(r), 1) : i.config.address[this.id] != null ? (r.values[n] = i.field(this), 0) : (r.values[n] = this.create(r), 1);
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, Gc.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const ho = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Sa(t) {
  return (e) => new n6(e, t);
}
const Wo = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ Sa(ho.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ Sa(ho.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ Sa(ho.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ Sa(ho.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ Sa(ho.lowest)
};
class n6 {
  constructor(e, n) {
    this.inner = e, this.prec = n;
  }
}
class Yh {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new x1(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return Yh.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class x1 {
  constructor(e, n) {
    this.compartment = e, this.inner = n;
  }
}
class Yu {
  constructor(e, n, r, i, o, s) {
    for (this.base = e, this.compartments = n, this.dynamicSlots = r, this.address = i, this.staticValues = o, this.facets = s, this.statusTemplate = []; this.statusTemplate.length < r.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let n = this.address[e.id];
    return n == null ? e.default : this.staticValues[n >> 1];
  }
  static resolve(e, n, r) {
    let i = [], o = /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ new Map();
    for (let p of VP(e, n, s))
      p instanceof Kt ? i.push(p) : (o[p.facet.id] || (o[p.facet.id] = [])).push(p);
    let a = /* @__PURE__ */ Object.create(null), c = [], h = [];
    for (let p of i)
      a[p.id] = h.length << 1, h.push((v) => p.slot(v));
    let f = r?.config.facets;
    for (let p in o) {
      let v = o[p], w = v[0].facet, b = f && f[p] || [];
      if (v.every(
        (y) => y.type == 0
        /* Provider.Static */
      ))
        if (a[w.id] = c.length << 1 | 1, Mp(b, v))
          c.push(r.facet(w));
        else {
          let y = w.combine(v.map(($) => $.value));
          c.push(r && w.compare(y, r.facet(w)) ? r.facet(w) : y);
        }
      else {
        for (let y of v)
          y.type == 0 ? (a[y.id] = c.length << 1 | 1, c.push(y.value)) : (a[y.id] = h.length << 1, h.push(($) => y.dynamicSlot($)));
        a[w.id] = h.length << 1, h.push((y) => FP(y, w, v));
      }
    }
    let d = h.map((p) => p(a));
    return new Yu(e, s, d, a, c, o);
  }
}
function VP(t, e, n) {
  let r = [[], [], [], [], []], i = /* @__PURE__ */ new Map();
  function o(s, a) {
    let c = i.get(s);
    if (c != null) {
      if (c <= a)
        return;
      let h = r[c].indexOf(s);
      h > -1 && r[c].splice(h, 1), s instanceof x1 && n.delete(s.compartment);
    }
    if (i.set(s, a), Array.isArray(s))
      for (let h of s)
        o(h, a);
    else if (s instanceof x1) {
      if (n.has(s.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let h = e.get(s.compartment) || s.inner;
      n.set(s.compartment, h), o(h, a);
    } else if (s instanceof n6)
      o(s.inner, s.prec);
    else if (s instanceof Kt)
      r[a].push(s), s.provides && o(s.provides, a);
    else if (s instanceof yu)
      r[a].push(s), s.facet.extensions && o(s.facet.extensions, ho.default);
    else {
      let h = s.extension;
      if (!h)
        throw new Error(`Unrecognized extension value in extension set (${s}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      o(h, a);
    }
  }
  return o(t, ho.default), r.reduce((s, a) => s.concat(a));
}
function Va(t, e) {
  if (e & 1)
    return 2;
  let n = e >> 1, r = t.status[n];
  if (r == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (r & 2)
    return r;
  t.status[n] = 4;
  let i = t.computeSlot(t, t.config.dynamicSlots[n]);
  return t.status[n] = 2 | i;
}
function ju(t, e) {
  return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
}
const r6 = /* @__PURE__ */ pe.define(), y1 = /* @__PURE__ */ pe.define({
  combine: (t) => t.some((e) => e),
  static: !0
}), i6 = /* @__PURE__ */ pe.define({
  combine: (t) => t.length ? t[0] : void 0,
  static: !0
}), o6 = /* @__PURE__ */ pe.define(), s6 = /* @__PURE__ */ pe.define(), a6 = /* @__PURE__ */ pe.define(), l6 = /* @__PURE__ */ pe.define({
  combine: (t) => t.length ? t[0] : !1
});
class Fr {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.value = n;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new HP();
  }
}
class HP {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new Fr(this, e);
  }
}
class PP {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new Ne(this, e);
  }
}
class Ne {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.value = n;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let n = this.type.map(this.value, e);
    return n === void 0 ? void 0 : n == this.value ? this : new Ne(this.type, n);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new PP(e.map || ((n) => n));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, n) {
    if (!e.length)
      return e;
    let r = [];
    for (let i of e) {
      let o = i.map(n);
      o && r.push(o);
    }
    return r;
  }
}
Ne.reconfigure = /* @__PURE__ */ Ne.define();
Ne.appendConfig = /* @__PURE__ */ Ne.define();
class Ft {
  constructor(e, n, r, i, o, s) {
    this.startState = e, this.changes = n, this.selection = r, this.effects = i, this.annotations = o, this.scrollIntoView = s, this._doc = null, this._state = null, r && t6(r, n.newLength), o.some((a) => a.type == Ft.time) || (this.annotations = o.concat(Ft.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, n, r, i, o, s) {
    return new Ft(e, n, r, i, o, s);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let n of this.annotations)
      if (n.type == e)
        return n.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let n = this.annotation(Ft.userEvent);
    return !!(n && (n == e || n.length > e.length && n.slice(0, e.length) == e && n[e.length] == "."));
  }
}
Ft.time = /* @__PURE__ */ Fr.define();
Ft.userEvent = /* @__PURE__ */ Fr.define();
Ft.addToHistory = /* @__PURE__ */ Fr.define();
Ft.remote = /* @__PURE__ */ Fr.define();
function WP(t, e) {
  let n = [];
  for (let r = 0, i = 0; ; ) {
    let o, s;
    if (r < t.length && (i == e.length || e[i] >= t[r]))
      o = t[r++], s = t[r++];
    else if (i < e.length)
      o = e[i++], s = e[i++];
    else
      return n;
    !n.length || n[n.length - 1] < o ? n.push(o, s) : n[n.length - 1] < s && (n[n.length - 1] = s);
  }
}
function c6(t, e, n) {
  var r;
  let i, o, s;
  return n ? (i = e.changes, o = Nt.empty(e.changes.length), s = t.changes.compose(e.changes)) : (i = e.changes.map(t.changes), o = t.changes.mapDesc(e.changes, !0), s = t.changes.compose(i)), {
    changes: s,
    selection: e.selection ? e.selection.map(o) : (r = t.selection) === null || r === void 0 ? void 0 : r.map(i),
    effects: Ne.mapEffects(t.effects, i).concat(Ne.mapEffects(e.effects, o)),
    annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: t.scrollIntoView || e.scrollIntoView
  };
}
function C1(t, e, n) {
  let r = e.selection, i = As(e.annotations);
  return e.userEvent && (i = i.concat(Ft.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof Nt ? e.changes : Nt.of(e.changes || [], n, t.facet(i6)),
    selection: r && (r instanceof J ? r : J.single(r.anchor, r.head)),
    effects: As(e.effects),
    annotations: i,
    scrollIntoView: !!e.scrollIntoView
  };
}
function u6(t, e, n) {
  let r = C1(t, e.length ? e[0] : {}, t.doc.length);
  e.length && e[0].filter === !1 && (n = !1);
  for (let o = 1; o < e.length; o++) {
    e[o].filter === !1 && (n = !1);
    let s = !!e[o].sequential;
    r = c6(r, C1(t, e[o], s ? r.changes.newLength : t.doc.length), s);
  }
  let i = Ft.create(t, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
  return UP(n ? zP(i) : i);
}
function zP(t) {
  let e = t.startState, n = !0;
  for (let i of e.facet(o6)) {
    let o = i(t);
    if (o === !1) {
      n = !1;
      break;
    }
    Array.isArray(o) && (n = n === !0 ? o : WP(n, o));
  }
  if (n !== !0) {
    let i, o;
    if (n === !1)
      o = t.changes.invertedDesc, i = Nt.empty(e.doc.length);
    else {
      let s = t.changes.filter(n);
      i = s.changes, o = s.filtered.mapDesc(s.changes).invertedDesc;
    }
    t = Ft.create(e, i, t.selection && t.selection.map(o), Ne.mapEffects(t.effects, o), t.annotations, t.scrollIntoView);
  }
  let r = e.facet(s6);
  for (let i = r.length - 1; i >= 0; i--) {
    let o = r[i](t);
    o instanceof Ft ? t = o : Array.isArray(o) && o.length == 1 && o[0] instanceof Ft ? t = o[0] : t = u6(e, As(o), !1);
  }
  return t;
}
function UP(t) {
  let e = t.startState, n = e.facet(a6), r = t;
  for (let i = n.length - 1; i >= 0; i--) {
    let o = n[i](t);
    o && Object.keys(o).length && (r = c6(r, C1(e, o, t.changes.newLength), !0));
  }
  return r == t ? t : Ft.create(e, t.changes, t.selection, r.effects, r.annotations, r.scrollIntoView);
}
const KP = [];
function As(t) {
  return t == null ? KP : Array.isArray(t) ? t : [t];
}
var bt = /* @__PURE__ */ function(t) {
  return t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t;
}(bt || (bt = {}));
const qP = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let $1;
try {
  $1 = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function GP(t) {
  if ($1)
    return $1.test(t);
  for (let e = 0; e < t.length; e++) {
    let n = t[e];
    if (/\w/.test(n) || n > "" && (n.toUpperCase() != n.toLowerCase() || qP.test(n)))
      return !0;
  }
  return !1;
}
function YP(t) {
  return (e) => {
    if (!/\S/.test(e))
      return bt.Space;
    if (GP(e))
      return bt.Word;
    for (let n = 0; n < t.length; n++)
      if (e.indexOf(t[n]) > -1)
        return bt.Word;
    return bt.Other;
  };
}
class et {
  constructor(e, n, r, i, o, s) {
    this.config = e, this.doc = n, this.selection = r, this.values = i, this.status = e.statusTemplate.slice(), this.computeSlot = o, s && (s._state = this);
    for (let a = 0; a < this.config.dynamicSlots.length; a++)
      Va(this, a << 1);
    this.computeSlot = null;
  }
  field(e, n = !0) {
    let r = this.config.address[e.id];
    if (r == null) {
      if (n)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Va(this, r), ju(this, r);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return u6(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let n = this.config, { base: r, compartments: i } = n;
    for (let a of e.effects)
      a.is(Yh.reconfigure) ? (n && (i = /* @__PURE__ */ new Map(), n.compartments.forEach((c, h) => i.set(h, c)), n = null), i.set(a.value.compartment, a.value.extension)) : a.is(Ne.reconfigure) ? (n = null, r = a.value) : a.is(Ne.appendConfig) && (n = null, r = As(r).concat(a.value));
    let o;
    n ? o = e.startState.values.slice() : (n = Yu.resolve(r, i, this), o = new et(n, this.doc, this.selection, n.dynamicSlots.map(() => null), (c, h) => h.reconfigure(c, this), null).values);
    let s = e.startState.facet(y1) ? e.newSelection : e.newSelection.asSingle();
    new et(n, e.newDoc, s, o, (a, c) => c.update(a, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((n) => ({
      changes: { from: n.from, to: n.to, insert: e },
      range: J.cursor(n.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let n = this.selection, r = e(n.ranges[0]), i = this.changes(r.changes), o = [r.range], s = As(r.effects);
    for (let a = 1; a < n.ranges.length; a++) {
      let c = e(n.ranges[a]), h = this.changes(c.changes), f = h.map(i);
      for (let p = 0; p < a; p++)
        o[p] = o[p].map(f);
      let d = i.mapDesc(h, !0);
      o.push(c.range.map(d)), i = i.compose(f), s = Ne.mapEffects(s, f).concat(Ne.mapEffects(As(c.effects), d));
    }
    return {
      changes: i,
      selection: J.create(o, n.mainIndex),
      effects: s
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof Nt ? e : Nt.of(e, this.doc.length, this.facet(et.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return nt.of(e.split(this.facet(et.lineSeparator) || m1));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, n = this.doc.length) {
    return this.doc.sliceString(e, n, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let n = this.config.address[e.id];
    return n == null ? e.default : (Va(this, n), ju(this, n));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let n = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let r in e) {
        let i = e[r];
        i instanceof Kt && this.config.address[i.id] != null && (n[r] = i.spec.toJSON(this.field(e[r]), this));
      }
    return n;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, n = {}, r) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (r) {
      for (let o in r)
        if (Object.prototype.hasOwnProperty.call(e, o)) {
          let s = r[o], a = e[o];
          i.push(s.init((c) => s.spec.fromJSON(a, c)));
        }
    }
    return et.create({
      doc: e.doc,
      selection: J.fromJSON(e.selection),
      extensions: n.extensions ? i.concat([n.extensions]) : i
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let n = Yu.resolve(e.extensions || [], /* @__PURE__ */ new Map()), r = e.doc instanceof nt ? e.doc : nt.of((e.doc || "").split(n.staticFacet(et.lineSeparator) || m1)), i = e.selection ? e.selection instanceof J ? e.selection : J.single(e.selection.anchor, e.selection.head) : J.single(0);
    return t6(i, r.length), n.staticFacet(y1) || (i = i.asSingle()), new et(n, r, i, n.dynamicSlots.map(() => null), (o, s) => s.create(o), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(et.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(et.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(l6);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...n) {
    for (let r of this.facet(et.phrases))
      if (Object.prototype.hasOwnProperty.call(r, e)) {
        e = r[e];
        break;
      }
    return n.length && (e = e.replace(/\$(\$|\d*)/g, (r, i) => {
      if (i == "$")
        return "$";
      let o = +(i || 1);
      return !o || o > n.length ? r : n[o - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, n, r = -1) {
    let i = [];
    for (let o of this.facet(r6))
      for (let s of o(this, n, r))
        Object.prototype.hasOwnProperty.call(s, e) && i.push(s[e]);
    return i;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return YP(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: n, from: r, length: i } = this.doc.lineAt(e), o = this.charCategorizer(e), s = e - r, a = e - r;
    for (; s > 0; ) {
      let c = Zt(n, s, !1);
      if (o(n.slice(c, s)) != bt.Word)
        break;
      s = c;
    }
    for (; a < i; ) {
      let c = Zt(n, a);
      if (o(n.slice(a, c)) != bt.Word)
        break;
      a = c;
    }
    return s == a ? null : J.range(s + r, a + r);
  }
}
et.allowMultipleSelections = y1;
et.tabSize = /* @__PURE__ */ pe.define({
  combine: (t) => t.length ? t[0] : 4
});
et.lineSeparator = i6;
et.readOnly = l6;
et.phrases = /* @__PURE__ */ pe.define({
  compare(t, e) {
    let n = Object.keys(t), r = Object.keys(e);
    return n.length == r.length && n.every((i) => t[i] == e[i]);
  }
});
et.languageData = r6;
et.changeFilter = o6;
et.transactionFilter = s6;
et.transactionExtender = a6;
Yh.reconfigure = /* @__PURE__ */ Ne.define();
function Vr(t, e, n = {}) {
  let r = {};
  for (let i of t)
    for (let o of Object.keys(i)) {
      let s = i[o], a = r[o];
      if (a === void 0)
        r[o] = s;
      else if (!(a === s || s === void 0)) if (Object.hasOwnProperty.call(n, o))
        r[o] = n[o](a, s);
      else
        throw new Error("Config merge conflict for field " + o);
    }
  for (let i in e)
    r[i] === void 0 && (r[i] = e[i]);
  return r;
}
class Ro {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, n = e) {
    return Ja.create(e, n, this);
  }
}
Ro.prototype.startSide = Ro.prototype.endSide = 0;
Ro.prototype.point = !1;
Ro.prototype.mapMode = hn.TrackDel;
class Ja {
  constructor(e, n, r) {
    this.from = e, this.to = n, this.value = r;
  }
  /**
  @internal
  */
  static create(e, n, r) {
    return new Ja(e, n, r);
  }
}
function S1(t, e) {
  return t.from - e.from || t.value.startSide - e.value.startSide;
}
class Tp {
  constructor(e, n, r, i) {
    this.from = e, this.to = n, this.value = r, this.maxPoint = i;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, n, r, i = 0) {
    let o = r ? this.to : this.from;
    for (let s = i, a = o.length; ; ) {
      if (s == a)
        return s;
      let c = s + a >> 1, h = o[c] - e || (r ? this.value[c].endSide : this.value[c].startSide) - n;
      if (c == s)
        return h >= 0 ? s : a;
      h >= 0 ? a = c : s = c + 1;
    }
  }
  between(e, n, r, i) {
    for (let o = this.findIndex(n, -1e9, !0), s = this.findIndex(r, 1e9, !1, o); o < s; o++)
      if (i(this.from[o] + e, this.to[o] + e, this.value[o]) === !1)
        return !1;
  }
  map(e, n) {
    let r = [], i = [], o = [], s = -1, a = -1;
    for (let c = 0; c < this.value.length; c++) {
      let h = this.value[c], f = this.from[c] + e, d = this.to[c] + e, p, v;
      if (f == d) {
        let w = n.mapPos(f, h.startSide, h.mapMode);
        if (w == null || (p = v = w, h.startSide != h.endSide && (v = n.mapPos(f, h.endSide), v < p)))
          continue;
      } else if (p = n.mapPos(f, h.startSide), v = n.mapPos(d, h.endSide), p > v || p == v && h.startSide > 0 && h.endSide <= 0)
        continue;
      (v - p || h.endSide - h.startSide) < 0 || (s < 0 && (s = p), h.point && (a = Math.max(a, v - p)), r.push(h), i.push(p - s), o.push(v - s));
    }
    return { mapped: r.length ? new Tp(i, o, r, a) : null, pos: s };
  }
}
class tt {
  constructor(e, n, r, i) {
    this.chunkPos = e, this.chunk = n, this.nextLayer = r, this.maxPoint = i;
  }
  /**
  @internal
  */
  static create(e, n, r, i) {
    return new tt(e, n, r, i);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let n of this.chunk)
      e += n.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: n = [], sort: r = !1, filterFrom: i = 0, filterTo: o = this.length } = e, s = e.filter;
    if (n.length == 0 && !s)
      return this;
    if (r && (n = n.slice().sort(S1)), this.isEmpty)
      return n.length ? tt.of(n) : this;
    let a = new h6(this, null, -1).goto(0), c = 0, h = [], f = new di();
    for (; a.value || c < n.length; )
      if (c < n.length && (a.from - n[c].from || a.startSide - n[c].value.startSide) >= 0) {
        let d = n[c++];
        f.addInner(d.from, d.to, d.value) || h.push(d);
      } else a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (c == n.length || this.chunkEnd(a.chunkIndex) < n[c].from) && (!s || i > this.chunkEnd(a.chunkIndex) || o < this.chunkPos[a.chunkIndex]) && f.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!s || i > a.to || o < a.from || s(a.from, a.to, a.value)) && (f.addInner(a.from, a.to, a.value) || h.push(Ja.create(a.from, a.to, a.value))), a.next());
    return f.finishInner(this.nextLayer.isEmpty && !h.length ? tt.empty : this.nextLayer.update({ add: h, filter: s, filterFrom: i, filterTo: o }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let n = [], r = [], i = -1;
    for (let s = 0; s < this.chunk.length; s++) {
      let a = this.chunkPos[s], c = this.chunk[s], h = e.touchesRange(a, a + c.length);
      if (h === !1)
        i = Math.max(i, c.maxPoint), n.push(c), r.push(e.mapPos(a));
      else if (h === !0) {
        let { mapped: f, pos: d } = c.map(a, e);
        f && (i = Math.max(i, f.maxPoint), n.push(f), r.push(d));
      }
    }
    let o = this.nextLayer.map(e);
    return n.length == 0 ? o : new tt(r, n, o || tt.empty, i);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, n, r) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let o = this.chunkPos[i], s = this.chunk[i];
        if (n >= o && e <= o + s.length && s.between(o, e - o, n - o, r) === !1)
          return;
      }
      this.nextLayer.between(e, n, r);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return el.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, n = 0) {
    return el.from(e).goto(n);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, n, r, i, o = -1) {
    let s = e.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= o), a = n.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= o), c = H5(s, a, r), h = new Aa(s, c, o), f = new Aa(a, c, o);
    r.iterGaps((d, p, v) => P5(h, d, f, p, v, i)), r.empty && r.length == 0 && P5(h, 0, f, 0, 0, i);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, n, r = 0, i) {
    i == null && (i = 999999999);
    let o = e.filter((f) => !f.isEmpty && n.indexOf(f) < 0), s = n.filter((f) => !f.isEmpty && e.indexOf(f) < 0);
    if (o.length != s.length)
      return !1;
    if (!o.length)
      return !0;
    let a = H5(o, s), c = new Aa(o, a, 0).goto(r), h = new Aa(s, a, 0).goto(r);
    for (; ; ) {
      if (c.to != h.to || !A1(c.active, h.active) || c.point && (!h.point || !c.point.eq(h.point)))
        return !1;
      if (c.to > i)
        return !0;
      c.next(), h.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, n, r, i, o = -1) {
    let s = new Aa(e, null, o).goto(n), a = n, c = s.openStart;
    for (; ; ) {
      let h = Math.min(s.to, r);
      if (s.point) {
        let f = s.activeForPoint(s.to), d = s.pointFrom < n ? f.length + 1 : s.point.startSide < 0 ? f.length : Math.min(f.length, c);
        i.point(a, h, s.point, f, d, s.pointRank), c = Math.min(s.openEnd(h), f.length);
      } else h > a && (i.span(a, h, s.active, c), c = s.openEnd(h));
      if (s.to > r)
        return c + (s.point && s.to > r ? 1 : 0);
      a = s.to, s.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, n = !1) {
    let r = new di();
    for (let i of e instanceof Ja ? [e] : n ? jP(e) : e)
      r.add(i.from, i.to, i.value);
    return r.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return tt.empty;
    let n = e[e.length - 1];
    for (let r = e.length - 2; r >= 0; r--)
      for (let i = e[r]; i != tt.empty; i = i.nextLayer)
        n = new tt(i.chunkPos, i.chunk, n, Math.max(i.maxPoint, n.maxPoint));
    return n;
  }
}
tt.empty = /* @__PURE__ */ new tt([], [], null, -1);
function jP(t) {
  if (t.length > 1)
    for (let e = t[0], n = 1; n < t.length; n++) {
      let r = t[n];
      if (S1(e, r) > 0)
        return t.slice().sort(S1);
      e = r;
    }
  return t;
}
tt.empty.nextLayer = tt.empty;
class di {
  finishChunk(e) {
    this.chunks.push(new Tp(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, n, r) {
    this.addInner(e, n, r) || (this.nextLayer || (this.nextLayer = new di())).add(e, n, r);
  }
  /**
  @internal
  */
  addInner(e, n, r) {
    let i = e - this.lastTo || r.startSide - this.last.endSide;
    if (i <= 0 && (e - this.lastFrom || r.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(n - this.chunkStart), this.last = r, this.lastFrom = e, this.lastTo = n, this.value.push(r), r.point && (this.maxPoint = Math.max(this.maxPoint, n - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, n) {
    if ((e - this.lastTo || n.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, n.maxPoint), this.chunks.push(n), this.chunkPos.push(e);
    let r = n.value.length - 1;
    return this.last = n.value[r], this.lastFrom = n.from[r] + e, this.lastTo = n.to[r] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(tt.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let n = tt.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, n;
  }
}
function H5(t, e, n) {
  let r = /* @__PURE__ */ new Map();
  for (let o of t)
    for (let s = 0; s < o.chunk.length; s++)
      o.chunk[s].maxPoint <= 0 && r.set(o.chunk[s], o.chunkPos[s]);
  let i = /* @__PURE__ */ new Set();
  for (let o of e)
    for (let s = 0; s < o.chunk.length; s++) {
      let a = r.get(o.chunk[s]);
      a != null && (n ? n.mapPos(a) : a) == o.chunkPos[s] && !n?.touchesRange(a, a + o.chunk[s].length) && i.add(o.chunk[s]);
    }
  return i;
}
class h6 {
  constructor(e, n, r, i = 0) {
    this.layer = e, this.skip = n, this.minPoint = r, this.rank = i;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, n = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, n, !1), this;
  }
  gotoInner(e, n, r) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, r = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], n, !0);
      (!r || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(e, n) {
    (this.to - e || this.endSide - n) < 0 && this.gotoInner(e, n, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], n = this.layer.chunk[this.chunkIndex], r = e + n.from[this.rangeIndex];
        if (this.from = r, this.to = e + n.to[this.rangeIndex], this.value = n.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class el {
  constructor(e) {
    this.heap = e;
  }
  static from(e, n = null, r = -1) {
    let i = [];
    for (let o = 0; o < e.length; o++)
      for (let s = e[o]; !s.isEmpty; s = s.nextLayer)
        s.maxPoint >= r && i.push(new h6(s, n, r, o));
    return i.length == 1 ? i[0] : new el(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, n = -1e9) {
    for (let r of this.heap)
      r.goto(e, n);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      l0(this.heap, r);
    return this.next(), this;
  }
  forward(e, n) {
    for (let r of this.heap)
      r.forward(e, n);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      l0(this.heap, r);
    (this.to - e || this.value.endSide - n) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), l0(this.heap, 0);
    }
  }
}
function l0(t, e) {
  for (let n = t[e]; ; ) {
    let r = (e << 1) + 1;
    if (r >= t.length)
      break;
    let i = t[r];
    if (r + 1 < t.length && i.compare(t[r + 1]) >= 0 && (i = t[r + 1], r++), n.compare(i) < 0)
      break;
    t[r] = n, t[e] = i, e = r;
  }
}
class Aa {
  constructor(e, n, r) {
    this.minPoint = r, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = el.from(e, n, r);
  }
  goto(e, n = -1e9) {
    return this.cursor.goto(e, n), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = n, this.openStart = -1, this.next(), this;
  }
  forward(e, n) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - n) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, n);
  }
  removeActive(e) {
    Yc(this.active, e), Yc(this.activeTo, e), Yc(this.activeRank, e), this.minActive = W5(this.active, this.activeTo);
  }
  addActive(e) {
    let n = 0, { value: r, to: i, rank: o } = this.cursor;
    for (; n < this.activeRank.length && (o - this.activeRank[n] || i - this.activeTo[n]) > 0; )
      n++;
    jc(this.active, n, r), jc(this.activeTo, n, i), jc(this.activeRank, n, o), e && jc(e, n, this.cursor.from), this.minActive = W5(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, n = this.point;
    this.point = null;
    let r = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > e) {
          this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
          break;
        }
        this.removeActive(i), r && Yc(r, i);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let o = this.cursor.value;
          if (!o.point)
            this.addActive(r), this.cursor.next();
          else if (n && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = o, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = o.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (r) {
      this.openStart = 0;
      for (let i = r.length - 1; i >= 0 && r[i] < e; i--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let n = [];
    for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)
      (this.activeTo[r] > e || this.activeTo[r] == e && this.active[r].endSide >= this.point.endSide) && n.push(this.active[r]);
    return n.reverse();
  }
  openEnd(e) {
    let n = 0;
    for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > e; r--)
      n++;
    return n;
  }
}
function P5(t, e, n, r, i, o) {
  t.goto(e), n.goto(r);
  let s = r + i, a = r, c = r - e;
  for (; ; ) {
    let h = t.to + c - n.to, f = h || t.endSide - n.endSide, d = f < 0 ? t.to + c : n.to, p = Math.min(d, s);
    if (t.point || n.point ? t.point && n.point && (t.point == n.point || t.point.eq(n.point)) && A1(t.activeForPoint(t.to), n.activeForPoint(n.to)) || o.comparePoint(a, p, t.point, n.point) : p > a && !A1(t.active, n.active) && o.compareRange(a, p, t.active, n.active), d > s)
      break;
    (h || t.openEnd != n.openEnd) && o.boundChange && o.boundChange(d), a = d, f <= 0 && t.next(), f >= 0 && n.next();
  }
}
function A1(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n] != e[n] && !t[n].eq(e[n]))
      return !1;
  return !0;
}
function Yc(t, e) {
  for (let n = e, r = t.length - 1; n < r; n++)
    t[n] = t[n + 1];
  t.pop();
}
function jc(t, e, n) {
  for (let r = t.length - 1; r >= e; r--)
    t[r + 1] = t[r];
  t[e] = n;
}
function W5(t, e) {
  let n = -1, r = 1e9;
  for (let i = 0; i < e.length; i++)
    (e[i] - r || t[i].endSide - t[n].endSide) < 0 && (n = i, r = e[i]);
  return n;
}
function na(t, e, n = t.length) {
  let r = 0;
  for (let i = 0; i < n && i < t.length; )
    t.charCodeAt(i) == 9 ? (r += e - r % e, i++) : (r++, i = Zt(t, i));
  return r;
}
function k1(t, e, n, r) {
  for (let i = 0, o = 0; ; ) {
    if (o >= e)
      return i;
    if (i == t.length)
      break;
    o += t.charCodeAt(i) == 9 ? n - o % n : 1, i = Zt(t, i);
  }
  return r === !0 ? -1 : t.length;
}
const M1 = "ͼ", z5 = typeof Symbol > "u" ? "__" + M1 : Symbol.for(M1), T1 = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), U5 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class Ui {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, n) {
    this.rules = [];
    let { finish: r } = n || {};
    function i(s) {
      return /^@/.test(s) ? [s] : s.split(/,\s*/);
    }
    function o(s, a, c, h) {
      let f = [], d = /^@(\w+)\b/.exec(s[0]), p = d && d[1] == "keyframes";
      if (d && a == null) return c.push(s[0] + ";");
      for (let v in a) {
        let w = a[v];
        if (/&/.test(v))
          o(
            v.split(/,\s*/).map((b) => s.map((y) => b.replace(/&/, y))).reduce((b, y) => b.concat(y)),
            w,
            c
          );
        else if (w && typeof w == "object") {
          if (!d) throw new RangeError("The value of a property (" + v + ") should be a primitive value.");
          o(i(v), w, f, p);
        } else w != null && f.push(v.replace(/_.*/, "").replace(/[A-Z]/g, (b) => "-" + b.toLowerCase()) + ": " + w + ";");
      }
      (f.length || p) && c.push((r && !d && !h ? s.map(r) : s).join(", ") + " {" + f.join(" ") + "}");
    }
    for (let s in e) o(i(s), e[s], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let e = U5[z5] || 1;
    return U5[z5] = e + 1, M1 + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, n, r) {
    let i = e[T1], o = r && r.nonce;
    i ? o && i.setNonce(o) : i = new XP(e, o), i.mount(Array.isArray(n) ? n : [n], e);
  }
}
let K5 = /* @__PURE__ */ new Map();
class XP {
  constructor(e, n) {
    let r = e.ownerDocument || e, i = r.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let o = K5.get(r);
      if (o) return e[T1] = o;
      this.sheet = new i.CSSStyleSheet(), K5.set(r, this);
    } else
      this.styleTag = r.createElement("style"), n && this.styleTag.setAttribute("nonce", n);
    this.modules = [], e[T1] = this;
  }
  mount(e, n) {
    let r = this.sheet, i = 0, o = 0;
    for (let s = 0; s < e.length; s++) {
      let a = e[s], c = this.modules.indexOf(a);
      if (c < o && c > -1 && (this.modules.splice(c, 1), o--, c = -1), c == -1) {
        if (this.modules.splice(o++, 0, a), r) for (let h = 0; h < a.rules.length; h++)
          r.insertRule(a.rules[h], i++);
      } else {
        for (; o < c; ) i += this.modules[o++].rules.length;
        i += a.rules.length, o++;
      }
    }
    if (r)
      n.adoptedStyleSheets.indexOf(this.sheet) < 0 && (n.adoptedStyleSheets = [this.sheet, ...n.adoptedStyleSheets]);
    else {
      let s = "";
      for (let c = 0; c < this.modules.length; c++)
        s += this.modules[c].getRules() + `
`;
      this.styleTag.textContent = s;
      let a = n.head || n;
      this.styleTag.parentNode != a && a.insertBefore(this.styleTag, a.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var Ki = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, tl = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, ZP = typeof navigator < "u" && /Mac/.test(navigator.platform), QP = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Xt = 0; Xt < 10; Xt++) Ki[48 + Xt] = Ki[96 + Xt] = String(Xt);
for (var Xt = 1; Xt <= 24; Xt++) Ki[Xt + 111] = "F" + Xt;
for (var Xt = 65; Xt <= 90; Xt++)
  Ki[Xt] = String.fromCharCode(Xt + 32), tl[Xt] = String.fromCharCode(Xt);
for (var c0 in Ki) tl.hasOwnProperty(c0) || (tl[c0] = Ki[c0]);
function JP(t) {
  var e = ZP && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || QP && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? tl : Ki)[t.keyCode] || t.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
function nl(t) {
  let e;
  return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t, e.getSelection();
}
function R1(t, e) {
  return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function Cu(t, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return R1(t, e.anchorNode);
  } catch {
    return !1;
  }
}
function Fs(t) {
  return t.nodeType == 3 ? Oo(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
}
function Ha(t, e, n, r) {
  return n ? q5(t, e, n, r, -1) || q5(t, e, n, r, 1) : !1;
}
function Eo(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}
function Xu(t) {
  return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
}
function q5(t, e, n, r, i) {
  for (; ; ) {
    if (t == n && e == r)
      return !0;
    if (e == (i < 0 ? 0 : _r(t))) {
      if (t.nodeName == "DIV")
        return !1;
      let o = t.parentNode;
      if (!o || o.nodeType != 1)
        return !1;
      e = Eo(t) + (i < 0 ? 0 : 1), t = o;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (i < 0 ? -1 : 0)], t.nodeType == 1 && t.contentEditable == "false")
        return !1;
      e = i < 0 ? _r(t) : 0;
    } else
      return !1;
  }
}
function _r(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function kl(t, e) {
  let n = e ? t.left : t.right;
  return { left: n, right: n, top: t.top, bottom: t.bottom };
}
function eW(t) {
  let e = t.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: t.innerWidth,
    top: 0,
    bottom: t.innerHeight
  };
}
function f6(t, e) {
  let n = e.width / t.offsetWidth, r = e.height / t.offsetHeight;
  return (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(e.width - t.offsetWidth) < 1) && (n = 1), (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.height - t.offsetHeight) < 1) && (r = 1), { scaleX: n, scaleY: r };
}
function tW(t, e, n, r, i, o, s, a) {
  let c = t.ownerDocument, h = c.defaultView || window;
  for (let f = t, d = !1; f && !d; )
    if (f.nodeType == 1) {
      let p, v = f == c.body, w = 1, b = 1;
      if (v)
        p = eW(h);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(f).position) && (d = !0), f.scrollHeight <= f.clientHeight && f.scrollWidth <= f.clientWidth) {
          f = f.assignedSlot || f.parentNode;
          continue;
        }
        let A = f.getBoundingClientRect();
        ({ scaleX: w, scaleY: b } = f6(f, A)), p = {
          left: A.left,
          right: A.left + f.clientWidth * w,
          top: A.top,
          bottom: A.top + f.clientHeight * b
        };
      }
      let y = 0, $ = 0;
      if (i == "nearest")
        e.top < p.top ? ($ = e.top - (p.top + s), n > 0 && e.bottom > p.bottom + $ && ($ = e.bottom - p.bottom + s)) : e.bottom > p.bottom && ($ = e.bottom - p.bottom + s, n < 0 && e.top - $ < p.top && ($ = e.top - (p.top + s)));
      else {
        let A = e.bottom - e.top, k = p.bottom - p.top;
        $ = (i == "center" && A <= k ? e.top + A / 2 - k / 2 : i == "start" || i == "center" && n < 0 ? e.top - s : e.bottom - k + s) - p.top;
      }
      if (r == "nearest" ? e.left < p.left ? (y = e.left - (p.left + o), n > 0 && e.right > p.right + y && (y = e.right - p.right + o)) : e.right > p.right && (y = e.right - p.right + o, n < 0 && e.left < p.left + y && (y = e.left - (p.left + o))) : y = (r == "center" ? e.left + (e.right - e.left) / 2 - (p.right - p.left) / 2 : r == "start" == a ? e.left - o : e.right - (p.right - p.left) + o) - p.left, y || $)
        if (v)
          h.scrollBy(y, $);
        else {
          let A = 0, k = 0;
          if ($) {
            let T = f.scrollTop;
            f.scrollTop += $ / b, k = (f.scrollTop - T) * b;
          }
          if (y) {
            let T = f.scrollLeft;
            f.scrollLeft += y / w, A = (f.scrollLeft - T) * w;
          }
          e = {
            left: e.left - A,
            top: e.top - k,
            right: e.right - A,
            bottom: e.bottom - k
          }, A && Math.abs(A - y) < 1 && (r = "nearest"), k && Math.abs(k - $) < 1 && (i = "nearest");
        }
      if (v)
        break;
      (e.top < p.top || e.bottom > p.bottom || e.left < p.left || e.right > p.right) && (e = {
        left: Math.max(e.left, p.left),
        right: Math.min(e.right, p.right),
        top: Math.max(e.top, p.top),
        bottom: Math.min(e.bottom, p.bottom)
      }), f = f.assignedSlot || f.parentNode;
    } else if (f.nodeType == 11)
      f = f.host;
    else
      break;
}
function nW(t) {
  let e = t.ownerDocument, n, r;
  for (let i = t.parentNode; i && !(i == e.body || n && r); )
    if (i.nodeType == 1)
      !r && i.scrollHeight > i.clientHeight && (r = i), !n && i.scrollWidth > i.clientWidth && (n = i), i = i.assignedSlot || i.parentNode;
    else if (i.nodeType == 11)
      i = i.host;
    else
      break;
  return { x: n, y: r };
}
class rW {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: n, focusNode: r } = e;
    this.set(n, Math.min(e.anchorOffset, n ? _r(n) : 0), r, Math.min(e.focusOffset, r ? _r(r) : 0));
  }
  set(e, n, r, i) {
    this.anchorNode = e, this.anchorOffset = n, this.focusNode = r, this.focusOffset = i;
  }
}
let gs = null;
function d6(t) {
  if (t.setActive)
    return t.setActive();
  if (gs)
    return t.focus(gs);
  let e = [];
  for (let n = t; n && (e.push(n, n.scrollTop, n.scrollLeft), n != n.ownerDocument); n = n.parentNode)
    ;
  if (t.focus(gs == null ? {
    get preventScroll() {
      return gs = { preventScroll: !0 }, !0;
    }
  } : void 0), !gs) {
    gs = !1;
    for (let n = 0; n < e.length; ) {
      let r = e[n++], i = e[n++], o = e[n++];
      r.scrollTop != i && (r.scrollTop = i), r.scrollLeft != o && (r.scrollLeft = o);
    }
  }
}
let G5;
function Oo(t, e, n = e) {
  let r = G5 || (G5 = document.createRange());
  return r.setEnd(t, n), r.setStart(t, e), r;
}
function ks(t, e, n, r) {
  let i = { key: e, code: e, keyCode: n, which: n, cancelable: !0 };
  r && ({ altKey: i.altKey, ctrlKey: i.ctrlKey, shiftKey: i.shiftKey, metaKey: i.metaKey } = r);
  let o = new KeyboardEvent("keydown", i);
  o.synthetic = !0, t.dispatchEvent(o);
  let s = new KeyboardEvent("keyup", i);
  return s.synthetic = !0, t.dispatchEvent(s), o.defaultPrevented || s.defaultPrevented;
}
function iW(t) {
  for (; t; ) {
    if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host))
      return t;
    t = t.assignedSlot || t.parentNode;
  }
  return null;
}
function g6(t) {
  for (; t.attributes.length; )
    t.removeAttributeNode(t.attributes[0]);
}
function oW(t, e) {
  let n = e.focusNode, r = e.focusOffset;
  if (!n || e.anchorNode != n || e.anchorOffset != r)
    return !1;
  for (r = Math.min(r, _r(n)); ; )
    if (r) {
      if (n.nodeType != 1)
        return !1;
      let i = n.childNodes[r - 1];
      i.contentEditable == "false" ? r-- : (n = i, r = _r(n));
    } else {
      if (n == t)
        return !0;
      r = Eo(n), n = n.parentNode;
    }
}
function p6(t) {
  return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);
}
function m6(t, e) {
  for (let n = t, r = e; ; ) {
    if (n.nodeType == 3 && r > 0)
      return { node: n, offset: r };
    if (n.nodeType == 1 && r > 0) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[r - 1], r = _r(n);
    } else if (n.parentNode && !Xu(n))
      r = Eo(n), n = n.parentNode;
    else
      return null;
  }
}
function v6(t, e) {
  for (let n = t, r = e; ; ) {
    if (n.nodeType == 3 && r < n.nodeValue.length)
      return { node: n, offset: r };
    if (n.nodeType == 1 && r < n.childNodes.length) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[r], r = 0;
    } else if (n.parentNode && !Xu(n))
      r = Eo(n) + 1, n = n.parentNode;
    else
      return null;
  }
}
class rn {
  constructor(e, n, r = !0) {
    this.node = e, this.offset = n, this.precise = r;
  }
  static before(e, n) {
    return new rn(e.parentNode, Eo(e), n);
  }
  static after(e, n) {
    return new rn(e.parentNode, Eo(e) + 1, n);
  }
}
const Rp = [];
class ft {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let n = this.posAtStart;
    for (let r of this.children) {
      if (r == e)
        return n;
      n += r.length + r.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, n) {
    if (this.flags & 2) {
      let r = this.dom, i = null, o;
      for (let s of this.children) {
        if (s.flags & 7) {
          if (!s.dom && (o = i ? i.nextSibling : r.firstChild)) {
            let a = ft.get(o);
            (!a || !a.parent && a.canReuseDOM(s)) && s.reuseDOM(o);
          }
          s.sync(e, n), s.flags &= -8;
        }
        if (o = i ? i.nextSibling : r.firstChild, n && !n.written && n.node == r && o != s.dom && (n.written = !0), s.dom.parentNode == r)
          for (; o && o != s.dom; )
            o = Y5(o);
        else
          r.insertBefore(s.dom, o);
        i = s.dom;
      }
      for (o = i ? i.nextSibling : r.firstChild, o && n && n.node == r && (n.written = !0); o; )
        o = Y5(o);
    } else if (this.flags & 1)
      for (let r of this.children)
        r.flags & 7 && (r.sync(e, n), r.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, n) {
    let r;
    if (e == this.dom)
      r = this.dom.childNodes[n];
    else {
      let i = _r(e) == 0 ? 0 : n == 0 ? -1 : 1;
      for (; ; ) {
        let o = e.parentNode;
        if (o == this.dom)
          break;
        i == 0 && o.firstChild != o.lastChild && (e == o.firstChild ? i = -1 : i = 1), e = o;
      }
      i < 0 ? r = e : r = e.nextSibling;
    }
    if (r == this.dom.firstChild)
      return 0;
    for (; r && !ft.get(r); )
      r = r.nextSibling;
    if (!r)
      return this.length;
    for (let i = 0, o = 0; ; i++) {
      let s = this.children[i];
      if (s.dom == r)
        return o;
      o += s.length + s.breakAfter;
    }
  }
  domBoundsAround(e, n, r = 0) {
    let i = -1, o = -1, s = -1, a = -1;
    for (let c = 0, h = r, f = r; c < this.children.length; c++) {
      let d = this.children[c], p = h + d.length;
      if (h < e && p > n)
        return d.domBoundsAround(e, n, h);
      if (p >= e && i == -1 && (i = c, o = h), h > n && d.dom.parentNode == this.dom) {
        s = c, a = f;
        break;
      }
      f = p, h = p + d.breakAfter;
    }
    return {
      from: o,
      to: a < 0 ? r + this.length : a,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: s < this.children.length && s >= 0 ? this.children[s].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let n = this.parent; n; n = n.parent) {
      if (e && (n.flags |= 2), n.flags & 1)
        return;
      n.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let n = e.parent;
      if (!n)
        return e;
      e = n;
    }
  }
  replaceChildren(e, n, r = Rp) {
    this.markDirty();
    for (let i = e; i < n; i++) {
      let o = this.children[i];
      o.parent == this && r.indexOf(o) < 0 && o.destroy();
    }
    r.length < 250 ? this.children.splice(e, n - e, ...r) : this.children = [].concat(this.children.slice(0, e), r, this.children.slice(n));
    for (let i = 0; i < r.length; i++)
      r[i].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new b6(this.children, e, this.children.length);
  }
  childPos(e, n = 1) {
    return this.childCursor().findPos(e, n);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, n, r, i, o, s) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
ft.prototype.breakAfter = 0;
function Y5(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class b6 {
  constructor(e, n, r) {
    this.children = e, this.pos = n, this.i = r, this.off = 0;
  }
  findPos(e, n = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (n > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let r = this.children[--this.i];
      this.pos -= r.length + r.breakAfter;
    }
  }
}
function w6(t, e, n, r, i, o, s, a, c) {
  let { children: h } = t, f = h.length ? h[e] : null, d = o.length ? o[o.length - 1] : null, p = d ? d.breakAfter : s;
  if (!(e == r && f && !s && !p && o.length < 2 && f.merge(n, i, o.length ? d : null, n == 0, a, c))) {
    if (r < h.length) {
      let v = h[r];
      v && (i < v.length || v.breakAfter && d?.breakAfter) ? (e == r && (v = v.split(i), i = 0), !p && d && v.merge(0, i, d, !0, 0, c) ? o[o.length - 1] = v : ((i || v.children.length && !v.children[0].length) && v.merge(0, i, null, !1, 0, c), o.push(v))) : v?.breakAfter && (d ? d.breakAfter = 1 : s = 1), r++;
    }
    for (f && (f.breakAfter = s, n > 0 && (!s && o.length && f.merge(n, f.length, o[0], !1, a, 0) ? f.breakAfter = o.shift().breakAfter : (n < f.length || f.children.length && f.children[f.children.length - 1].length == 0) && f.merge(n, f.length, null, !1, a, 0), e++)); e < r && o.length; )
      if (h[r - 1].become(o[o.length - 1]))
        r--, o.pop(), c = o.length ? 0 : a;
      else if (h[e].become(o[0]))
        e++, o.shift(), a = o.length ? 0 : c;
      else
        break;
    !o.length && e && r < h.length && !h[e - 1].breakAfter && h[r].merge(0, 0, h[e - 1], !1, a, c) && e--, (e < r || o.length) && t.replaceChildren(e, r, o);
  }
}
function x6(t, e, n, r, i, o) {
  let s = t.childCursor(), { i: a, off: c } = s.findPos(n, 1), { i: h, off: f } = s.findPos(e, -1), d = e - n;
  for (let p of r)
    d += p.length;
  t.length += d, w6(t, h, f, a, c, r, 0, i, o);
}
let xn = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, E1 = typeof document < "u" ? document : { documentElement: { style: {} } };
const O1 = /* @__PURE__ */ /Edge\/(\d+)/.exec(xn.userAgent), y6 = /* @__PURE__ */ /MSIE \d/.test(xn.userAgent), D1 = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(xn.userAgent), jh = !!(y6 || D1 || O1), j5 = !jh && /* @__PURE__ */ /gecko\/(\d+)/i.test(xn.userAgent), u0 = !jh && /* @__PURE__ */ /Chrome\/(\d+)/.exec(xn.userAgent), sW = "webkitFontSmoothing" in E1.documentElement.style, C6 = !jh && /* @__PURE__ */ /Apple Computer/.test(xn.vendor), X5 = C6 && (/* @__PURE__ */ /Mobile\/\w+/.test(xn.userAgent) || xn.maxTouchPoints > 2);
var me = {
  mac: X5 || /* @__PURE__ */ /Mac/.test(xn.platform),
  windows: /* @__PURE__ */ /Win/.test(xn.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(xn.platform),
  ie: jh,
  ie_version: y6 ? E1.documentMode || 6 : D1 ? +D1[1] : O1 ? +O1[1] : 0,
  gecko: j5,
  gecko_version: j5 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(xn.userAgent) || [0, 0])[1] : 0,
  chrome: !!u0,
  chrome_version: u0 ? +u0[1] : 0,
  ios: X5,
  android: /* @__PURE__ */ /Android\b/.test(xn.userAgent),
  safari: C6,
  webkit_version: sW ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(xn.userAgent) || [0, 0])[1] : 0,
  tabSize: E1.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const aW = 256;
class hr extends ft {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, n) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (n && n.node == this.dom && (n.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, n, r) {
    return this.flags & 8 || r && (!(r instanceof hr) || this.length - (n - e) + r.length > aW || r.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (r ? r.text : "") + this.text.slice(n), this.markDirty(), !0);
  }
  split(e) {
    let n = new hr(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), n.flags |= this.flags & 8, n;
  }
  localPosFromDOM(e, n) {
    return e == this.dom ? n : n ? this.text.length : 0;
  }
  domAtPos(e) {
    return new rn(this.dom, e);
  }
  domBoundsAround(e, n, r) {
    return { from: r, to: r + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, n) {
    return lW(this.dom, e, n);
  }
}
class gi extends ft {
  constructor(e, n = [], r = 0) {
    super(), this.mark = e, this.children = n, this.length = r;
    for (let i of n)
      i.setParent(this);
  }
  setAttrs(e) {
    if (g6(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let n in this.mark.attrs)
        e.setAttribute(n, this.mark.attrs[n]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, n) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, n);
  }
  merge(e, n, r, i, o, s) {
    return r && (!(r instanceof gi && r.mark.eq(this.mark)) || e && o <= 0 || n < this.length && s <= 0) ? !1 : (x6(this, e, n, r ? r.children.slice() : [], o - 1, s - 1), this.markDirty(), !0);
  }
  split(e) {
    let n = [], r = 0, i = -1, o = 0;
    for (let a of this.children) {
      let c = r + a.length;
      c > e && n.push(r < e ? a.split(e - r) : a), i < 0 && r >= e && (i = o), r = c, o++;
    }
    let s = this.length - e;
    return this.length = e, i > -1 && (this.children.length = i, this.markDirty()), new gi(this.mark, n, s);
  }
  domAtPos(e) {
    return $6(this, e);
  }
  coordsAt(e, n) {
    return A6(this, e, n);
  }
}
function lW(t, e, n) {
  let r = t.nodeValue.length;
  e > r && (e = r);
  let i = e, o = e, s = 0;
  e == 0 && n < 0 || e == r && n >= 0 ? me.chrome || me.gecko || (e ? (i--, s = 1) : o < r && (o++, s = -1)) : n < 0 ? i-- : o < r && o++;
  let a = Oo(t, i, o).getClientRects();
  if (!a.length)
    return null;
  let c = a[(s ? s < 0 : n >= 0) ? 0 : a.length - 1];
  return me.safari && !s && c.width == 0 && (c = Array.prototype.find.call(a, (h) => h.width) || c), s ? kl(c, s < 0) : c || null;
}
class Ni extends ft {
  static create(e, n, r) {
    return new Ni(e, n, r);
  }
  constructor(e, n, r) {
    super(), this.widget = e, this.length = n, this.side = r, this.prevWidget = null;
  }
  split(e) {
    let n = Ni.create(this.widget, this.length - e, this.side);
    return this.length -= e, n;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, n, r, i, o, s) {
    return r && (!(r instanceof Ni) || !this.widget.compare(r.widget) || e > 0 && o <= 0 || n < this.length && s <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - n), !0);
  }
  become(e) {
    return e instanceof Ni && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return nt.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: n } = e, r = n && n.state.doc, i = this.posAtStart;
    return r ? r.slice(i, i + this.length) : nt.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? rn.before(this.dom) : rn.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, n) {
    let r = this.widget.coordsAt(this.dom, e, n);
    if (r)
      return r;
    let i = this.dom.getClientRects(), o = null;
    if (!i.length)
      return null;
    let s = this.side ? this.side < 0 : e > 0;
    for (let a = s ? i.length - 1 : 0; o = i[a], !(e > 0 ? a == 0 : a == i.length - 1 || o.top < o.bottom); a += s ? -1 : 1)
      ;
    return kl(o, !s);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Vs extends ft {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof Vs && e.side == this.side;
  }
  split() {
    return new Vs(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? rn.before(this.dom) : rn.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return nt.empty;
  }
  get isHidden() {
    return !0;
  }
}
hr.prototype.children = Ni.prototype.children = Vs.prototype.children = Rp;
function $6(t, e) {
  let n = t.dom, { children: r } = t, i = 0;
  for (let o = 0; i < r.length; i++) {
    let s = r[i], a = o + s.length;
    if (!(a == o && s.getSide() <= 0)) {
      if (e > o && e < a && s.dom.parentNode == n)
        return s.domAtPos(e - o);
      if (e <= o)
        break;
      o = a;
    }
  }
  for (let o = i; o > 0; o--) {
    let s = r[o - 1];
    if (s.dom.parentNode == n)
      return s.domAtPos(s.length);
  }
  for (let o = i; o < r.length; o++) {
    let s = r[o];
    if (s.dom.parentNode == n)
      return s.domAtPos(0);
  }
  return new rn(n, 0);
}
function S6(t, e, n) {
  let r, { children: i } = t;
  n > 0 && e instanceof gi && i.length && (r = i[i.length - 1]) instanceof gi && r.mark.eq(e.mark) ? S6(r, e.children[0], n - 1) : (i.push(e), e.setParent(t)), t.length += e.length;
}
function A6(t, e, n) {
  let r = null, i = -1, o = null, s = -1;
  function a(h, f) {
    for (let d = 0, p = 0; d < h.children.length && p <= f; d++) {
      let v = h.children[d], w = p + v.length;
      w >= f && (v.children.length ? a(v, f - p) : (!o || o.isHidden && (n > 0 || uW(o, v))) && (w > f || p == w && v.getSide() > 0) ? (o = v, s = f - p) : (p < f || p == w && v.getSide() < 0 && !v.isHidden) && (r = v, i = f - p)), p = w;
    }
  }
  a(t, e);
  let c = (n < 0 ? r : o) || r || o;
  return c ? c.coordsAt(Math.max(0, c == r ? i : s), n) : cW(t);
}
function cW(t) {
  let e = t.dom.lastChild;
  if (!e)
    return t.dom.getBoundingClientRect();
  let n = Fs(e);
  return n[n.length - 1] || null;
}
function uW(t, e) {
  let n = t.coordsAt(0, 1), r = e.coordsAt(0, 1);
  return n && r && r.top < n.bottom;
}
function I1(t, e) {
  for (let n in t)
    n == "class" && e.class ? e.class += " " + t.class : n == "style" && e.style ? e.style += ";" + t.style : e[n] = t[n];
  return e;
}
const Z5 = /* @__PURE__ */ Object.create(null);
function Zu(t, e, n) {
  if (t == e)
    return !0;
  t || (t = Z5), e || (e = Z5);
  let r = Object.keys(t), i = Object.keys(e);
  if (r.length - (n && r.indexOf(n) > -1 ? 1 : 0) != i.length - (n && i.indexOf(n) > -1 ? 1 : 0))
    return !1;
  for (let o of r)
    if (o != n && (i.indexOf(o) == -1 || t[o] !== e[o]))
      return !1;
  return !0;
}
function _1(t, e, n) {
  let r = !1;
  if (e)
    for (let i in e)
      n && i in n || (r = !0, i == "style" ? t.style.cssText = "" : t.removeAttribute(i));
  if (n)
    for (let i in n)
      e && e[i] == n[i] || (r = !0, i == "style" ? t.style.cssText = n[i] : t.setAttribute(i, n[i]));
  return r;
}
function hW(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n = 0; n < t.attributes.length; n++) {
    let r = t.attributes[n];
    e[r.name] = r.value;
  }
  return e;
}
class xi {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, n) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, n, r) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var fn = /* @__PURE__ */ function(t) {
  return t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t;
}(fn || (fn = {}));
class Se extends Ro {
  constructor(e, n, r, i) {
    super(), this.startSide = e, this.endSide = n, this.widget = r, this.spec = i;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new Ml(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let n = Math.max(-1e4, Math.min(1e4, e.side || 0)), r = !!e.block;
    return n += r && !e.inlineOrder ? n > 0 ? 3e8 : -4e8 : n > 0 ? 1e8 : -1e8, new qi(e, n, n, r, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let n = !!e.block, r, i;
    if (e.isBlockGap)
      r = -5e8, i = 4e8;
    else {
      let { start: o, end: s } = k6(e, n);
      r = (o ? n ? -3e8 : -1 : 5e8) - 1, i = (s ? n ? 2e8 : 1 : -6e8) + 1;
    }
    return new qi(e, r, i, n, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new Tl(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, n = !1) {
    return tt.of(e, n);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
Se.none = tt.empty;
class Ml extends Se {
  constructor(e) {
    let { start: n, end: r } = k6(e);
    super(n ? -1 : 5e8, r ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var n, r;
    return this == e || e instanceof Ml && this.tagName == e.tagName && (this.class || ((n = this.attrs) === null || n === void 0 ? void 0 : n.class)) == (e.class || ((r = e.attrs) === null || r === void 0 ? void 0 : r.class)) && Zu(this.attrs, e.attrs, "class");
  }
  range(e, n = e) {
    if (e >= n)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, n);
  }
}
Ml.prototype.point = !1;
class Tl extends Se {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof Tl && this.spec.class == e.spec.class && Zu(this.spec.attributes, e.spec.attributes);
  }
  range(e, n = e) {
    if (n != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, n);
  }
}
Tl.prototype.mapMode = hn.TrackBefore;
Tl.prototype.point = !0;
class qi extends Se {
  constructor(e, n, r, i, o, s) {
    super(n, r, o, e), this.block = i, this.isReplace = s, this.mapMode = i ? n <= 0 ? hn.TrackBefore : hn.TrackAfter : hn.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? fn.WidgetRange : this.startSide <= 0 ? fn.WidgetBefore : fn.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof qi && fW(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, n = e) {
    if (this.isReplace && (e > n || e == n && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && n != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, n);
  }
}
qi.prototype.point = !0;
function k6(t, e = !1) {
  let { inclusiveStart: n, inclusiveEnd: r } = t;
  return n == null && (n = t.inclusive), r == null && (r = t.inclusive), { start: n ?? e, end: r ?? e };
}
function fW(t, e) {
  return t == e || !!(t && e && t.compare(e));
}
function $u(t, e, n, r = 0) {
  let i = n.length - 1;
  i >= 0 && n[i] + r >= t ? n[i] = Math.max(n[i], e) : n.push(t, e);
}
class Et extends ft {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, n, r, i, o, s) {
    if (r) {
      if (!(r instanceof Et))
        return !1;
      this.dom || r.transferDOM(this);
    }
    return i && this.setDeco(r ? r.attrs : null), x6(this, e, n, r ? r.children.slice() : [], o, s), !0;
  }
  split(e) {
    let n = new Et();
    if (n.breakAfter = this.breakAfter, this.length == 0)
      return n;
    let { i: r, off: i } = this.childPos(e);
    i && (n.append(this.children[r].split(i), 0), this.children[r].merge(i, this.children[r].length, null, !1, 0, 0), r++);
    for (let o = r; o < this.children.length; o++)
      n.append(this.children[o], 0);
    for (; r > 0 && this.children[r - 1].length == 0; )
      this.children[--r].destroy();
    return this.children.length = r, this.markDirty(), this.length = e, n;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    Zu(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, n) {
    S6(this, e, n);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let n = e.spec.attributes, r = e.spec.class;
    n && (this.attrs = I1(n, this.attrs || {})), r && (this.attrs = I1({ class: r }, this.attrs || {}));
  }
  domAtPos(e) {
    return $6(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, n) {
    var r;
    this.dom ? this.flags & 4 && (g6(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (_1(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, n);
    let i = this.dom.lastChild;
    for (; i && ft.get(i) instanceof gi; )
      i = i.lastChild;
    if (!i || !this.length || i.nodeName != "BR" && ((r = ft.get(i)) === null || r === void 0 ? void 0 : r.isEditable) == !1 && (!me.ios || !this.children.some((o) => o instanceof hr))) {
      let o = document.createElement("BR");
      o.cmIgnore = !0, this.dom.appendChild(o);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, n;
    for (let r of this.children) {
      if (!(r instanceof hr) || /[^ -~]/.test(r.text))
        return null;
      let i = Fs(r.dom);
      if (i.length != 1)
        return null;
      e += i[0].width, n = i[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: n
    } : null;
  }
  coordsAt(e, n) {
    let r = A6(this, e, n);
    if (!this.children.length && r && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState, o = r.bottom - r.top;
      if (Math.abs(o - i.lineHeight) < 2 && i.textHeight < o) {
        let s = (o - i.textHeight) / 2;
        return { top: r.top + s, bottom: r.bottom - s, left: r.left, right: r.left };
      }
    }
    return r;
  }
  become(e) {
    return e instanceof Et && this.children.length == 0 && e.children.length == 0 && Zu(this.attrs, e.attrs) && this.breakAfter == e.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(e, n) {
    for (let r = 0, i = 0; r < e.children.length; r++) {
      let o = e.children[r], s = i + o.length;
      if (s >= n) {
        if (o instanceof Et)
          return o;
        if (s > n)
          break;
      }
      i = s + o.breakAfter;
    }
    return null;
  }
}
class ci extends ft {
  constructor(e, n, r) {
    super(), this.widget = e, this.length = n, this.deco = r, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, n, r, i, o, s) {
    return r && (!(r instanceof ci) || !this.widget.compare(r.widget) || e > 0 && o <= 0 || n < this.length && s <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - n), !0);
  }
  domAtPos(e) {
    return e == 0 ? rn.before(this.dom) : rn.after(this.dom, e == this.length);
  }
  split(e) {
    let n = this.length - e;
    this.length = e;
    let r = new ci(this.widget, n, this.deco);
    return r.breakAfter = this.breakAfter, r;
  }
  get children() {
    return Rp;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : nt.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof ci && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, n) {
    let r = this.widget.coordsAt(this.dom, e, n);
    return r || (this.widget instanceof L1 ? null : kl(this.dom.getBoundingClientRect(), this.length ? e == 0 : n <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: n, endSide: r } = this.deco;
    return n == r ? !1 : e < 0 ? n < 0 : r > 0;
  }
}
class L1 extends xi {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
class Pa {
  constructor(e, n, r, i) {
    this.doc = e, this.pos = n, this.end = r, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = n;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof ci && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new Et()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Xc(new Vs(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof ci) && this.getLine();
  }
  buildText(e, n, r) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: o, lineBreak: s, done: a } = this.cursor.next(this.skip);
        if (this.skip = 0, a)
          throw new Error("Ran out of text content when drawing inline views");
        if (s) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = o, this.textOff = 0;
      }
      let i = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(n.slice(n.length - r)), this.getLine().append(Xc(new hr(this.text.slice(this.textOff, this.textOff + i)), n), r), this.atCursorPos = !0, this.textOff += i, e -= i, r = 0;
    }
  }
  span(e, n, r, i) {
    this.buildText(n - e, r, i), this.pos = n, this.openStart < 0 && (this.openStart = i);
  }
  point(e, n, r, i, o, s) {
    if (this.disallowBlockEffectsFor[s] && r instanceof qi) {
      if (r.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (n > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let a = n - e;
    if (r instanceof qi)
      if (r.block)
        r.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new ci(r.widget || Hs.block, a, r));
      else {
        let c = Ni.create(r.widget || Hs.inline, a, a ? 0 : r.startSide), h = this.atCursorPos && !c.isEditable && o <= i.length && (e < n || r.startSide > 0), f = !c.isEditable && (e < n || o > i.length || r.startSide <= 0), d = this.getLine();
        this.pendingBuffer == 2 && !h && !c.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), h && (d.append(Xc(new Vs(1), i), o), o = i.length + Math.max(0, o - i.length)), d.append(Xc(c, i), o), this.atCursorPos = f, this.pendingBuffer = f ? e < n || o > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(r);
    a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = n), this.openStart < 0 && (this.openStart = o);
  }
  static build(e, n, r, i, o) {
    let s = new Pa(e, n, r, o);
    return s.openEnd = tt.spans(i, n, r, s), s.openStart < 0 && (s.openStart = s.openEnd), s.finish(s.openEnd), s;
  }
}
function Xc(t, e) {
  for (let n of e)
    t = new gi(n, [t], t.length);
  return t;
}
class Hs extends xi {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
Hs.inline = /* @__PURE__ */ new Hs("span");
Hs.block = /* @__PURE__ */ new Hs("div");
var mt = /* @__PURE__ */ function(t) {
  return t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t;
}(mt || (mt = {}));
const Do = mt.LTR, Ep = mt.RTL;
function M6(t) {
  let e = [];
  for (let n = 0; n < t.length; n++)
    e.push(1 << +t[n]);
  return e;
}
const dW = /* @__PURE__ */ M6("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), gW = /* @__PURE__ */ M6("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), B1 = /* @__PURE__ */ Object.create(null), Cr = [];
for (let t of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ t.charCodeAt(0), n = /* @__PURE__ */ t.charCodeAt(1);
  B1[e] = n, B1[n] = -e;
}
function T6(t) {
  return t <= 247 ? dW[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? gW[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1;
}
const pW = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Fi {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? Ep : Do;
  }
  /**
  @internal
  */
  constructor(e, n, r) {
    this.from = e, this.to = n, this.level = r;
  }
  /**
  @internal
  */
  side(e, n) {
    return this.dir == n == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, n) {
    return e == (this.dir == n);
  }
  /**
  @internal
  */
  static find(e, n, r, i) {
    let o = -1;
    for (let s = 0; s < e.length; s++) {
      let a = e[s];
      if (a.from <= n && a.to >= n) {
        if (a.level == r)
          return s;
        (o < 0 || (i != 0 ? i < 0 ? a.from < n : a.to > n : e[o].level > a.level)) && (o = s);
      }
    }
    if (o < 0)
      throw new RangeError("Index out of range");
    return o;
  }
}
function R6(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++) {
    let r = t[n], i = e[n];
    if (r.from != i.from || r.to != i.to || r.direction != i.direction || !R6(r.inner, i.inner))
      return !1;
  }
  return !0;
}
const ht = [];
function mW(t, e, n, r, i) {
  for (let o = 0; o <= r.length; o++) {
    let s = o ? r[o - 1].to : e, a = o < r.length ? r[o].from : n, c = o ? 256 : i;
    for (let h = s, f = c, d = c; h < a; h++) {
      let p = T6(t.charCodeAt(h));
      p == 512 ? p = f : p == 8 && d == 4 && (p = 16), ht[h] = p == 4 ? 2 : p, p & 7 && (d = p), f = p;
    }
    for (let h = s, f = c, d = c; h < a; h++) {
      let p = ht[h];
      if (p == 128)
        h < a - 1 && f == ht[h + 1] && f & 24 ? p = ht[h] = f : ht[h] = 256;
      else if (p == 64) {
        let v = h + 1;
        for (; v < a && ht[v] == 64; )
          v++;
        let w = h && f == 8 || v < n && ht[v] == 8 ? d == 1 ? 1 : 8 : 256;
        for (let b = h; b < v; b++)
          ht[b] = w;
        h = v - 1;
      } else p == 8 && d == 1 && (ht[h] = 1);
      f = p, p & 7 && (d = p);
    }
  }
}
function vW(t, e, n, r, i) {
  let o = i == 1 ? 2 : 1;
  for (let s = 0, a = 0, c = 0; s <= r.length; s++) {
    let h = s ? r[s - 1].to : e, f = s < r.length ? r[s].from : n;
    for (let d = h, p, v, w; d < f; d++)
      if (v = B1[p = t.charCodeAt(d)])
        if (v < 0) {
          for (let b = a - 3; b >= 0; b -= 3)
            if (Cr[b + 1] == -v) {
              let y = Cr[b + 2], $ = y & 2 ? i : y & 4 ? y & 1 ? o : i : 0;
              $ && (ht[d] = ht[Cr[b]] = $), a = b;
              break;
            }
        } else {
          if (Cr.length == 189)
            break;
          Cr[a++] = d, Cr[a++] = p, Cr[a++] = c;
        }
      else if ((w = ht[d]) == 2 || w == 1) {
        let b = w == i;
        c = b ? 0 : 1;
        for (let y = a - 3; y >= 0; y -= 3) {
          let $ = Cr[y + 2];
          if ($ & 2)
            break;
          if (b)
            Cr[y + 2] |= 2;
          else {
            if ($ & 4)
              break;
            Cr[y + 2] |= 4;
          }
        }
      }
  }
}
function bW(t, e, n, r) {
  for (let i = 0, o = r; i <= n.length; i++) {
    let s = i ? n[i - 1].to : t, a = i < n.length ? n[i].from : e;
    for (let c = s; c < a; ) {
      let h = ht[c];
      if (h == 256) {
        let f = c + 1;
        for (; ; )
          if (f == a) {
            if (i == n.length)
              break;
            f = n[i++].to, a = i < n.length ? n[i].from : e;
          } else if (ht[f] == 256)
            f++;
          else
            break;
        let d = o == 1, p = (f < e ? ht[f] : r) == 1, v = d == p ? d ? 1 : 2 : r;
        for (let w = f, b = i, y = b ? n[b - 1].to : t; w > c; )
          w == y && (w = n[--b].from, y = b ? n[b - 1].to : t), ht[--w] = v;
        c = f;
      } else
        o = h, c++;
    }
  }
}
function N1(t, e, n, r, i, o, s) {
  let a = r % 2 ? 2 : 1;
  if (r % 2 == i % 2)
    for (let c = e, h = 0; c < n; ) {
      let f = !0, d = !1;
      if (h == o.length || c < o[h].from) {
        let b = ht[c];
        b != a && (f = !1, d = b == 16);
      }
      let p = !f && a == 1 ? [] : null, v = f ? r : r + 1, w = c;
      e: for (; ; )
        if (h < o.length && w == o[h].from) {
          if (d)
            break e;
          let b = o[h];
          if (!f)
            for (let y = b.to, $ = h + 1; ; ) {
              if (y == n)
                break e;
              if ($ < o.length && o[$].from == y)
                y = o[$++].to;
              else {
                if (ht[y] == a)
                  break e;
                break;
              }
            }
          if (h++, p)
            p.push(b);
          else {
            b.from > c && s.push(new Fi(c, b.from, v));
            let y = b.direction == Do != !(v % 2);
            F1(t, y ? r + 1 : r, i, b.inner, b.from, b.to, s), c = b.to;
          }
          w = b.to;
        } else {
          if (w == n || (f ? ht[w] != a : ht[w] == a))
            break;
          w++;
        }
      p ? N1(t, c, w, r + 1, i, p, s) : c < w && s.push(new Fi(c, w, v)), c = w;
    }
  else
    for (let c = n, h = o.length; c > e; ) {
      let f = !0, d = !1;
      if (!h || c > o[h - 1].to) {
        let b = ht[c - 1];
        b != a && (f = !1, d = b == 16);
      }
      let p = !f && a == 1 ? [] : null, v = f ? r : r + 1, w = c;
      e: for (; ; )
        if (h && w == o[h - 1].to) {
          if (d)
            break e;
          let b = o[--h];
          if (!f)
            for (let y = b.from, $ = h; ; ) {
              if (y == e)
                break e;
              if ($ && o[$ - 1].to == y)
                y = o[--$].from;
              else {
                if (ht[y - 1] == a)
                  break e;
                break;
              }
            }
          if (p)
            p.push(b);
          else {
            b.to < c && s.push(new Fi(b.to, c, v));
            let y = b.direction == Do != !(v % 2);
            F1(t, y ? r + 1 : r, i, b.inner, b.from, b.to, s), c = b.from;
          }
          w = b.from;
        } else {
          if (w == e || (f ? ht[w - 1] != a : ht[w - 1] == a))
            break;
          w--;
        }
      p ? N1(t, w, c, r + 1, i, p, s) : w < c && s.push(new Fi(w, c, v)), c = w;
    }
}
function F1(t, e, n, r, i, o, s) {
  let a = e % 2 ? 2 : 1;
  mW(t, i, o, r, a), vW(t, i, o, r, a), bW(i, o, r, a), N1(t, i, o, e, n, r, s);
}
function wW(t, e, n) {
  if (!t)
    return [new Fi(0, 0, e == Ep ? 1 : 0)];
  if (e == Do && !n.length && !pW.test(t))
    return E6(t.length);
  if (n.length)
    for (; t.length > ht.length; )
      ht[ht.length] = 256;
  let r = [], i = e == Do ? 0 : 1;
  return F1(t, i, i, n, 0, t.length, r), r;
}
function E6(t) {
  return [new Fi(0, t, 0)];
}
let O6 = "";
function xW(t, e, n, r, i) {
  var o;
  let s = r.head - t.from, a = Fi.find(e, s, (o = r.bidiLevel) !== null && o !== void 0 ? o : -1, r.assoc), c = e[a], h = c.side(i, n);
  if (s == h) {
    let p = a += i ? 1 : -1;
    if (p < 0 || p >= e.length)
      return null;
    c = e[a = p], s = c.side(!i, n), h = c.side(i, n);
  }
  let f = Zt(t.text, s, c.forward(i, n));
  (f < c.from || f > c.to) && (f = h), O6 = t.text.slice(Math.min(s, f), Math.max(s, f));
  let d = a == (i ? e.length - 1 : 0) ? null : e[a + (i ? 1 : -1)];
  return d && f == h && d.level + (i ? 0 : 1) < c.level ? J.cursor(d.side(!i, n) + t.from, d.forward(i, n) ? 1 : -1, d.level) : J.cursor(f + t.from, c.forward(i, n) ? -1 : 1, c.level);
}
function yW(t, e, n) {
  for (let r = e; r < n; r++) {
    let i = T6(t.charCodeAt(r));
    if (i == 1)
      return Do;
    if (i == 2 || i == 4)
      return Ep;
  }
  return Do;
}
const D6 = /* @__PURE__ */ pe.define(), I6 = /* @__PURE__ */ pe.define(), _6 = /* @__PURE__ */ pe.define(), L6 = /* @__PURE__ */ pe.define(), V1 = /* @__PURE__ */ pe.define(), B6 = /* @__PURE__ */ pe.define(), N6 = /* @__PURE__ */ pe.define(), Op = /* @__PURE__ */ pe.define(), Dp = /* @__PURE__ */ pe.define(), F6 = /* @__PURE__ */ pe.define({
  combine: (t) => t.some((e) => e)
}), V6 = /* @__PURE__ */ pe.define({
  combine: (t) => t.some((e) => e)
}), H6 = /* @__PURE__ */ pe.define();
class Ms {
  constructor(e, n = "nearest", r = "nearest", i = 5, o = 5, s = !1) {
    this.range = e, this.y = n, this.x = r, this.yMargin = i, this.xMargin = o, this.isSnapshot = s;
  }
  map(e) {
    return e.empty ? this : new Ms(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new Ms(J.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const Zc = /* @__PURE__ */ Ne.define({ map: (t, e) => t.map(e) }), P6 = /* @__PURE__ */ Ne.define();
function Cn(t, e, n) {
  let r = t.facet(L6);
  r.length ? r[0](e) : window.onerror && window.onerror(String(e), n, void 0, void 0, e) || (n ? console.error(n + ":", e) : console.error(e));
}
const oi = /* @__PURE__ */ pe.define({ combine: (t) => t.length ? t[0] : !0 });
let CW = 0;
const Da = /* @__PURE__ */ pe.define();
class Mt {
  constructor(e, n, r, i, o) {
    this.id = e, this.create = n, this.domEventHandlers = r, this.domEventObservers = i, this.extension = o(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, n) {
    const { eventHandlers: r, eventObservers: i, provide: o, decorations: s } = n || {};
    return new Mt(CW++, e, r, i, (a) => {
      let c = [Da.of(a)];
      return s && c.push(rl.of((h) => {
        let f = h.plugin(a);
        return f ? s(f) : Se.none;
      })), o && c.push(o(a)), c;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, n) {
    return Mt.define((r) => new e(r), n);
  }
}
class h0 {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let n = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(n);
          } catch (r) {
            if (Cn(n.state, r, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (n) {
        Cn(e.state, n, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var n;
    if (!((n = this.value) === null || n === void 0) && n.destroy)
      try {
        this.value.destroy();
      } catch (r) {
        Cn(e.state, r, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const W6 = /* @__PURE__ */ pe.define(), Ip = /* @__PURE__ */ pe.define(), rl = /* @__PURE__ */ pe.define(), z6 = /* @__PURE__ */ pe.define(), _p = /* @__PURE__ */ pe.define(), U6 = /* @__PURE__ */ pe.define();
function Q5(t, e) {
  let n = t.state.facet(U6);
  if (!n.length)
    return n;
  let r = n.map((o) => o instanceof Function ? o(t) : o), i = [];
  return tt.spans(r, e.from, e.to, {
    point() {
    },
    span(o, s, a, c) {
      let h = o - e.from, f = s - e.from, d = i;
      for (let p = a.length - 1; p >= 0; p--, c--) {
        let v = a[p].spec.bidiIsolate, w;
        if (v == null && (v = yW(e.text, h, f)), c > 0 && d.length && (w = d[d.length - 1]).to == h && w.direction == v)
          w.to = f, d = w.inner;
        else {
          let b = { from: h, to: f, direction: v, inner: [] };
          d.push(b), d = b.inner;
        }
      }
    }
  }), i;
}
const K6 = /* @__PURE__ */ pe.define();
function Lp(t) {
  let e = 0, n = 0, r = 0, i = 0;
  for (let o of t.state.facet(K6)) {
    let s = o(t);
    s && (s.left != null && (e = Math.max(e, s.left)), s.right != null && (n = Math.max(n, s.right)), s.top != null && (r = Math.max(r, s.top)), s.bottom != null && (i = Math.max(i, s.bottom)));
  }
  return { left: e, right: n, top: r, bottom: i };
}
const Ia = /* @__PURE__ */ pe.define();
class Zn {
  constructor(e, n, r, i) {
    this.fromA = e, this.toA = n, this.fromB = r, this.toB = i;
  }
  join(e) {
    return new Zn(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let n = e.length, r = this;
    for (; n > 0; n--) {
      let i = e[n - 1];
      if (!(i.fromA > r.toA)) {
        if (i.toA < r.fromA)
          break;
        r = r.join(i), e.splice(n - 1, 1);
      }
    }
    return e.splice(n, 0, r), e;
  }
  static extendWithRanges(e, n) {
    if (n.length == 0)
      return e;
    let r = [];
    for (let i = 0, o = 0, s = 0, a = 0; ; i++) {
      let c = i == e.length ? null : e[i], h = s - a, f = c ? c.fromB : 1e9;
      for (; o < n.length && n[o] < f; ) {
        let d = n[o], p = n[o + 1], v = Math.max(a, d), w = Math.min(f, p);
        if (v <= w && new Zn(v + h, w + h, v, w).addToSet(r), p > f)
          break;
        o += 2;
      }
      if (!c)
        return r;
      new Zn(c.fromA, c.toA, c.fromB, c.toB).addToSet(r), s = c.toA, a = c.toB;
    }
  }
}
class Qu {
  constructor(e, n, r) {
    this.view = e, this.state = n, this.transactions = r, this.flags = 0, this.startState = e.state, this.changes = Nt.empty(this.startState.doc.length);
    for (let o of r)
      this.changes = this.changes.compose(o.changes);
    let i = [];
    this.changes.iterChangedRanges((o, s, a, c) => i.push(new Zn(o, s, a, c))), this.changedRanges = i;
  }
  /**
  @internal
  */
  static create(e, n, r) {
    return new Qu(e, n, r);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class J5 extends ft {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = Se.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new Et()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Zn(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var n;
    let r = e.changedRanges;
    this.minWidth > 0 && r.length && (r.every(({ fromA: h, toA: f }) => f < this.minWidthFrom || h > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
    let i = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((n = this.domChanged) === null || n === void 0) && n.newSel ? i = this.domChanged.newSel.head : !RW(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
    let o = i > -1 ? SW(this.view, e.changes, i) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: h, to: f } = this.hasComposition;
      r = new Zn(h, f, e.changes.mapPos(h, -1), e.changes.mapPos(f, 1)).addToSet(r.slice());
    }
    this.hasComposition = o ? { from: o.range.fromB, to: o.range.toB } : null, (me.ie || me.chrome) && !o && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let s = this.decorations, a = this.updateDeco(), c = MW(s, a, e.changes);
    return r = Zn.extendWithRanges(r, c), !(this.flags & 7) && r.length == 0 ? !1 : (this.updateInner(r, e.startState.doc.length, o), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, n, r) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, n, r);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let s = me.chrome || me.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, s), this.flags &= -8, s && (s.written || i.selectionRange.focusNode != s.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (s) => s.flags &= -9
      /* ViewFlag.Composition */
    );
    let o = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let s of this.children)
        s instanceof ci && s.widget instanceof L1 && o.push(s.dom);
    i.updateGaps(o);
  }
  updateChildren(e, n, r) {
    let i = r ? r.range.addToSet(e.slice()) : e, o = this.childCursor(n);
    for (let s = i.length - 1; ; s--) {
      let a = s >= 0 ? i[s] : null;
      if (!a)
        break;
      let { fromA: c, toA: h, fromB: f, toB: d } = a, p, v, w, b;
      if (r && r.range.fromB < d && r.range.toB > f) {
        let T = Pa.build(this.view.state.doc, f, r.range.fromB, this.decorations, this.dynamicDecorationMap), R = Pa.build(this.view.state.doc, r.range.toB, d, this.decorations, this.dynamicDecorationMap);
        v = T.breakAtStart, w = T.openStart, b = R.openEnd;
        let _ = this.compositionView(r);
        R.breakAtStart ? _.breakAfter = 1 : R.content.length && _.merge(_.length, _.length, R.content[0], !1, R.openStart, 0) && (_.breakAfter = R.content[0].breakAfter, R.content.shift()), T.content.length && _.merge(0, 0, T.content[T.content.length - 1], !0, 0, T.openEnd) && T.content.pop(), p = T.content.concat(_).concat(R.content);
      } else
        ({ content: p, breakAtStart: v, openStart: w, openEnd: b } = Pa.build(this.view.state.doc, f, d, this.decorations, this.dynamicDecorationMap));
      let { i: y, off: $ } = o.findPos(h, 1), { i: A, off: k } = o.findPos(c, -1);
      w6(this, A, k, y, $, p, v, w, b);
    }
    r && this.fixCompositionDOM(r);
  }
  updateEditContextFormatting(e) {
    this.editContextFormatting = this.editContextFormatting.map(e.changes);
    for (let n of e.transactions)
      for (let r of n.effects)
        r.is(P6) && (this.editContextFormatting = r.value);
  }
  compositionView(e) {
    let n = new hr(e.text.nodeValue);
    n.flags |= 8;
    for (let { deco: i } of e.marks)
      n = new gi(i, [n], n.length);
    let r = new Et();
    return r.append(n, 0), r;
  }
  fixCompositionDOM(e) {
    let n = (o, s) => {
      s.flags |= 8 | (s.children.some(
        (c) => c.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(s);
      let a = ft.get(o);
      a && a != s && (a.dom = null), s.setDOM(o);
    }, r = this.childPos(e.range.fromB, 1), i = this.children[r.i];
    n(e.line, i);
    for (let o = e.marks.length - 1; o >= -1; o--)
      r = i.childPos(r.off, 1), i = i.children[r.i], n(o >= 0 ? e.marks[o].node : e.text, i);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, n = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let r = this.view.root.activeElement, i = r == this.dom, o = !i && !(this.view.state.facet(oi) || this.dom.tabIndex > -1) && Cu(this.dom, this.view.observer.selectionRange) && !(r && this.dom.contains(r));
    if (!(i || n || o))
      return;
    let s = this.forceSelection;
    this.forceSelection = !1;
    let a = this.view.state.selection.main, c = this.moveToLine(this.domAtPos(a.anchor)), h = a.empty ? c : this.moveToLine(this.domAtPos(a.head));
    if (me.gecko && a.empty && !this.hasComposition && $W(c)) {
      let d = document.createTextNode("");
      this.view.observer.ignore(() => c.node.insertBefore(d, c.node.childNodes[c.offset] || null)), c = h = new rn(d, 0), s = !0;
    }
    let f = this.view.observer.selectionRange;
    (s || !f.focusNode || (!Ha(c.node, c.offset, f.anchorNode, f.anchorOffset) || !Ha(h.node, h.offset, f.focusNode, f.focusOffset)) && !this.suppressWidgetCursorChange(f, a)) && (this.view.observer.ignore(() => {
      me.android && me.chrome && this.dom.contains(f.focusNode) && TW(f.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let d = nl(this.view.root);
      if (d) if (a.empty) {
        if (me.gecko) {
          let p = AW(c.node, c.offset);
          if (p && p != 3) {
            let v = (p == 1 ? m6 : v6)(c.node, c.offset);
            v && (c = new rn(v.node, v.offset));
          }
        }
        d.collapse(c.node, c.offset), a.bidiLevel != null && d.caretBidiLevel !== void 0 && (d.caretBidiLevel = a.bidiLevel);
      } else if (d.extend) {
        d.collapse(c.node, c.offset);
        try {
          d.extend(h.node, h.offset);
        } catch {
        }
      } else {
        let p = document.createRange();
        a.anchor > a.head && ([c, h] = [h, c]), p.setEnd(h.node, h.offset), p.setStart(c.node, c.offset), d.removeAllRanges(), d.addRange(p);
      }
      o && this.view.root.activeElement == this.dom && (this.dom.blur(), r && r.focus());
    }), this.view.observer.setSelectionRange(c, h)), this.impreciseAnchor = c.precise ? null : new rn(f.anchorNode, f.anchorOffset), this.impreciseHead = h.precise ? null : new rn(f.focusNode, f.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, n) {
    return this.hasComposition && n.empty && Ha(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == n.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, n = e.state.selection.main, r = nl(e.root), { anchorNode: i, anchorOffset: o } = e.observer.selectionRange;
    if (!r || !n.empty || !n.assoc || !r.modify)
      return;
    let s = Et.find(this, n.head);
    if (!s)
      return;
    let a = s.posAtStart;
    if (n.head == a || n.head == a + s.length)
      return;
    let c = this.coordsAt(n.head, -1), h = this.coordsAt(n.head, 1);
    if (!c || !h || c.bottom > h.top)
      return;
    let f = this.domAtPos(n.head + n.assoc);
    r.collapse(f.node, f.offset), r.modify("move", n.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let d = e.observer.selectionRange;
    e.docView.posFromDOM(d.anchorNode, d.anchorOffset) != n.from && r.collapse(i, o);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let n = this.dom, r;
    if (e.node != n)
      return e;
    for (let i = e.offset; !r && i < n.childNodes.length; i++) {
      let o = ft.get(n.childNodes[i]);
      o instanceof Et && (r = o.domAtPos(0));
    }
    for (let i = e.offset - 1; !r && i >= 0; i--) {
      let o = ft.get(n.childNodes[i]);
      o instanceof Et && (r = o.domAtPos(o.length));
    }
    return r ? new rn(r.node, r.offset, !0) : e;
  }
  nearest(e) {
    for (let n = e; n; ) {
      let r = ft.get(n);
      if (r && r.rootView == this)
        return r;
      n = n.parentNode;
    }
    return null;
  }
  posFromDOM(e, n) {
    let r = this.nearest(e);
    if (!r)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return r.localPosFromDOM(e, n) + r.posAtStart;
  }
  domAtPos(e) {
    let { i: n, off: r } = this.childCursor().findPos(e, -1);
    for (; n < this.children.length - 1; ) {
      let i = this.children[n];
      if (r < i.length || i instanceof Et)
        break;
      n++, r = 0;
    }
    return this.children[n].domAtPos(r);
  }
  coordsAt(e, n) {
    let r = null, i = 0;
    for (let o = this.length, s = this.children.length - 1; s >= 0; s--) {
      let a = this.children[s], c = o - a.breakAfter, h = c - a.length;
      if (c < e)
        break;
      if (h <= e && (h < e || a.covers(-1)) && (c > e || a.covers(1)) && (!r || a instanceof Et && !(r instanceof Et && n >= 0)))
        r = a, i = h;
      else if (r && h == e && c == e && a instanceof ci && Math.abs(n) < 2) {
        if (a.deco.startSide < 0)
          break;
        s && (r = null);
      }
      o = h;
    }
    return r ? r.coordsAt(e - i, n) : null;
  }
  coordsForChar(e) {
    let { i: n, off: r } = this.childPos(e, 1), i = this.children[n];
    if (!(i instanceof Et))
      return null;
    for (; i.children.length; ) {
      let { i: a, off: c } = i.childPos(r, 1);
      for (; ; a++) {
        if (a == i.children.length)
          return null;
        if ((i = i.children[a]).length)
          break;
      }
      r = c;
    }
    if (!(i instanceof hr))
      return null;
    let o = Zt(i.text, r);
    if (o == r)
      return null;
    let s = Oo(i.dom, r, o).getClientRects();
    for (let a = 0; a < s.length; a++) {
      let c = s[a];
      if (a == s.length - 1 || c.top < c.bottom && c.left < c.right)
        return c;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let n = [], { from: r, to: i } = e, o = this.view.contentDOM.clientWidth, s = o > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, c = this.view.textDirection == mt.LTR;
    for (let h = 0, f = 0; f < this.children.length; f++) {
      let d = this.children[f], p = h + d.length;
      if (p > i)
        break;
      if (h >= r) {
        let v = d.dom.getBoundingClientRect();
        if (n.push(v.height), s) {
          let w = d.dom.lastChild, b = w ? Fs(w) : [];
          if (b.length) {
            let y = b[b.length - 1], $ = c ? y.right - v.left : v.right - y.left;
            $ > a && (a = $, this.minWidth = o, this.minWidthFrom = h, this.minWidthTo = p);
          }
        }
      }
      h = p + d.breakAfter;
    }
    return n;
  }
  textDirectionAt(e) {
    let { i: n } = this.childPos(e, 1);
    return getComputedStyle(this.children[n].dom).direction == "rtl" ? mt.RTL : mt.LTR;
  }
  measureTextSize() {
    for (let o of this.children)
      if (o instanceof Et) {
        let s = o.measureTextSize();
        if (s)
          return s;
      }
    let e = document.createElement("div"), n, r, i;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let o = Fs(e.firstChild)[0];
      n = e.getBoundingClientRect().height, r = o ? o.width / 27 : 7, i = o ? o.height : n, e.remove();
    }), { lineHeight: n, charWidth: r, textHeight: i };
  }
  childCursor(e = this.length) {
    let n = this.children.length;
    return n && (e -= this.children[--n].length), new b6(this.children, e, n);
  }
  computeBlockGapDeco() {
    let e = [], n = this.view.viewState;
    for (let r = 0, i = 0; ; i++) {
      let o = i == n.viewports.length ? null : n.viewports[i], s = o ? o.from - 1 : this.length;
      if (s > r) {
        let a = (n.lineBlockAt(s).bottom - n.lineBlockAt(r).top) / this.view.scaleY;
        e.push(Se.replace({
          widget: new L1(a),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(r, s));
      }
      if (!o)
        break;
      r = o.to + 1;
    }
    return Se.set(e);
  }
  updateDeco() {
    let e = 1, n = this.view.state.facet(rl).map((o) => (this.dynamicDecorationMap[e++] = typeof o == "function") ? o(this.view) : o), r = !1, i = this.view.state.facet(z6).map((o, s) => {
      let a = typeof o == "function";
      return a && (r = !0), a ? o(this.view) : o;
    });
    for (i.length && (this.dynamicDecorationMap[e++] = r, n.push(tt.join(i))), this.decorations = [
      this.editContextFormatting,
      ...n,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; e < this.decorations.length; )
      this.dynamicDecorationMap[e++] = !1;
    return this.decorations;
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let h = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = h.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    for (let h of this.view.state.facet(H6))
      try {
        if (h(this.view, e.range, e))
          return !0;
      } catch (f) {
        Cn(this.view.state, f, "scroll handler");
      }
    let { range: n } = e, r = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1), i;
    if (!r)
      return;
    !n.empty && (i = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) && (r = {
      left: Math.min(r.left, i.left),
      top: Math.min(r.top, i.top),
      right: Math.max(r.right, i.right),
      bottom: Math.max(r.bottom, i.bottom)
    });
    let o = Lp(this.view), s = {
      left: r.left - o.left,
      top: r.top - o.top,
      right: r.right + o.right,
      bottom: r.bottom + o.bottom
    }, { offsetWidth: a, offsetHeight: c } = this.view.scrollDOM;
    tW(this.view.scrollDOM, s, n.head < n.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, a), -a), Math.max(Math.min(e.yMargin, c), -c), this.view.textDirection == mt.LTR);
  }
}
function $W(t) {
  return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false");
}
function q6(t, e) {
  let n = t.observer.selectionRange;
  if (!n.focusNode)
    return null;
  let r = m6(n.focusNode, n.focusOffset), i = v6(n.focusNode, n.focusOffset), o = r || i;
  if (i && r && i.node != r.node) {
    let a = ft.get(i.node);
    if (!a || a instanceof hr && a.text != i.node.nodeValue)
      o = i;
    else if (t.docView.lastCompositionAfterCursor) {
      let c = ft.get(r.node);
      !c || c instanceof hr && c.text != r.node.nodeValue || (o = i);
    }
  }
  if (t.docView.lastCompositionAfterCursor = o != r, !o)
    return null;
  let s = e - o.offset;
  return { from: s, to: s + o.node.nodeValue.length, node: o.node };
}
function SW(t, e, n) {
  let r = q6(t, n);
  if (!r)
    return null;
  let { node: i, from: o, to: s } = r, a = i.nodeValue;
  if (/[\n\r]/.test(a) || t.state.doc.sliceString(r.from, r.to) != a)
    return null;
  let c = e.invertedDesc, h = new Zn(c.mapPos(o), c.mapPos(s), o, s), f = [];
  for (let d = i.parentNode; ; d = d.parentNode) {
    let p = ft.get(d);
    if (p instanceof gi)
      f.push({ node: d, deco: p.mark });
    else {
      if (p instanceof Et || d.nodeName == "DIV" && d.parentNode == t.contentDOM)
        return { range: h, text: i, marks: f, line: d };
      if (d != t.contentDOM)
        f.push({ node: d, deco: new Ml({
          inclusive: !0,
          attributes: hW(d),
          tagName: d.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function AW(t, e) {
  return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let kW = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, n) {
    $u(e, n, this.changes);
  }
  comparePoint(e, n) {
    $u(e, n, this.changes);
  }
  boundChange(e) {
    $u(e, e, this.changes);
  }
};
function MW(t, e, n) {
  let r = new kW();
  return tt.compare(t, e, n, r), r.changes;
}
function TW(t, e) {
  for (let n = t; n && n != e; n = n.assignedSlot || n.parentNode)
    if (n.nodeType == 1 && n.contentEditable == "false")
      return !0;
  return !1;
}
function RW(t, e) {
  let n = !1;
  return e && t.iterChangedRanges((r, i) => {
    r < e.to && i > e.from && (n = !0);
  }), n;
}
function EW(t, e, n = 1) {
  let r = t.charCategorizer(e), i = t.doc.lineAt(e), o = e - i.from;
  if (i.length == 0)
    return J.cursor(e);
  o == 0 ? n = 1 : o == i.length && (n = -1);
  let s = o, a = o;
  n < 0 ? s = Zt(i.text, o, !1) : a = Zt(i.text, o);
  let c = r(i.text.slice(s, a));
  for (; s > 0; ) {
    let h = Zt(i.text, s, !1);
    if (r(i.text.slice(h, s)) != c)
      break;
    s = h;
  }
  for (; a < i.length; ) {
    let h = Zt(i.text, a);
    if (r(i.text.slice(a, h)) != c)
      break;
    a = h;
  }
  return J.range(s + i.from, a + i.from);
}
function OW(t, e) {
  return e.left > t ? e.left - t : Math.max(0, t - e.right);
}
function DW(t, e) {
  return e.top > t ? e.top - t : Math.max(0, t - e.bottom);
}
function f0(t, e) {
  return t.top < e.bottom - 1 && t.bottom > e.top + 1;
}
function eb(t, e) {
  return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t;
}
function tb(t, e) {
  return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t;
}
function H1(t, e, n) {
  let r, i, o, s, a = !1, c, h, f, d;
  for (let w = t.firstChild; w; w = w.nextSibling) {
    let b = Fs(w);
    for (let y = 0; y < b.length; y++) {
      let $ = b[y];
      i && f0(i, $) && ($ = eb(tb($, i.bottom), i.top));
      let A = OW(e, $), k = DW(n, $);
      if (A == 0 && k == 0)
        return w.nodeType == 3 ? nb(w, e, n) : H1(w, e, n);
      if (!r || s > k || s == k && o > A) {
        r = w, i = $, o = A, s = k;
        let T = k ? n < $.top ? -1 : 1 : A ? e < $.left ? -1 : 1 : 0;
        a = !T || (T > 0 ? y < b.length - 1 : y > 0);
      }
      A == 0 ? n > $.bottom && (!f || f.bottom < $.bottom) ? (c = w, f = $) : n < $.top && (!d || d.top > $.top) && (h = w, d = $) : f && f0(f, $) ? f = tb(f, $.bottom) : d && f0(d, $) && (d = eb(d, $.top));
    }
  }
  if (f && f.bottom >= n ? (r = c, i = f) : d && d.top <= n && (r = h, i = d), !r)
    return { node: t, offset: 0 };
  let p = Math.max(i.left, Math.min(i.right, e));
  if (r.nodeType == 3)
    return nb(r, p, n);
  if (a && r.contentEditable != "false")
    return H1(r, p, n);
  let v = Array.prototype.indexOf.call(t.childNodes, r) + (e >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: t, offset: v };
}
function nb(t, e, n) {
  let r = t.nodeValue.length, i = -1, o = 1e9, s = 0;
  for (let a = 0; a < r; a++) {
    let c = Oo(t, a, a + 1).getClientRects();
    for (let h = 0; h < c.length; h++) {
      let f = c[h];
      if (f.top == f.bottom)
        continue;
      s || (s = e - f.left);
      let d = (f.top > n ? f.top - n : n - f.bottom) - 1;
      if (f.left - 1 <= e && f.right + 1 >= e && d < o) {
        let p = e >= (f.left + f.right) / 2, v = p;
        if ((me.chrome || me.gecko) && Oo(t, a).getBoundingClientRect().left == f.right && (v = !p), d <= 0)
          return { node: t, offset: a + (v ? 1 : 0) };
        i = a + (v ? 1 : 0), o = d;
      }
    }
  }
  return { node: t, offset: i > -1 ? i : s > 0 ? t.nodeValue.length : 0 };
}
function G6(t, e, n, r = -1) {
  var i, o;
  let s = t.contentDOM.getBoundingClientRect(), a = s.top + t.viewState.paddingTop, c, { docHeight: h } = t.viewState, { x: f, y: d } = e, p = d - a;
  if (p < 0)
    return 0;
  if (p > h)
    return t.state.doc.length;
  for (let T = t.viewState.heightOracle.textHeight / 2, R = !1; c = t.elementAtHeight(p), c.type != fn.Text; )
    for (; p = r > 0 ? c.bottom + T : c.top - T, !(p >= 0 && p <= h); ) {
      if (R)
        return n ? null : 0;
      R = !0, r = -r;
    }
  d = a + p;
  let v = c.from;
  if (v < t.viewport.from)
    return t.viewport.from == 0 ? 0 : n ? null : rb(t, s, c, f, d);
  if (v > t.viewport.to)
    return t.viewport.to == t.state.doc.length ? t.state.doc.length : n ? null : rb(t, s, c, f, d);
  let w = t.dom.ownerDocument, b = t.root.elementFromPoint ? t.root : w, y = b.elementFromPoint(f, d);
  y && !t.contentDOM.contains(y) && (y = null), y || (f = Math.max(s.left + 1, Math.min(s.right - 1, f)), y = b.elementFromPoint(f, d), y && !t.contentDOM.contains(y) && (y = null));
  let $, A = -1;
  if (y && ((i = t.docView.nearest(y)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
    if (w.caretPositionFromPoint) {
      let T = w.caretPositionFromPoint(f, d);
      T && ({ offsetNode: $, offset: A } = T);
    } else if (w.caretRangeFromPoint) {
      let T = w.caretRangeFromPoint(f, d);
      T && ({ startContainer: $, startOffset: A } = T, (!t.contentDOM.contains($) || me.safari && IW($, A, f) || me.chrome && _W($, A, f)) && ($ = void 0));
    }
    $ && (A = Math.min(_r($), A));
  }
  if (!$ || !t.docView.dom.contains($)) {
    let T = Et.find(t.docView, v);
    if (!T)
      return p > c.top + c.height / 2 ? c.to : c.from;
    ({ node: $, offset: A } = H1(T.dom, f, d));
  }
  let k = t.docView.nearest($);
  if (!k)
    return null;
  if (k.isWidget && ((o = k.dom) === null || o === void 0 ? void 0 : o.nodeType) == 1) {
    let T = k.dom.getBoundingClientRect();
    return e.y < T.top || e.y <= T.bottom && e.x <= (T.left + T.right) / 2 ? k.posAtStart : k.posAtEnd;
  } else
    return k.localPosFromDOM($, A) + k.posAtStart;
}
function rb(t, e, n, r, i) {
  let o = Math.round((r - e.left) * t.defaultCharacterWidth);
  if (t.lineWrapping && n.height > t.defaultLineHeight * 1.5) {
    let a = t.viewState.heightOracle.textHeight, c = Math.floor((i - n.top - (t.defaultLineHeight - a) * 0.5) / a);
    o += c * t.viewState.heightOracle.lineLength;
  }
  let s = t.state.sliceDoc(n.from, n.to);
  return n.from + k1(s, o, t.state.tabSize);
}
function IW(t, e, n) {
  let r;
  if (t.nodeType != 3 || e != (r = t.nodeValue.length))
    return !1;
  for (let i = t.nextSibling; i; i = i.nextSibling)
    if (i.nodeType != 1 || i.nodeName != "BR")
      return !1;
  return Oo(t, r - 1, r).getBoundingClientRect().left > n;
}
function _W(t, e, n) {
  if (e != 0)
    return !1;
  for (let i = t; ; ) {
    let o = i.parentNode;
    if (!o || o.nodeType != 1 || o.firstChild != i)
      return !1;
    if (o.classList.contains("cm-line"))
      break;
    i = o;
  }
  let r = t.nodeType == 1 ? t.getBoundingClientRect() : Oo(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
  return n - r.left > 5;
}
function P1(t, e, n) {
  let r = t.lineBlockAt(e);
  if (Array.isArray(r.type)) {
    let i;
    for (let o of r.type) {
      if (o.from > e)
        break;
      if (!(o.to < e)) {
        if (o.from < e && o.to > e)
          return o;
        (!i || o.type == fn.Text && (i.type != o.type || (n < 0 ? o.from < e : o.to > e))) && (i = o);
      }
    }
    return i || r;
  }
  return r;
}
function LW(t, e, n, r) {
  let i = P1(t, e.head, e.assoc || -1), o = !r || i.type != fn.Text || !(t.lineWrapping || i.widgetLineBreaks) ? null : t.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
  if (o) {
    let s = t.dom.getBoundingClientRect(), a = t.textDirectionAt(i.from), c = t.posAtCoords({
      x: n == (a == mt.LTR) ? s.right - 1 : s.left + 1,
      y: (o.top + o.bottom) / 2
    });
    if (c != null)
      return J.cursor(c, n ? -1 : 1);
  }
  return J.cursor(n ? i.to : i.from, n ? -1 : 1);
}
function ib(t, e, n, r) {
  let i = t.state.doc.lineAt(e.head), o = t.bidiSpans(i), s = t.textDirectionAt(i.from);
  for (let a = e, c = null; ; ) {
    let h = xW(i, o, s, a, n), f = O6;
    if (!h) {
      if (i.number == (n ? t.state.doc.lines : 1))
        return a;
      f = `
`, i = t.state.doc.line(i.number + (n ? 1 : -1)), o = t.bidiSpans(i), h = t.visualLineSide(i, !n);
    }
    if (c) {
      if (!c(f))
        return a;
    } else {
      if (!r)
        return h;
      c = r(f);
    }
    a = h;
  }
}
function BW(t, e, n) {
  let r = t.state.charCategorizer(e), i = r(n);
  return (o) => {
    let s = r(o);
    return i == bt.Space && (i = s), i == s;
  };
}
function NW(t, e, n, r) {
  let i = e.head, o = n ? 1 : -1;
  if (i == (n ? t.state.doc.length : 0))
    return J.cursor(i, e.assoc);
  let s = e.goalColumn, a, c = t.contentDOM.getBoundingClientRect(), h = t.coordsAtPos(i, e.assoc || -1), f = t.documentTop;
  if (h)
    s == null && (s = h.left - c.left), a = o < 0 ? h.top : h.bottom;
  else {
    let v = t.viewState.lineBlockAt(i);
    s == null && (s = Math.min(c.right - c.left, t.defaultCharacterWidth * (i - v.from))), a = (o < 0 ? v.top : v.bottom) + f;
  }
  let d = c.left + s, p = r ?? t.viewState.heightOracle.textHeight >> 1;
  for (let v = 0; ; v += 10) {
    let w = a + (p + v) * o, b = G6(t, { x: d, y: w }, !1, o);
    if (w < c.top || w > c.bottom || (o < 0 ? b < i : b > i)) {
      let y = t.docView.coordsForChar(b), $ = !y || w < y.top ? -1 : 1;
      return J.cursor(b, $, void 0, s);
    }
  }
}
function Su(t, e, n) {
  for (; ; ) {
    let r = 0;
    for (let i of t)
      i.between(e - 1, e + 1, (o, s, a) => {
        if (e > o && e < s) {
          let c = r || n || (e - o < s - e ? -1 : 1);
          e = c < 0 ? o : s, r = c;
        }
      });
    if (!r)
      return e;
  }
}
function d0(t, e, n) {
  let r = Su(t.state.facet(_p).map((i) => i(t)), n.from, e.head > n.from ? -1 : 1);
  return r == n.from ? n : J.cursor(r, r < n.from ? 1 : -1);
}
const _a = "￿";
class FW {
  constructor(e, n) {
    this.points = e, this.text = "", this.lineSeparator = n.facet(et.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += _a;
  }
  readRange(e, n) {
    if (!e)
      return this;
    let r = e.parentNode;
    for (let i = e; ; ) {
      this.findPointBefore(r, i);
      let o = this.text.length;
      this.readNode(i);
      let s = i.nextSibling;
      if (s == n)
        break;
      let a = ft.get(i), c = ft.get(s);
      (a && c ? a.breakAfter : (a ? a.breakAfter : Xu(i)) || Xu(s) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > o) && this.lineBreak(), i = s;
    }
    return this.findPointBefore(r, n), this;
  }
  readTextNode(e) {
    let n = e.nodeValue;
    for (let r of this.points)
      r.node == e && (r.pos = this.text.length + Math.min(r.offset, n.length));
    for (let r = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let o = -1, s = 1, a;
      if (this.lineSeparator ? (o = n.indexOf(this.lineSeparator, r), s = this.lineSeparator.length) : (a = i.exec(n)) && (o = a.index, s = a[0].length), this.append(n.slice(r, o < 0 ? n.length : o)), o < 0)
        break;
      if (this.lineBreak(), s > 1)
        for (let c of this.points)
          c.node == e && c.pos > this.text.length && (c.pos -= s - 1);
      r = o + s;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let n = ft.get(e), r = n && n.overrideDOMText;
    if (r != null) {
      this.findPointInside(e, r.length);
      for (let i = r.iter(); !i.next().done; )
        i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, n) {
    for (let r of this.points)
      r.node == e && e.childNodes[r.offset] == n && (r.pos = this.text.length);
  }
  findPointInside(e, n) {
    for (let r of this.points)
      (e.nodeType == 3 ? r.node == e : e.contains(r.node)) && (r.pos = this.text.length + (VW(e, r.node, r.offset) ? n : 0));
  }
}
function VW(t, e, n) {
  for (; ; ) {
    if (!e || n < _r(e))
      return !1;
    if (e == t)
      return !0;
    n = Eo(e) + 1, e = e.parentNode;
  }
}
class ob {
  constructor(e, n) {
    this.node = e, this.offset = n, this.pos = -1;
  }
}
class HW {
  constructor(e, n, r, i) {
    this.typeOver = i, this.bounds = null, this.text = "", this.domChanged = n > -1;
    let { impreciseHead: o, impreciseAnchor: s } = e.docView;
    if (e.state.readOnly && n > -1)
      this.newSel = null;
    else if (n > -1 && (this.bounds = e.docView.domBoundsAround(n, r, 0))) {
      let a = o || s ? [] : zW(e), c = new FW(a, e.state);
      c.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = c.text, this.newSel = UW(a, this.bounds.from);
    } else {
      let a = e.observer.selectionRange, c = o && o.node == a.focusNode && o.offset == a.focusOffset || !R1(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset), h = s && s.node == a.anchorNode && s.offset == a.anchorOffset || !R1(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset), f = e.viewport;
      if ((me.ios || me.chrome) && e.state.selection.main.empty && c != h && (f.from > 0 || f.to < e.state.doc.length)) {
        let d = Math.min(c, h), p = Math.max(c, h), v = f.from - d, w = f.to - p;
        (v == 0 || v == 1 || d == 0) && (w == 0 || w == -1 || p == e.state.doc.length) && (c = 0, h = e.state.doc.length);
      }
      this.newSel = J.single(h, c);
    }
  }
}
function Y6(t, e) {
  let n, { newSel: r } = e, i = t.state.selection.main, o = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: s, to: a } = e.bounds, c = i.from, h = null;
    (o === 8 || me.android && e.text.length < a - s) && (c = i.to, h = "end");
    let f = WW(t.state.doc.sliceString(s, a, _a), e.text, c - s, h);
    f && (me.chrome && o == 13 && f.toB == f.from + 2 && e.text.slice(f.from, f.toB) == _a + _a && f.toB--, n = {
      from: s + f.from,
      to: s + f.toA,
      insert: nt.of(e.text.slice(f.from, f.toB).split(_a))
    });
  } else r && (!t.hasFocus && t.state.facet(oi) || r.main.eq(i)) && (r = null);
  if (!n && !r)
    return !1;
  if (!n && e.typeOver && !i.empty && r && r.main.empty ? n = { from: i.from, to: i.to, insert: t.state.doc.slice(i.from, i.to) } : (me.mac || me.android) && n && n.from == n.to && n.from == i.head - 1 && /^\. ?$/.test(n.insert.toString()) && t.contentDOM.getAttribute("autocorrect") == "off" ? (r && n.insert.length == 2 && (r = J.single(r.main.anchor - 1, r.main.head - 1)), n = { from: n.from, to: n.to, insert: nt.of([n.insert.toString().replace(".", " ")]) }) : n && n.from >= i.from && n.to <= i.to && (n.from != i.from || n.to != i.to) && i.to - i.from - (n.to - n.from) <= 4 ? n = {
    from: i.from,
    to: i.to,
    insert: t.state.doc.slice(i.from, n.from).append(n.insert).append(t.state.doc.slice(n.to, i.to))
  } : me.chrome && n && n.from == n.to && n.from == i.head && n.insert.toString() == `
 ` && t.lineWrapping && (r && (r = J.single(r.main.anchor - 1, r.main.head - 1)), n = { from: i.from, to: i.to, insert: nt.of([" "]) }), n)
    return Bp(t, n, r, o);
  if (r && !r.main.eq(i)) {
    let s = !1, a = "select";
    return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == "select" && (s = !0), a = t.inputState.lastSelectionOrigin), t.dispatch({ selection: r, scrollIntoView: s, userEvent: a }), !0;
  } else
    return !1;
}
function Bp(t, e, n, r = -1) {
  if (me.ios && t.inputState.flushIOSKey(e))
    return !0;
  let i = t.state.selection.main;
  if (me.android && (e.to == i.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (e.from == i.from || e.from == i.from - 1 && t.state.sliceDoc(e.from, i.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && ks(t.contentDOM, "Enter", 13) || (e.from == i.from - 1 && e.to == i.to && e.insert.length == 0 || r == 8 && e.insert.length < e.to - e.from && e.to > i.head) && ks(t.contentDOM, "Backspace", 8) || e.from == i.from && e.to == i.to + 1 && e.insert.length == 0 && ks(t.contentDOM, "Delete", 46)))
    return !0;
  let o = e.insert.toString();
  t.inputState.composing >= 0 && t.inputState.composing++;
  let s, a = () => s || (s = PW(t, e, n));
  return t.state.facet(B6).some((c) => c(t, e.from, e.to, o, a)) || t.dispatch(a()), !0;
}
function PW(t, e, n) {
  let r, i = t.state, o = i.selection.main;
  if (e.from >= o.from && e.to <= o.to && e.to - e.from >= (o.to - o.from) / 3 && (!n || n.main.empty && n.main.from == e.from + e.insert.length) && t.inputState.composing < 0) {
    let a = o.from < e.from ? i.sliceDoc(o.from, e.from) : "", c = o.to > e.to ? i.sliceDoc(e.to, o.to) : "";
    r = i.replaceSelection(t.state.toText(a + e.insert.sliceString(0, void 0, t.state.lineBreak) + c));
  } else {
    let a = i.changes(e), c = n && n.main.to <= a.newLength ? n.main : void 0;
    if (i.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= o.to && e.to >= o.to - 10) {
      let h = t.state.sliceDoc(e.from, e.to), f, d = n && q6(t, n.main.head);
      if (d) {
        let w = e.insert.length - (e.to - e.from);
        f = { from: d.from, to: d.to - w };
      } else
        f = t.state.doc.lineAt(o.head);
      let p = o.to - e.to, v = o.to - o.from;
      r = i.changeByRange((w) => {
        if (w.from == o.from && w.to == o.to)
          return { changes: a, range: c || w.map(a) };
        let b = w.to - p, y = b - h.length;
        if (w.to - w.from != v || t.state.sliceDoc(y, b) != h || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        w.to >= f.from && w.from <= f.to)
          return { range: w };
        let $ = i.changes({ from: y, to: b, insert: e.insert }), A = w.to - o.to;
        return {
          changes: $,
          range: c ? J.range(Math.max(0, c.anchor + A), Math.max(0, c.head + A)) : w.map($)
        };
      });
    } else
      r = {
        changes: a,
        selection: c && i.selection.replaceRange(c)
      };
  }
  let s = "input.type";
  return (t.composing || t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50) && (t.inputState.compositionPendingChange = !1, s += ".compose", t.inputState.compositionFirstChange && (s += ".start", t.inputState.compositionFirstChange = !1)), i.update(r, { userEvent: s, scrollIntoView: !0 });
}
function WW(t, e, n, r) {
  let i = Math.min(t.length, e.length), o = 0;
  for (; o < i && t.charCodeAt(o) == e.charCodeAt(o); )
    o++;
  if (o == i && t.length == e.length)
    return null;
  let s = t.length, a = e.length;
  for (; s > 0 && a > 0 && t.charCodeAt(s - 1) == e.charCodeAt(a - 1); )
    s--, a--;
  if (r == "end") {
    let c = Math.max(0, o - Math.min(s, a));
    n -= s + c - o;
  }
  if (s < o && t.length < e.length) {
    let c = n <= o && n >= s ? o - n : 0;
    o -= c, a = o + (a - s), s = o;
  } else if (a < o) {
    let c = n <= o && n >= a ? o - n : 0;
    o -= c, s = o + (s - a), a = o;
  }
  return { from: o, toA: s, toB: a };
}
function zW(t) {
  let e = [];
  if (t.root.activeElement != t.contentDOM)
    return e;
  let { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: o } = t.observer.selectionRange;
  return n && (e.push(new ob(n, r)), (i != n || o != r) && e.push(new ob(i, o))), e;
}
function UW(t, e) {
  if (t.length == 0)
    return null;
  let n = t[0].pos, r = t.length == 2 ? t[1].pos : n;
  return n > -1 && r > -1 ? J.single(n + e, r + e) : null;
}
class KW {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, me.safari && e.contentDOM.addEventListener("input", () => null), me.gecko && az(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !JW(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(e.type, e)) : this.runHandlers(e.type, e));
  }
  runHandlers(e, n) {
    let r = this.handlers[e];
    if (r) {
      for (let i of r.observers)
        i(this.view, n);
      for (let i of r.handlers) {
        if (n.defaultPrevented)
          break;
        if (i(this.view, n)) {
          n.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let n = qW(e), r = this.handlers, i = this.view.contentDOM;
    for (let o in n)
      if (o != "scroll") {
        let s = !n[o].handlers.length, a = r[o];
        a && s != !a.handlers.length && (i.removeEventListener(o, this.handleEvent), a = null), a || i.addEventListener(o, this.handleEvent, { passive: s });
      }
    for (let o in r)
      o != "scroll" && !n[o] && i.removeEventListener(o, this.handleEvent);
    this.handlers = n;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && e.keyCode != 27 && X6.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), me.android && me.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let n;
    return me.ios && !e.synthetic && !e.altKey && !e.metaKey && ((n = j6.find((r) => r.keyCode == e.keyCode)) && !e.ctrlKey || GW.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = n || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(e) {
    let n = this.pendingIOSKey;
    return !n || n.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, ks(this.view.contentDOM, n.key, n.keyCode, n instanceof KeyboardEvent ? n : void 0));
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : me.safari && !me.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function sb(t, e) {
  return (n, r) => {
    try {
      return e.call(t, r, n);
    } catch (i) {
      Cn(n.state, i);
    }
  };
}
function qW(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(r) {
    return e[r] || (e[r] = { observers: [], handlers: [] });
  }
  for (let r of t) {
    let i = r.spec;
    if (i && i.domEventHandlers)
      for (let o in i.domEventHandlers) {
        let s = i.domEventHandlers[o];
        s && n(o).handlers.push(sb(r.value, s));
      }
    if (i && i.domEventObservers)
      for (let o in i.domEventObservers) {
        let s = i.domEventObservers[o];
        s && n(o).observers.push(sb(r.value, s));
      }
  }
  for (let r in fr)
    n(r).handlers.push(fr[r]);
  for (let r in Qn)
    n(r).observers.push(Qn[r]);
  return e;
}
const j6 = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], GW = "dthko", X6 = [16, 17, 18, 20, 91, 92, 224, 225], Qc = 6;
function Jc(t) {
  return Math.max(0, t) * 0.7 + 8;
}
function YW(t, e) {
  return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));
}
class jW {
  constructor(e, n, r, i) {
    this.view = e, this.startEvent = n, this.style = r, this.mustSelect = i, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = n, this.scrollParents = nW(e.contentDOM), this.atoms = e.state.facet(_p).map((s) => s(e));
    let o = e.contentDOM.ownerDocument;
    o.addEventListener("mousemove", this.move = this.move.bind(this)), o.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = n.shiftKey, this.multiple = e.state.facet(et.allowMultipleSelections) && XW(e, n), this.dragging = QW(e, n) && J6(n) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && YW(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let n = 0, r = 0, i = 0, o = 0, s = this.view.win.innerWidth, a = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: i, right: s } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: o, bottom: a } = this.scrollParents.y.getBoundingClientRect());
    let c = Lp(this.view);
    e.clientX - c.left <= i + Qc ? n = -Jc(i - e.clientX) : e.clientX + c.right >= s - Qc && (n = Jc(e.clientX - s)), e.clientY - c.top <= o + Qc ? r = -Jc(o - e.clientY) : e.clientY + c.bottom >= a - Qc && (r = Jc(e.clientY - a)), this.setScrollSpeed(n, r);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, n) {
    this.scrollSpeed = { x: e, y: n }, e || n ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: e, y: n } = this.scrollSpeed;
    e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), n && this.scrollParents.y && (this.scrollParents.y.scrollTop += n, n = 0), (e || n) && this.view.win.scrollBy(e, n), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let n = null;
    for (let r = 0; r < e.ranges.length; r++) {
      let i = e.ranges[r], o = null;
      if (i.empty) {
        let s = Su(this.atoms, i.from, 0);
        s != i.from && (o = J.cursor(s, -1));
      } else {
        let s = Su(this.atoms, i.from, -1), a = Su(this.atoms, i.to, 1);
        (s != i.from || a != i.to) && (o = J.range(i.from == i.anchor ? s : a, i.from == i.head ? s : a));
      }
      o && (n || (n = e.ranges.slice()), n[r] = o);
    }
    return n ? J.create(n, e.mainIndex) : e;
  }
  select(e) {
    let { view: n } = this, r = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !r.eq(n.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: r,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.transactions.some((n) => n.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function XW(t, e) {
  let n = t.state.facet(D6);
  return n.length ? n[0](e) : me.mac ? e.metaKey : e.ctrlKey;
}
function ZW(t, e) {
  let n = t.state.facet(I6);
  return n.length ? n[0](e) : me.mac ? !e.altKey : !e.ctrlKey;
}
function QW(t, e) {
  let { main: n } = t.state.selection;
  if (n.empty)
    return !1;
  let r = nl(t.root);
  if (!r || r.rangeCount == 0)
    return !0;
  let i = r.getRangeAt(0).getClientRects();
  for (let o = 0; o < i.length; o++) {
    let s = i[o];
    if (s.left <= e.clientX && s.right >= e.clientX && s.top <= e.clientY && s.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function JW(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let n = e.target, r; n != t.contentDOM; n = n.parentNode)
    if (!n || n.nodeType == 11 || (r = ft.get(n)) && r.ignoreEvent(e))
      return !1;
  return !0;
}
const fr = /* @__PURE__ */ Object.create(null), Qn = /* @__PURE__ */ Object.create(null), Z6 = me.ie && me.ie_version < 15 || me.ios && me.webkit_version < 604;
function ez(t) {
  let e = t.dom.parentNode;
  if (!e)
    return;
  let n = e.appendChild(document.createElement("textarea"));
  n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.focus(), setTimeout(() => {
    t.focus(), n.remove(), Q6(t, n.value);
  }, 50);
}
function Xh(t, e, n) {
  for (let r of t.facet(e))
    n = r(n, t);
  return n;
}
function Q6(t, e) {
  e = Xh(t.state, Op, e);
  let { state: n } = t, r, i = 1, o = n.toText(e), s = o.lines == n.selection.ranges.length;
  if (W1 != null && n.selection.ranges.every((c) => c.empty) && W1 == o.toString()) {
    let c = -1;
    r = n.changeByRange((h) => {
      let f = n.doc.lineAt(h.from);
      if (f.from == c)
        return { range: h };
      c = f.from;
      let d = n.toText((s ? o.line(i++).text : e) + n.lineBreak);
      return {
        changes: { from: f.from, insert: d },
        range: J.cursor(h.from + d.length)
      };
    });
  } else s ? r = n.changeByRange((c) => {
    let h = o.line(i++);
    return {
      changes: { from: c.from, to: c.to, insert: h.text },
      range: J.cursor(c.from + h.length)
    };
  }) : r = n.replaceSelection(o);
  t.dispatch(r, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
Qn.scroll = (t) => {
  t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft;
};
fr.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"), e.keyCode == 27 && t.inputState.tabFocusMode != 0 && (t.inputState.tabFocusMode = Date.now() + 2e3), !1);
Qn.touchstart = (t, e) => {
  t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer");
};
Qn.touchmove = (t) => {
  t.inputState.setSelectionOrigin("select.pointer");
};
fr.mousedown = (t, e) => {
  if (t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let n = null;
  for (let r of t.state.facet(_6))
    if (n = r(t, e), n)
      break;
  if (!n && e.button == 0 && (n = rz(t, e)), n) {
    let r = !t.hasFocus;
    t.inputState.startMouseSelection(new jW(t, e, n, r)), r && t.observer.ignore(() => {
      d6(t.contentDOM);
      let o = t.root.activeElement;
      o && !o.contains(t.contentDOM) && o.blur();
    });
    let i = t.inputState.mouseSelection;
    if (i)
      return i.start(e), i.dragging === !1;
  }
  return !1;
};
function ab(t, e, n, r) {
  if (r == 1)
    return J.cursor(e, n);
  if (r == 2)
    return EW(t.state, e, n);
  {
    let i = Et.find(t.docView, e), o = t.state.doc.lineAt(i ? i.posAtEnd : e), s = i ? i.posAtStart : o.from, a = i ? i.posAtEnd : o.to;
    return a < t.state.doc.length && a == o.to && a++, J.range(s, a);
  }
}
let lb = (t, e, n) => e >= n.top && e <= n.bottom && t >= n.left && t <= n.right;
function tz(t, e, n, r) {
  let i = Et.find(t.docView, e);
  if (!i)
    return 1;
  let o = e - i.posAtStart;
  if (o == 0)
    return 1;
  if (o == i.length)
    return -1;
  let s = i.coordsAt(o, -1);
  if (s && lb(n, r, s))
    return -1;
  let a = i.coordsAt(o, 1);
  return a && lb(n, r, a) ? 1 : s && s.bottom >= r ? -1 : 1;
}
function cb(t, e) {
  let n = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: n, bias: tz(t, n, e.clientX, e.clientY) };
}
const nz = me.ie && me.ie_version <= 11;
let ub = null, hb = 0, fb = 0;
function J6(t) {
  if (!nz)
    return t.detail;
  let e = ub, n = fb;
  return ub = t, fb = Date.now(), hb = !e || n > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (hb + 1) % 3 : 1;
}
function rz(t, e) {
  let n = cb(t, e), r = J6(e), i = t.state.selection;
  return {
    update(o) {
      o.docChanged && (n.pos = o.changes.mapPos(n.pos), i = i.map(o.changes));
    },
    get(o, s, a) {
      let c = cb(t, o), h, f = ab(t, c.pos, c.bias, r);
      if (n.pos != c.pos && !s) {
        let d = ab(t, n.pos, n.bias, r), p = Math.min(d.from, f.from), v = Math.max(d.to, f.to);
        f = p < f.from ? J.range(p, v) : J.range(v, p);
      }
      return s ? i.replaceRange(i.main.extend(f.from, f.to)) : a && r == 1 && i.ranges.length > 1 && (h = iz(i, c.pos)) ? h : a ? i.addRange(f) : J.create([f]);
    }
  };
}
function iz(t, e) {
  for (let n = 0; n < t.ranges.length; n++) {
    let { from: r, to: i } = t.ranges[n];
    if (r <= e && i >= e)
      return J.create(t.ranges.slice(0, n).concat(t.ranges.slice(n + 1)), t.mainIndex == n ? 0 : t.mainIndex - (t.mainIndex > n ? 1 : 0));
  }
  return null;
}
fr.dragstart = (t, e) => {
  let { selection: { main: n } } = t.state;
  if (e.target.draggable) {
    let i = t.docView.nearest(e.target);
    if (i && i.isWidget) {
      let o = i.posAtStart, s = o + i.length;
      (o >= n.to || s <= n.from) && (n = J.range(o, s));
    }
  }
  let { inputState: r } = t;
  return r.mouseSelection && (r.mouseSelection.dragging = !0), r.draggedContent = n, e.dataTransfer && (e.dataTransfer.setData("Text", Xh(t.state, Dp, t.state.sliceDoc(n.from, n.to))), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
fr.dragend = (t) => (t.inputState.draggedContent = null, !1);
function db(t, e, n, r) {
  if (n = Xh(t.state, Op, n), !n)
    return;
  let i = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: o } = t.inputState, s = r && o && ZW(t, e) ? { from: o.from, to: o.to } : null, a = { from: i, insert: n }, c = t.state.changes(s ? [s, a] : a);
  t.focus(), t.dispatch({
    changes: c,
    selection: { anchor: c.mapPos(i, -1), head: c.mapPos(i, 1) },
    userEvent: s ? "move.drop" : "input.drop"
  }), t.inputState.draggedContent = null;
}
fr.drop = (t, e) => {
  if (!e.dataTransfer)
    return !1;
  if (t.state.readOnly)
    return !0;
  let n = e.dataTransfer.files;
  if (n && n.length) {
    let r = Array(n.length), i = 0, o = () => {
      ++i == n.length && db(t, e, r.filter((s) => s != null).join(t.state.lineBreak), !1);
    };
    for (let s = 0; s < n.length; s++) {
      let a = new FileReader();
      a.onerror = o, a.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (r[s] = a.result), o();
      }, a.readAsText(n[s]);
    }
    return !0;
  } else {
    let r = e.dataTransfer.getData("Text");
    if (r)
      return db(t, e, r, !0), !0;
  }
  return !1;
};
fr.paste = (t, e) => {
  if (t.state.readOnly)
    return !0;
  t.observer.flush();
  let n = Z6 ? null : e.clipboardData;
  return n ? (Q6(t, n.getData("text/plain") || n.getData("text/uri-list")), !0) : (ez(t), !1);
};
function oz(t, e) {
  let n = t.dom.parentNode;
  if (!n)
    return;
  let r = n.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.value = e, r.focus(), r.selectionEnd = e.length, r.selectionStart = 0, setTimeout(() => {
    r.remove(), t.focus();
  }, 50);
}
function sz(t) {
  let e = [], n = [], r = !1;
  for (let i of t.selection.ranges)
    i.empty || (e.push(t.sliceDoc(i.from, i.to)), n.push(i));
  if (!e.length) {
    let i = -1;
    for (let { from: o } of t.selection.ranges) {
      let s = t.doc.lineAt(o);
      s.number > i && (e.push(s.text), n.push({ from: s.from, to: Math.min(t.doc.length, s.to + 1) })), i = s.number;
    }
    r = !0;
  }
  return { text: Xh(t, Dp, e.join(t.lineBreak)), ranges: n, linewise: r };
}
let W1 = null;
fr.copy = fr.cut = (t, e) => {
  let { text: n, ranges: r, linewise: i } = sz(t.state);
  if (!n && !i)
    return !1;
  W1 = i ? n : null, e.type == "cut" && !t.state.readOnly && t.dispatch({
    changes: r,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let o = Z6 ? null : e.clipboardData;
  return o ? (o.clearData(), o.setData("text/plain", n), !0) : (oz(t, n), !1);
};
const e4 = /* @__PURE__ */ Fr.define();
function t4(t, e) {
  let n = [];
  for (let r of t.facet(N6)) {
    let i = r(t, e);
    i && n.push(i);
  }
  return n.length ? t.update({ effects: n, annotations: e4.of(!0) }) : null;
}
function n4(t) {
  setTimeout(() => {
    let e = t.hasFocus;
    if (e != t.inputState.notifiedFocused) {
      let n = t4(t.state, e);
      n ? t.dispatch(n) : t.update([]);
    }
  }, 10);
}
Qn.focus = (t) => {
  t.inputState.lastFocusTime = Date.now(), !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), n4(t);
};
Qn.blur = (t) => {
  t.observer.clearSelectionRange(), n4(t);
};
Qn.compositionstart = Qn.compositionupdate = (t) => {
  t.observer.editContext || (t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = !0), t.inputState.composing < 0 && (t.inputState.composing = 0));
};
Qn.compositionend = (t) => {
  t.observer.editContext || (t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = !0, t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0, t.inputState.compositionFirstChange = null, me.chrome && me.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => {
    t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);
  }, 50));
};
Qn.contextmenu = (t) => {
  t.inputState.lastContextMenu = Date.now();
};
fr.beforeinput = (t, e) => {
  var n, r;
  if (e.inputType == "insertReplacementText" && t.observer.editContext) {
    let o = (n = e.dataTransfer) === null || n === void 0 ? void 0 : n.getData("text/plain"), s = e.getTargetRanges();
    if (o && s.length) {
      let a = s[0], c = t.posAtDOM(a.startContainer, a.startOffset), h = t.posAtDOM(a.endContainer, a.endOffset);
      return Bp(t, { from: c, to: h, insert: t.state.toText(o) }, null), !0;
    }
  }
  let i;
  if (me.chrome && me.android && (i = j6.find((o) => o.inputType == e.inputType)) && (t.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let o = ((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0;
    setTimeout(() => {
      var s;
      (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > o + 10 && t.hasFocus && (t.contentDOM.blur(), t.focus());
    }, 100);
  }
  return me.ios && e.inputType == "deleteContentForward" && t.observer.flushSoon(), me.safari && e.inputType == "insertText" && t.inputState.composing >= 0 && setTimeout(() => Qn.compositionend(t, e), 20), !1;
};
const gb = /* @__PURE__ */ new Set();
function az(t) {
  gb.has(t) || (gb.add(t), t.addEventListener("copy", () => {
  }), t.addEventListener("cut", () => {
  }));
}
const pb = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let Ps = !1;
function mb() {
  Ps = !1;
}
class lz {
  constructor(e) {
    this.lineWrapping = e, this.doc = nt.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(e, n) {
    let r = this.doc.lineAt(n).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (r += Math.max(0, Math.ceil((n - e - r * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * r;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return pb.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let n = !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      i < 0 ? r++ : this.heightSamples[Math.floor(i * 10)] || (n = !0, this.heightSamples[Math.floor(i * 10)] = !0);
    }
    return n;
  }
  refresh(e, n, r, i, o, s) {
    let a = pb.indexOf(e) > -1, c = Math.round(n) != Math.round(this.lineHeight) || this.lineWrapping != a;
    if (this.lineWrapping = a, this.lineHeight = n, this.charWidth = r, this.textHeight = i, this.lineLength = o, c) {
      this.heightSamples = {};
      for (let h = 0; h < s.length; h++) {
        let f = s[h];
        f < 0 ? h++ : this.heightSamples[Math.floor(f * 10)] = !0;
      }
    }
    return c;
  }
}
class cz {
  constructor(e, n) {
    this.from = e, this.heights = n, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class kr {
  /**
  @internal
  */
  constructor(e, n, r, i, o) {
    this.from = e, this.length = n, this.top = r, this.height = i, this._content = o;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? fn.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof qi ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let n = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new kr(this.from, this.length + e.length, this.top, this.height + e.height, n);
  }
}
var pt = /* @__PURE__ */ function(t) {
  return t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t;
}(pt || (pt = {}));
const Au = 1e-3;
class dn {
  constructor(e, n, r = 2) {
    this.length = e, this.height = n, this.flags = r;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e) {
    this.height != e && (Math.abs(this.height - e) > Au && (Ps = !0), this.height = e);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, n, r) {
    return dn.of(r);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, n) {
    n.push(this);
  }
  decomposeRight(e, n) {
    n.push(this);
  }
  applyChanges(e, n, r, i) {
    let o = this, s = r.doc;
    for (let a = i.length - 1; a >= 0; a--) {
      let { fromA: c, toA: h, fromB: f, toB: d } = i[a], p = o.lineAt(c, pt.ByPosNoHeight, r.setDoc(n), 0, 0), v = p.to >= h ? p : o.lineAt(h, pt.ByPosNoHeight, r, 0, 0);
      for (d += v.to - h, h = v.to; a > 0 && p.from <= i[a - 1].toA; )
        c = i[a - 1].fromA, f = i[a - 1].fromB, a--, c < p.from && (p = o.lineAt(c, pt.ByPosNoHeight, r, 0, 0));
      f += p.from - c, c = p.from;
      let w = Np.build(r.setDoc(s), e, f, d);
      o = Ju(o, o.replace(c, h, w));
    }
    return o.updateHeight(r, 0);
  }
  static empty() {
    return new Ln(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let n = 0, r = e.length, i = 0, o = 0;
    for (; ; )
      if (n == r)
        if (i > o * 2) {
          let a = e[n - 1];
          a.break ? e.splice(--n, 1, a.left, null, a.right) : e.splice(--n, 1, a.left, a.right), r += 1 + a.break, i -= a.size;
        } else if (o > i * 2) {
          let a = e[r];
          a.break ? e.splice(r, 1, a.left, null, a.right) : e.splice(r, 1, a.left, a.right), r += 2 + a.break, o -= a.size;
        } else
          break;
      else if (i < o) {
        let a = e[n++];
        a && (i += a.size);
      } else {
        let a = e[--r];
        a && (o += a.size);
      }
    let s = 0;
    return e[n - 1] == null ? (s = 1, n--) : e[n] == null && (s = 1, r++), new uz(dn.of(e.slice(0, n)), s, dn.of(e.slice(r)));
  }
}
function Ju(t, e) {
  return t == e ? t : (t.constructor != e.constructor && (Ps = !0), e);
}
dn.prototype.size = 1;
class r4 extends dn {
  constructor(e, n, r) {
    super(e, n), this.deco = r;
  }
  blockAt(e, n, r, i) {
    return new kr(i, this.length, r, this.height, this.deco || 0);
  }
  lineAt(e, n, r, i, o) {
    return this.blockAt(0, r, i, o);
  }
  forEachLine(e, n, r, i, o, s) {
    e <= o + this.length && n >= o && s(this.blockAt(0, r, i, o));
  }
  updateHeight(e, n = 0, r = !1, i) {
    return i && i.from <= n && i.more && this.setHeight(i.heights[i.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Ln extends r4 {
  constructor(e, n) {
    super(e, n, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, n, r, i) {
    return new kr(i, this.length, r, this.height, this.breaks);
  }
  replace(e, n, r) {
    let i = r[0];
    return r.length == 1 && (i instanceof Ln || i instanceof jt && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof jt ? i = new Ln(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = !1), i) : dn.of(r);
  }
  updateHeight(e, n = 0, r = !1, i) {
    return i && i.from <= n && i.more ? this.setHeight(i.heights[i.index++]) : (r || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class jt extends dn {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, n) {
    let r = e.doc.lineAt(n).number, i = e.doc.lineAt(n + this.length).number, o = i - r + 1, s, a = 0;
    if (e.lineWrapping) {
      let c = Math.min(this.height, e.lineHeight * o);
      s = c / o, this.length > o + 1 && (a = (this.height - c) / (this.length - o - 1));
    } else
      s = this.height / o;
    return { firstLine: r, lastLine: i, perLine: s, perChar: a };
  }
  blockAt(e, n, r, i) {
    let { firstLine: o, lastLine: s, perLine: a, perChar: c } = this.heightMetrics(n, i);
    if (n.lineWrapping) {
      let h = i + (e < n.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - r) / this.height)) * this.length)), f = n.doc.lineAt(h), d = a + f.length * c, p = Math.max(r, e - d / 2);
      return new kr(f.from, f.length, p, d, 0);
    } else {
      let h = Math.max(0, Math.min(s - o, Math.floor((e - r) / a))), { from: f, length: d } = n.doc.line(o + h);
      return new kr(f, d, r + a * h, a, 0);
    }
  }
  lineAt(e, n, r, i, o) {
    if (n == pt.ByHeight)
      return this.blockAt(e, r, i, o);
    if (n == pt.ByPosNoHeight) {
      let { from: v, to: w } = r.doc.lineAt(e);
      return new kr(v, w - v, 0, 0, 0);
    }
    let { firstLine: s, perLine: a, perChar: c } = this.heightMetrics(r, o), h = r.doc.lineAt(e), f = a + h.length * c, d = h.number - s, p = i + a * d + c * (h.from - o - d);
    return new kr(h.from, h.length, Math.max(i, Math.min(p, i + this.height - f)), f, 0);
  }
  forEachLine(e, n, r, i, o, s) {
    e = Math.max(e, o), n = Math.min(n, o + this.length);
    let { firstLine: a, perLine: c, perChar: h } = this.heightMetrics(r, o);
    for (let f = e, d = i; f <= n; ) {
      let p = r.doc.lineAt(f);
      if (f == e) {
        let w = p.number - a;
        d += c * w + h * (e - o - w);
      }
      let v = c + h * p.length;
      s(new kr(p.from, p.length, d, v, 0)), d += v, f = p.to + 1;
    }
  }
  replace(e, n, r) {
    let i = this.length - n;
    if (i > 0) {
      let o = r[r.length - 1];
      o instanceof jt ? r[r.length - 1] = new jt(o.length + i) : r.push(null, new jt(i - 1));
    }
    if (e > 0) {
      let o = r[0];
      o instanceof jt ? r[0] = new jt(e + o.length) : r.unshift(new jt(e - 1), null);
    }
    return dn.of(r);
  }
  decomposeLeft(e, n) {
    n.push(new jt(e - 1), null);
  }
  decomposeRight(e, n) {
    n.push(null, new jt(this.length - e - 1));
  }
  updateHeight(e, n = 0, r = !1, i) {
    let o = n + this.length;
    if (i && i.from <= n + this.length && i.more) {
      let s = [], a = Math.max(n, i.from), c = -1;
      for (i.from > n && s.push(new jt(i.from - n - 1).updateHeight(e, n)); a <= o && i.more; ) {
        let f = e.doc.lineAt(a).length;
        s.length && s.push(null);
        let d = i.heights[i.index++];
        c == -1 ? c = d : Math.abs(d - c) >= Au && (c = -2);
        let p = new Ln(f, d);
        p.outdated = !1, s.push(p), a += f + 1;
      }
      a <= o && s.push(null, new jt(o - a).updateHeight(e, a));
      let h = dn.of(s);
      return (c < 0 || Math.abs(h.height - this.height) >= Au || Math.abs(c - this.heightMetrics(e, n).perLine) >= Au) && (Ps = !0), Ju(this, h);
    } else (r || this.outdated) && (this.setHeight(e.heightForGap(n, n + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class uz extends dn {
  constructor(e, n, r) {
    super(e.length + n + r.length, e.height + r.height, n | (e.outdated || r.outdated ? 2 : 0)), this.left = e, this.right = r, this.size = e.size + r.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, n, r, i) {
    let o = r + this.left.height;
    return e < o ? this.left.blockAt(e, n, r, i) : this.right.blockAt(e, n, o, i + this.left.length + this.break);
  }
  lineAt(e, n, r, i, o) {
    let s = i + this.left.height, a = o + this.left.length + this.break, c = n == pt.ByHeight ? e < s : e < a, h = c ? this.left.lineAt(e, n, r, i, o) : this.right.lineAt(e, n, r, s, a);
    if (this.break || (c ? h.to < a : h.from > a))
      return h;
    let f = n == pt.ByPosNoHeight ? pt.ByPosNoHeight : pt.ByPos;
    return c ? h.join(this.right.lineAt(a, f, r, s, a)) : this.left.lineAt(a, f, r, i, o).join(h);
  }
  forEachLine(e, n, r, i, o, s) {
    let a = i + this.left.height, c = o + this.left.length + this.break;
    if (this.break)
      e < c && this.left.forEachLine(e, n, r, i, o, s), n >= c && this.right.forEachLine(e, n, r, a, c, s);
    else {
      let h = this.lineAt(c, pt.ByPos, r, i, o);
      e < h.from && this.left.forEachLine(e, h.from - 1, r, i, o, s), h.to >= e && h.from <= n && s(h), n > h.to && this.right.forEachLine(h.to + 1, n, r, a, c, s);
    }
  }
  replace(e, n, r) {
    let i = this.left.length + this.break;
    if (n < i)
      return this.balanced(this.left.replace(e, n, r), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - i, n - i, r));
    let o = [];
    e > 0 && this.decomposeLeft(e, o);
    let s = o.length;
    for (let a of r)
      o.push(a);
    if (e > 0 && vb(o, s - 1), n < this.length) {
      let a = o.length;
      this.decomposeRight(n, o), vb(o, a);
    }
    return dn.of(o);
  }
  decomposeLeft(e, n) {
    let r = this.left.length;
    if (e <= r)
      return this.left.decomposeLeft(e, n);
    n.push(this.left), this.break && (r++, e >= r && n.push(null)), e > r && this.right.decomposeLeft(e - r, n);
  }
  decomposeRight(e, n) {
    let r = this.left.length, i = r + this.break;
    if (e >= i)
      return this.right.decomposeRight(e - i, n);
    e < r && this.left.decomposeRight(e, n), this.break && e < i && n.push(null), n.push(this.right);
  }
  balanced(e, n) {
    return e.size > 2 * n.size || n.size > 2 * e.size ? dn.of(this.break ? [e, null, n] : [e, n]) : (this.left = Ju(this.left, e), this.right = Ju(this.right, n), this.setHeight(e.height + n.height), this.outdated = e.outdated || n.outdated, this.size = e.size + n.size, this.length = e.length + this.break + n.length, this);
  }
  updateHeight(e, n = 0, r = !1, i) {
    let { left: o, right: s } = this, a = n + o.length + this.break, c = null;
    return i && i.from <= n + o.length && i.more ? c = o = o.updateHeight(e, n, r, i) : o.updateHeight(e, n, r), i && i.from <= a + s.length && i.more ? c = s = s.updateHeight(e, a, r, i) : s.updateHeight(e, a, r), c ? this.balanced(o, s) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function vb(t, e) {
  let n, r;
  t[e] == null && (n = t[e - 1]) instanceof jt && (r = t[e + 1]) instanceof jt && t.splice(e - 1, 3, new jt(n.length + 1 + r.length));
}
const hz = 5;
class Np {
  constructor(e, n) {
    this.pos = e, this.oracle = n, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, n) {
    if (this.lineStart > -1) {
      let r = Math.min(n, this.lineEnd), i = this.nodes[this.nodes.length - 1];
      i instanceof Ln ? i.length += r - this.pos : (r > this.pos || !this.isCovered) && this.nodes.push(new Ln(r - this.pos, -1)), this.writtenTo = r, n > r && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = n;
  }
  point(e, n, r) {
    if (e < n || r.heightRelevant) {
      let i = r.widget ? r.widget.estimatedHeight : 0, o = r.widget ? r.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let s = n - e;
      r.block ? this.addBlock(new r4(s, i, r)) : (s || o || i >= hz) && this.addLineDeco(i, o, s);
    } else n > e && this.span(e, n);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: n } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = n, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Ln(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, n) {
    let r = new jt(n - e);
    return this.oracle.doc.lineAt(e).to == n && (r.flags |= 4), r;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof Ln)
      return e;
    let n = new Ln(0, -1);
    return this.nodes.push(n), n;
  }
  addBlock(e) {
    this.enterLine();
    let n = e.deco;
    n && n.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, n && n.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, n, r) {
    let i = this.ensureLine();
    i.length += r, i.collapsed += r, i.widgetHeight = Math.max(i.widgetHeight, e), i.breaks += n, this.writtenTo = this.pos = this.pos + r;
  }
  finish(e) {
    let n = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(n instanceof Ln) && !this.isCovered ? this.nodes.push(new Ln(0, -1)) : (this.writtenTo < this.pos || n == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let r = e;
    for (let i of this.nodes)
      i instanceof Ln && i.updateHeight(this.oracle, r), r += i ? i.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, n, r, i) {
    let o = new Np(r, e);
    return tt.spans(n, r, i, o, 0), o.finish(r);
  }
}
function fz(t, e, n) {
  let r = new dz();
  return tt.compare(t, e, n, r, 0), r.changes;
}
class dz {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, n, r, i) {
    (e < n || r && r.heightRelevant || i && i.heightRelevant) && $u(e, n, this.changes, 5);
  }
}
function gz(t, e) {
  let n = t.getBoundingClientRect(), r = t.ownerDocument, i = r.defaultView || window, o = Math.max(0, n.left), s = Math.min(i.innerWidth, n.right), a = Math.max(0, n.top), c = Math.min(i.innerHeight, n.bottom);
  for (let h = t.parentNode; h && h != r.body; )
    if (h.nodeType == 1) {
      let f = h, d = window.getComputedStyle(f);
      if ((f.scrollHeight > f.clientHeight || f.scrollWidth > f.clientWidth) && d.overflow != "visible") {
        let p = f.getBoundingClientRect();
        o = Math.max(o, p.left), s = Math.min(s, p.right), a = Math.max(a, p.top), c = Math.min(h == t.parentNode ? i.innerHeight : c, p.bottom);
      }
      h = d.position == "absolute" || d.position == "fixed" ? f.offsetParent : f.parentNode;
    } else if (h.nodeType == 11)
      h = h.host;
    else
      break;
  return {
    left: o - n.left,
    right: Math.max(o, s) - n.left,
    top: a - (n.top + e),
    bottom: Math.max(a, c) - (n.top + e)
  };
}
function pz(t) {
  let e = t.getBoundingClientRect(), n = t.ownerDocument.defaultView || window;
  return e.left < n.innerWidth && e.right > 0 && e.top < n.innerHeight && e.bottom > 0;
}
function mz(t, e) {
  let n = t.getBoundingClientRect();
  return {
    left: 0,
    right: n.right - n.left,
    top: e,
    bottom: n.bottom - (n.top + e)
  };
}
class g0 {
  constructor(e, n, r, i) {
    this.from = e, this.to = n, this.size = r, this.displaySize = i;
  }
  static same(e, n) {
    if (e.length != n.length)
      return !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r], o = n[r];
      if (i.from != o.from || i.to != o.to || i.size != o.size)
        return !1;
    }
    return !0;
  }
  draw(e, n) {
    return Se.replace({
      widget: new vz(this.displaySize * (n ? e.scaleY : e.scaleX), n)
    }).range(this.from, this.to);
  }
}
class vz extends xi {
  constructor(e, n) {
    super(), this.size = e, this.vertical = n;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class bb {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = wb, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = mt.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let n = e.facet(Ip).some((r) => typeof r != "function" && r.class == "cm-lineWrapping");
    this.heightOracle = new lz(n), this.stateDeco = e.facet(rl).filter((r) => typeof r != "function"), this.heightMap = dn.empty().applyChanges(this.stateDeco, nt.empty, this.heightOracle.setDoc(e.doc), [new Zn(0, 0, 0, e.doc.length)]);
    for (let r = 0; r < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); r++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = Se.set(this.lineGaps.map((r) => r.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: n } = this.state.selection;
    for (let r = 0; r <= 1; r++) {
      let i = r ? n.head : n.anchor;
      if (!e.some(({ from: o, to: s }) => i >= o && i <= s)) {
        let { from: o, to: s } = this.lineBlockAt(i);
        e.push(new eu(o, s));
      }
    }
    return this.viewports = e.sort((r, i) => r.from - i.from), this.updateScaler();
  }
  updateScaler() {
    let e = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? wb : new Fp(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(La(e, this.scaler));
    });
  }
  update(e, n = null) {
    this.state = e.state;
    let r = this.stateDeco;
    this.stateDeco = this.state.facet(rl).filter((f) => typeof f != "function");
    let i = e.changedRanges, o = Zn.extendWithRanges(i, fz(r, this.stateDeco, e ? e.changes : Nt.empty(this.state.doc.length))), s = this.heightMap.height, a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    mb(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), o), (this.heightMap.height != s || Ps) && (e.flags |= 2), a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = s);
    let c = o.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (n && (n.range.head < c.from || n.range.head > c.to) || !this.viewportIsAppropriate(c)) && (c = this.getViewport(0, n));
    let h = c.from != this.viewport.from || c.to != this.viewport.to;
    this.viewport = c, e.flags |= this.updateForViewport(), (h || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(e.changes), n && (this.scrollTarget = n), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(V6) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let n = e.contentDOM, r = window.getComputedStyle(n), i = this.heightOracle, o = r.whiteSpace;
    this.defaultTextDirection = r.direction == "rtl" ? mt.RTL : mt.LTR;
    let s = this.heightOracle.mustRefreshForWrapping(o), a = n.getBoundingClientRect(), c = s || this.mustMeasureContent || this.contentDOMHeight != a.height;
    this.contentDOMHeight = a.height, this.mustMeasureContent = !1;
    let h = 0, f = 0;
    if (a.width && a.height) {
      let { scaleX: T, scaleY: R } = f6(n, a);
      (T > 5e-3 && Math.abs(this.scaleX - T) > 5e-3 || R > 5e-3 && Math.abs(this.scaleY - R) > 5e-3) && (this.scaleX = T, this.scaleY = R, h |= 16, s = c = !0);
    }
    let d = (parseInt(r.paddingTop) || 0) * this.scaleY, p = (parseInt(r.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != d || this.paddingBottom != p) && (this.paddingTop = d, this.paddingBottom = p, h |= 18), this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (c = !0), this.editorWidth = e.scrollDOM.clientWidth, h |= 16);
    let v = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != v && (this.scrollAnchorHeight = -1, this.scrollTop = v), this.scrolledToBottom = p6(e.scrollDOM);
    let w = (this.printing ? mz : gz)(n, this.paddingTop), b = w.top - this.pixelViewport.top, y = w.bottom - this.pixelViewport.bottom;
    this.pixelViewport = w;
    let $ = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if ($ != this.inView && (this.inView = $, $ && (c = !0)), !this.inView && !this.scrollTarget && !pz(e.dom))
      return 0;
    let A = a.width;
    if ((this.contentDOMWidth != A || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = e.scrollDOM.clientHeight, h |= 16), c) {
      let T = e.docView.measureVisibleLineHeights(this.viewport);
      if (i.mustRefreshForHeights(T) && (s = !0), s || i.lineWrapping && Math.abs(A - this.contentDOMWidth) > i.charWidth) {
        let { lineHeight: R, charWidth: _, textHeight: D } = e.docView.measureTextSize();
        s = R > 0 && i.refresh(o, R, _, D, A / _, T), s && (e.docView.minWidth = 0, h |= 16);
      }
      b > 0 && y > 0 ? f = Math.max(b, y) : b < 0 && y < 0 && (f = Math.min(b, y)), mb();
      for (let R of this.viewports) {
        let _ = R.from == this.viewport.from ? T : e.docView.measureVisibleLineHeights(R);
        this.heightMap = (s ? dn.empty().applyChanges(this.stateDeco, nt.empty, this.heightOracle, [new Zn(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(i, 0, s, new cz(R.from, _));
      }
      Ps && (h |= 2);
    }
    let k = !this.viewportIsAppropriate(this.viewport, f) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return k && (h & 2 && (h |= this.updateScaler()), this.viewport = this.getViewport(f, this.scrollTarget), h |= this.updateForViewport()), (h & 2 || k) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(s ? [] : this.lineGaps, e)), h |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), h;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, n) {
    let r = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), i = this.heightMap, o = this.heightOracle, { visibleTop: s, visibleBottom: a } = this, c = new eu(i.lineAt(s - r * 1e3, pt.ByHeight, o, 0, 0).from, i.lineAt(a + (1 - r) * 1e3, pt.ByHeight, o, 0, 0).to);
    if (n) {
      let { head: h } = n.range;
      if (h < c.from || h > c.to) {
        let f = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), d = i.lineAt(h, pt.ByPos, o, 0, 0), p;
        n.y == "center" ? p = (d.top + d.bottom) / 2 - f / 2 : n.y == "start" || n.y == "nearest" && h < c.from ? p = d.top : p = d.bottom - f, c = new eu(i.lineAt(p - 1e3 / 2, pt.ByHeight, o, 0, 0).from, i.lineAt(p + f + 1e3 / 2, pt.ByHeight, o, 0, 0).to);
      }
    }
    return c;
  }
  mapViewport(e, n) {
    let r = n.mapPos(e.from, -1), i = n.mapPos(e.to, 1);
    return new eu(this.heightMap.lineAt(r, pt.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, pt.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: n }, r = 0) {
    if (!this.inView)
      return !0;
    let { top: i } = this.heightMap.lineAt(e, pt.ByPos, this.heightOracle, 0, 0), { bottom: o } = this.heightMap.lineAt(n, pt.ByPos, this.heightOracle, 0, 0), { visibleTop: s, visibleBottom: a } = this;
    return (e == 0 || i <= s - Math.max(10, Math.min(
      -r,
      250
      /* VP.MaxCoverMargin */
    ))) && (n == this.state.doc.length || o >= a + Math.max(10, Math.min(
      r,
      250
      /* VP.MaxCoverMargin */
    ))) && i > s - 2 * 1e3 && o < a + 2 * 1e3;
  }
  mapLineGaps(e, n) {
    if (!e.length || n.empty)
      return e;
    let r = [];
    for (let i of e)
      n.touchesRange(i.from, i.to) || r.push(new g0(n.mapPos(i.from), n.mapPos(i.to), i.size, i.displaySize));
    return r;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, n) {
    let r = this.heightOracle.lineWrapping, i = r ? 1e4 : 2e3, o = i >> 1, s = i << 1;
    if (this.defaultTextDirection != mt.LTR && !r)
      return [];
    let a = [], c = (f, d, p, v) => {
      if (d - f < o)
        return;
      let w = this.state.selection.main, b = [w.from];
      w.empty || b.push(w.to);
      for (let $ of b)
        if ($ > f && $ < d) {
          c(f, $ - 10, p, v), c($ + 10, d, p, v);
          return;
        }
      let y = wz(e, ($) => $.from >= p.from && $.to <= p.to && Math.abs($.from - f) < o && Math.abs($.to - d) < o && !b.some((A) => $.from < A && $.to > A));
      if (!y) {
        if (d < p.to && n && r && n.visibleRanges.some((k) => k.from <= d && k.to >= d)) {
          let k = n.moveToLineBoundary(J.cursor(d), !1, !0).head;
          k > f && (d = k);
        }
        let $ = this.gapSize(p, f, d, v), A = r || $ < 2e6 ? $ : 2e6;
        y = new g0(f, d, $, A);
      }
      a.push(y);
    }, h = (f) => {
      if (f.length < s || f.type != fn.Text)
        return;
      let d = bz(f.from, f.to, this.stateDeco);
      if (d.total < s)
        return;
      let p = this.scrollTarget ? this.scrollTarget.range.head : null, v, w;
      if (r) {
        let b = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, y, $;
        if (p != null) {
          let A = nu(d, p), k = ((this.visibleBottom - this.visibleTop) / 2 + b) / f.height;
          y = A - k, $ = A + k;
        } else
          y = (this.visibleTop - f.top - b) / f.height, $ = (this.visibleBottom - f.top + b) / f.height;
        v = tu(d, y), w = tu(d, $);
      } else {
        let b = d.total * this.heightOracle.charWidth, y = i * this.heightOracle.charWidth, $ = 0;
        if (b > 2e6)
          for (let _ of e)
            _.from >= f.from && _.from < f.to && _.size != _.displaySize && _.from * this.heightOracle.charWidth + $ < this.pixelViewport.left && ($ = _.size - _.displaySize);
        let A = this.pixelViewport.left + $, k = this.pixelViewport.right + $, T, R;
        if (p != null) {
          let _ = nu(d, p), D = ((k - A) / 2 + y) / b;
          T = _ - D, R = _ + D;
        } else
          T = (A - y) / b, R = (k + y) / b;
        v = tu(d, T), w = tu(d, R);
      }
      v > f.from && c(f.from, v, f, d), w < f.to && c(w, f.to, f, d);
    };
    for (let f of this.viewportLines)
      Array.isArray(f.type) ? f.type.forEach(h) : h(f);
    return a;
  }
  gapSize(e, n, r, i) {
    let o = nu(i, r) - nu(i, n);
    return this.heightOracle.lineWrapping ? e.height * o : i.total * this.heightOracle.charWidth * o;
  }
  updateLineGaps(e) {
    g0.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = Se.set(e.map((n) => n.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(e) {
    let n = this.stateDeco;
    this.lineGaps.length && (n = n.concat(this.lineGapDeco));
    let r = [];
    tt.spans(n, this.viewport.from, this.viewport.to, {
      span(o, s) {
        r.push({ from: o, to: s });
      },
      point() {
      }
    }, 20);
    let i = 0;
    if (r.length != this.visibleRanges.length)
      i = 12;
    else
      for (let o = 0; o < r.length && !(i & 8); o++) {
        let s = this.visibleRanges[o], a = r[o];
        (s.from != a.from || s.to != a.to) && (i |= 4, e && e.mapPos(s.from, -1) == a.from && e.mapPos(s.to, 1) == a.to || (i |= 8));
      }
    return this.visibleRanges = r, i;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((n) => n.from <= e && n.to >= e) || La(this.heightMap.lineAt(e, pt.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((n) => n.top <= e && n.bottom >= e) || La(this.heightMap.lineAt(this.scaler.fromDOM(e), pt.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let n = this.lineBlockAtHeight(e + 8);
    return n.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? n : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return La(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
let eu = class {
  constructor(e, n) {
    this.from = e, this.to = n;
  }
};
function bz(t, e, n) {
  let r = [], i = t, o = 0;
  return tt.spans(n, t, e, {
    span() {
    },
    point(s, a) {
      s > i && (r.push({ from: i, to: s }), o += s - i), i = a;
    }
  }, 20), i < e && (r.push({ from: i, to: e }), o += e - i), { total: o, ranges: r };
}
function tu({ total: t, ranges: e }, n) {
  if (n <= 0)
    return e[0].from;
  if (n >= 1)
    return e[e.length - 1].to;
  let r = Math.floor(t * n);
  for (let i = 0; ; i++) {
    let { from: o, to: s } = e[i], a = s - o;
    if (r <= a)
      return o + r;
    r -= a;
  }
}
function nu(t, e) {
  let n = 0;
  for (let { from: r, to: i } of t.ranges) {
    if (e <= i) {
      n += e - r;
      break;
    }
    n += i - r;
  }
  return n / t.total;
}
function wz(t, e) {
  for (let n of t)
    if (e(n))
      return n;
}
const wb = {
  toDOM(t) {
    return t;
  },
  fromDOM(t) {
    return t;
  },
  scale: 1,
  eq(t) {
    return t == this;
  }
};
class Fp {
  constructor(e, n, r) {
    let i = 0, o = 0, s = 0;
    this.viewports = r.map(({ from: a, to: c }) => {
      let h = n.lineAt(a, pt.ByPos, e, 0, 0).top, f = n.lineAt(c, pt.ByPos, e, 0, 0).bottom;
      return i += f - h, { from: a, to: c, top: h, bottom: f, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - i) / (n.height - i);
    for (let a of this.viewports)
      a.domTop = s + (a.top - o) * this.scale, s = a.domBottom = a.domTop + (a.bottom - a.top), o = a.bottom;
  }
  toDOM(e) {
    for (let n = 0, r = 0, i = 0; ; n++) {
      let o = n < this.viewports.length ? this.viewports[n] : null;
      if (!o || e < o.top)
        return i + (e - r) * this.scale;
      if (e <= o.bottom)
        return o.domTop + (e - o.top);
      r = o.bottom, i = o.domBottom;
    }
  }
  fromDOM(e) {
    for (let n = 0, r = 0, i = 0; ; n++) {
      let o = n < this.viewports.length ? this.viewports[n] : null;
      if (!o || e < o.domTop)
        return r + (e - i) / this.scale;
      if (e <= o.domBottom)
        return o.top + (e - o.domTop);
      r = o.bottom, i = o.domBottom;
    }
  }
  eq(e) {
    return e instanceof Fp ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((n, r) => n.from == e.viewports[r].from && n.to == e.viewports[r].to) : !1;
  }
}
function La(t, e) {
  if (e.scale == 1)
    return t;
  let n = e.toDOM(t.top), r = e.toDOM(t.bottom);
  return new kr(t.from, t.length, n, r - n, Array.isArray(t._content) ? t._content.map((i) => La(i, e)) : t._content);
}
const ru = /* @__PURE__ */ pe.define({ combine: (t) => t.join(" ") }), z1 = /* @__PURE__ */ pe.define({ combine: (t) => t.indexOf(!0) > -1 }), U1 = /* @__PURE__ */ Ui.newName(), i4 = /* @__PURE__ */ Ui.newName(), o4 = /* @__PURE__ */ Ui.newName(), s4 = { "&light": "." + i4, "&dark": "." + o4 };
function K1(t, e, n) {
  return new Ui(e, {
    finish(r) {
      return /&/.test(r) ? r.replace(/&\w*/, (i) => {
        if (i == "&")
          return t;
        if (!n || !n[i])
          throw new RangeError(`Unsupported selector: ${i}`);
        return n[i];
      }) : t + " " + r;
    }
  });
}
const xz = /* @__PURE__ */ K1("." + U1, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, s4), yz = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, p0 = me.ie && me.ie_version <= 11;
class Cz {
  constructor(e) {
    this.view = e, this.active = !1, this.editContext = null, this.selectionRange = new rW(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((n) => {
      for (let r of n)
        this.queue.push(r);
      (me.ie && me.ie_version <= 11 || me.ios && e.composing) && n.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && e.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(me.chrome && me.chrome_version < 126) && (this.editContext = new Sz(e), e.state.facet(oi) && (e.contentDOM.editContext = this.editContext.editContext)), p0 && (this.onCharData = (n) => {
      this.queue.push({
        target: n.target,
        type: "characterData",
        oldValue: n.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var n;
      ((n = this.view.docView) === null || n === void 0 ? void 0 : n.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((n) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), n.length > 0 && n[n.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((n) => {
      n.length > 0 && n[n.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(e) {
    (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((n, r) => n != e[r]))) {
      this.gapIntersection.disconnect();
      for (let n of e)
        this.gapIntersection.observe(n);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let n = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: r } = this, i = this.selectionRange;
    if (r.state.facet(oi) ? r.root.activeElement != this.dom : !Cu(this.dom, i))
      return;
    let o = i.anchorNode && r.docView.nearest(i.anchorNode);
    if (o && o.ignoreEvent(e)) {
      n || (this.selectionChanged = !1);
      return;
    }
    (me.ie && me.ie_version <= 11 || me.android && me.chrome) && !r.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    i.focusNode && Ha(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, n = nl(e.root);
    if (!n)
      return !1;
    let r = me.safari && e.root.nodeType == 11 && e.root.activeElement == this.dom && $z(this.view, n) || n;
    if (!r || this.selectionRange.eq(r))
      return !1;
    let i = Cu(this.dom, r);
    return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && oW(this.dom, r) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(r), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, n) {
    this.selectionRange.set(e.node, e.offset, n.node, n.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, n = null;
    for (let r = this.dom; r; )
      if (r.nodeType == 1)
        !n && e < this.scrollTargets.length && this.scrollTargets[e] == r ? e++ : n || (n = this.scrollTargets.slice(0, e)), n && n.push(r), r = r.assignedSlot || r.parentNode;
      else if (r.nodeType == 11)
        r = r.host;
      else
        break;
    if (e < this.scrollTargets.length && !n && (n = this.scrollTargets.slice(0, e)), n) {
      for (let r of this.scrollTargets)
        r.removeEventListener("scroll", this.onScroll);
      for (let r of this.scrollTargets = n)
        r.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, yz), p0 && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), p0 && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, n) {
    var r;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let o = this.delayedAndroidKey;
        o && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = o.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && o.force && ks(this.dom, o.key, o.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: n,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let n = -1, r = -1, i = !1;
    for (let o of e) {
      let s = this.readMutation(o);
      s && (s.typeOver && (i = !0), n == -1 ? { from: n, to: r } = s : (n = Math.min(s.from, n), r = Math.max(s.to, r)));
    }
    return { from: n, to: r, typeOver: i };
  }
  readChange() {
    let { from: e, to: n, typeOver: r } = this.processRecords(), i = this.selectionChanged && Cu(this.dom, this.selectionRange);
    if (e < 0 && !i)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let o = new HW(this.view, e, n, r);
    return this.view.docView.domChanged = { newSel: o.newSel ? o.newSel.main : null }, o;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let n = this.readChange();
    if (!n)
      return this.view.requestMeasure(), !1;
    let r = this.view.state, i = Y6(this.view, n);
    return this.view.state == r && (n.domChanged || n.newSel && !n.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), i;
  }
  readMutation(e) {
    let n = this.view.docView.nearest(e.target);
    if (!n || n.ignoreMutation(e))
      return null;
    if (n.markDirty(e.type == "attributes"), e.type == "attributes" && (n.flags |= 4), e.type == "childList") {
      let r = xb(n, e.previousSibling || e.target.previousSibling, -1), i = xb(n, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: r ? n.posAfter(r) : n.posAtStart,
        to: i ? n.posBefore(i) : n.posAtEnd,
        typeOver: !1
      };
    } else return e.type == "characterData" ? { from: n.posAtStart, to: n.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(e) {
    this.editContext && (this.editContext.update(e), e.startState.facet(oi) != e.state.facet(oi) && (e.view.contentDOM.editContext = e.state.facet(oi) ? this.editContext.editContext : null));
  }
  destroy() {
    var e, n, r;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (n = this.gapIntersection) === null || n === void 0 || n.disconnect(), (r = this.resizeScroll) === null || r === void 0 || r.disconnect();
    for (let i of this.scrollTargets)
      i.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}
function xb(t, e, n) {
  for (; e; ) {
    let r = ft.get(e);
    if (r && r.parent == t)
      return r;
    let i = e.parentNode;
    e = i != t.dom ? i : n > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function yb(t, e) {
  let n = e.startContainer, r = e.startOffset, i = e.endContainer, o = e.endOffset, s = t.docView.domAtPos(t.state.selection.main.anchor);
  return Ha(s.node, s.offset, i, o) && ([n, r, i, o] = [i, o, n, r]), { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: o };
}
function $z(t, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(t.root)[0];
    if (i)
      return yb(t, i);
  }
  let n = null;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), n = i.getTargetRanges()[0];
  }
  return t.contentDOM.addEventListener("beforeinput", r, !0), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", r, !0), n ? yb(t, n) : null;
}
class Sz {
  constructor(e) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(e.state);
    let n = this.editContext = new window.EditContext({
      text: e.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(e.state.selection.main.head)
    });
    this.handlers.textupdate = (r) => {
      let i = e.state.selection.main, { anchor: o, head: s } = i, a = this.toEditorPos(r.updateRangeStart), c = this.toEditorPos(r.updateRangeEnd);
      e.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: r.updateRangeStart, editorBase: a, drifted: !1 });
      let h = { from: a, to: c, insert: nt.of(r.text.split(`
`)) };
      if (h.from == this.from && o < this.from ? h.from = o : h.to == this.to && o > this.to && (h.to = o), h.from == h.to && !h.insert.length) {
        let f = J.single(this.toEditorPos(r.selectionStart), this.toEditorPos(r.selectionEnd));
        f.main.eq(i) || e.dispatch({ selection: f, userEvent: "select" });
        return;
      }
      if ((me.mac || me.android) && h.from == s - 1 && /^\. ?$/.test(r.text) && e.contentDOM.getAttribute("autocorrect") == "off" && (h = { from: a, to: c, insert: nt.of([r.text.replace(".", " ")]) }), this.pendingContextChange = h, !e.state.readOnly) {
        let f = this.to - this.from + (h.to - h.from + h.insert.length);
        Bp(e, h, J.single(this.toEditorPos(r.selectionStart, f), this.toEditorPos(r.selectionEnd, f)));
      }
      this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state));
    }, this.handlers.characterboundsupdate = (r) => {
      let i = [], o = null;
      for (let s = this.toEditorPos(r.rangeStart), a = this.toEditorPos(r.rangeEnd); s < a; s++) {
        let c = e.coordsForChar(s);
        o = c && new DOMRect(c.left, c.top, c.right - c.left, c.bottom - c.top) || o || new DOMRect(), i.push(o);
      }
      n.updateCharacterBounds(r.rangeStart, i);
    }, this.handlers.textformatupdate = (r) => {
      let i = [];
      for (let o of r.getTextFormats()) {
        let s = o.underlineStyle, a = o.underlineThickness;
        if (s != "None" && a != "None") {
          let c = this.toEditorPos(o.rangeStart), h = this.toEditorPos(o.rangeEnd);
          if (c < h) {
            let f = `text-decoration: underline ${s == "Dashed" ? "dashed " : s == "Squiggle" ? "wavy " : ""}${a == "Thin" ? 1 : 2}px`;
            i.push(Se.mark({ attributes: { style: f } }).range(c, h));
          }
        }
      }
      e.dispatch({ effects: P6.of(Se.set(i)) });
    }, this.handlers.compositionstart = () => {
      e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (e.inputState.composing = -1, e.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: r } = this.composing;
        this.composing = null, r && this.reset(e.state);
      }
    };
    for (let r in this.handlers)
      n.addEventListener(r, this.handlers[r]);
    this.measureReq = { read: (r) => {
      this.editContext.updateControlBounds(r.contentDOM.getBoundingClientRect());
      let i = nl(r.root);
      i && i.rangeCount && this.editContext.updateSelectionBounds(i.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(e) {
    let n = 0, r = !1, i = this.pendingContextChange;
    return e.changes.iterChanges((o, s, a, c, h) => {
      if (r)
        return;
      let f = h.length - (s - o);
      if (i && s >= i.to)
        if (i.from == o && i.to == s && i.insert.eq(h)) {
          i = this.pendingContextChange = null, n += f, this.to += f;
          return;
        } else
          i = null, this.revertPending(e.state);
      if (o += n, s += n, s <= this.from)
        this.from += f, this.to += f;
      else if (o < this.to) {
        if (o < this.from || s > this.to || this.to - this.from + h.length > 3e4) {
          r = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(o), this.toContextPos(s), h.toString()), this.to += f;
      }
      n += f;
    }), i && !r && this.revertPending(e.state), !r;
  }
  update(e) {
    let n = this.pendingContextChange, r = e.startState.selection.main;
    this.composing && (this.composing.drifted || !e.changes.touchesRange(r.from, r.to) && e.transactions.some((i) => !i.isUserEvent("input.type") && i.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = e.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.reset(e.state)) : (e.docChanged || e.selectionSet || n) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
  }
  resetRange(e) {
    let { head: n } = e.selection.main;
    this.from = Math.max(
      0,
      n - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      e.doc.length,
      n + 1e4
      /* CxVp.Margin */
    );
  }
  reset(e) {
    this.resetRange(e), this.editContext.updateText(0, this.editContext.text.length, e.doc.sliceString(this.from, this.to)), this.setSelection(e);
  }
  revertPending(e) {
    let n = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(n.from), this.toContextPos(n.from + n.insert.length), e.doc.sliceString(n.from, n.to));
  }
  setSelection(e) {
    let { main: n } = e.selection, r = this.toContextPos(Math.max(this.from, Math.min(this.to, n.anchor))), i = this.toContextPos(n.head);
    (this.editContext.selectionStart != r || this.editContext.selectionEnd != i) && this.editContext.updateSelection(r, i);
  }
  rangeIsValid(e) {
    let { head: n } = e.selection.main;
    return !(this.from > 0 && n - this.from < 500 || this.to < e.doc.length && this.to - n < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(e, n = this.to - this.from) {
    e = Math.min(e, n);
    let r = this.composing;
    return r && r.drifted ? r.editorBase + (e - r.contextBase) : e + this.from;
  }
  toContextPos(e) {
    let n = this.composing;
    return n && n.drifted ? n.contextBase + (e - n.editorBase) : e - this.from;
  }
  destroy() {
    for (let e in this.handlers)
      this.editContext.removeEventListener(e, this.handlers[e]);
  }
}
class fe {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    var n;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: r } = e;
    this.dispatchTransactions = e.dispatchTransactions || r && ((i) => i.forEach((o) => r(o, this))) || ((i) => this.update(i)), this.dispatch = this.dispatch.bind(this), this._root = e.root || iW(e.parent) || document, this.viewState = new bb(e.state || et.create(e)), e.scrollTo && e.scrollTo.is(Zc) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Da).map((i) => new h0(i));
    for (let i of this.plugins)
      i.update(this);
    this.observer = new Cz(this), this.inputState = new KW(this), this.inputState.ensureHandlers(this.plugins), this.docView = new J5(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((n = document.fonts) === null || n === void 0) && n.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...e) {
    let n = e.length == 1 && e[0] instanceof Ft ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(n, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let n = !1, r = !1, i, o = this.state;
    for (let p of e) {
      if (p.startState != o)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      o = p.state;
    }
    if (this.destroyed) {
      this.viewState.state = o;
      return;
    }
    let s = this.hasFocus, a = 0, c = null;
    e.some((p) => p.annotation(e4)) ? (this.inputState.notifiedFocused = s, a = 1) : s != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = s, c = t4(o, s), c || (a = 1));
    let h = this.observer.delayedAndroidKey, f = null;
    if (h ? (this.observer.clearDelayedAndroidKey(), f = this.observer.readChange(), (f && !this.state.doc.eq(o.doc) || !this.state.selection.eq(o.selection)) && (f = null)) : this.observer.clear(), o.facet(et.phrases) != this.state.facet(et.phrases))
      return this.setState(o);
    i = Qu.create(this, o, e), i.flags |= a;
    let d = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let p of e) {
        if (d && (d = d.map(p.changes)), p.scrollIntoView) {
          let { main: v } = p.state.selection;
          d = new Ms(v.empty ? v : J.cursor(v.head, v.head > v.anchor ? -1 : 1));
        }
        for (let v of p.effects)
          v.is(Zc) && (d = v.value.clip(this.state));
      }
      this.viewState.update(i, d), this.bidiCache = eh.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), n = this.docView.update(i), this.state.facet(Ia) != this.styleModules && this.mountStyles(), r = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(n, e.some((p) => p.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i.startState.facet(ru) != i.state.facet(ru) && (this.viewState.mustMeasureContent = !0), (n || r || d || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), n && this.docViewUpdate(), !i.empty)
      for (let p of this.state.facet(V1))
        try {
          p(i);
        } catch (v) {
          Cn(this.state, v, "update listener");
        }
    (c || f) && Promise.resolve().then(() => {
      c && this.state == c.startState && this.dispatch(c), f && !Y6(this, f) && h.force && ks(this.contentDOM, h.key, h.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let n = this.hasFocus;
    try {
      for (let r of this.plugins)
        r.destroy(this);
      this.viewState = new bb(e), this.plugins = e.facet(Da).map((r) => new h0(r)), this.pluginMap.clear();
      for (let r of this.plugins)
        r.update(this);
      this.docView.destroy(), this.docView = new J5(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    n && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let n = e.startState.facet(Da), r = e.state.facet(Da);
    if (n != r) {
      let i = [];
      for (let o of r) {
        let s = n.indexOf(o);
        if (s < 0)
          i.push(new h0(o));
        else {
          let a = this.plugins[s];
          a.mustUpdate = e, i.push(a);
        }
      }
      for (let o of this.plugins)
        o.mustUpdate != e && o.destroy(this);
      this.plugins = i, this.pluginMap.clear();
    } else
      for (let i of this.plugins)
        i.mustUpdate = e;
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    n != r && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let e of this.plugins) {
      let n = e.value;
      if (n && n.docViewUpdate)
        try {
          n.docViewUpdate(this);
        } catch (r) {
          Cn(this.state, r, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let n = null, r = this.scrollDOM, i = r.scrollTop * this.scaleY, { scrollAnchorPos: o, scrollAnchorHeight: s } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (s = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let a = 0; ; a++) {
        if (s < 0)
          if (p6(r))
            o = -1, s = this.viewState.heightMap.height;
          else {
            let v = this.viewState.scrollAnchorAt(i);
            o = v.from, s = v.top;
          }
        this.updateState = 1;
        let c = this.viewState.measure(this);
        if (!c && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (a > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let h = [];
        c & 4 || ([this.measureRequests, h] = [h, this.measureRequests]);
        let f = h.map((v) => {
          try {
            return v.read(this);
          } catch (w) {
            return Cn(this.state, w), Cb;
          }
        }), d = Qu.create(this, this.state, []), p = !1;
        d.flags |= c, n ? n.flags |= c : n = d, this.updateState = 2, d.empty || (this.updatePlugins(d), this.inputState.update(d), this.updateAttrs(), p = this.docView.update(d), p && this.docViewUpdate());
        for (let v = 0; v < h.length; v++)
          if (f[v] != Cb)
            try {
              let w = h[v];
              w.write && w.write(f[v], this);
            } catch (w) {
              Cn(this.state, w);
            }
        if (p && this.docView.updateSelection(!0), !d.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, s = -1;
              continue;
            } else {
              let w = (o < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(o).top) - s;
              if (w > 1 || w < -1) {
                i = i + w, r.scrollTop = i / this.scaleY, s = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (n && !n.empty)
      for (let a of this.state.facet(V1))
        a(n);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return U1 + " " + (this.state.facet(z1) ? o4 : i4) + " " + this.state.facet(ru);
  }
  updateAttrs() {
    let e = $b(this, W6, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), n = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(oi) ? "true" : "false",
      class: "cm-content",
      style: `${me.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (n["aria-readonly"] = "true"), $b(this, Ip, n);
    let r = this.observer.ignore(() => {
      let i = _1(this.contentDOM, this.contentAttrs, n), o = _1(this.dom, this.editorAttrs, e);
      return i || o;
    });
    return this.editorAttrs = e, this.contentAttrs = n, r;
  }
  showAnnouncements(e) {
    let n = !0;
    for (let r of e)
      for (let i of r.effects)
        if (i.is(fe.announce)) {
          n && (this.announceDOM.textContent = ""), n = !1;
          let o = this.announceDOM.appendChild(document.createElement("div"));
          o.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(Ia);
    let e = this.state.facet(fe.cspNonce);
    Ui.mount(this.root, this.styleModules.concat(xz).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let n = 0; n < this.measureRequests.length; n++)
          if (this.measureRequests[n].key === e.key) {
            this.measureRequests[n] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let n = this.pluginMap.get(e);
    return (n === void 0 || n && n.spec != e) && this.pluginMap.set(e, n = this.plugins.find((r) => r.spec == e) || null), n && n.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, n, r) {
    return d0(this, e, ib(this, e, n, r));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, n) {
    return d0(this, e, ib(this, e, n, (r) => BW(this, e.head, r)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, n) {
    let r = this.bidiSpans(e), i = this.textDirectionAt(e.from), o = r[n ? r.length - 1 : 0];
    return J.cursor(o.side(n, i) + e.from, o.forward(!n, i) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, n, r = !0) {
    return LW(this, e, n, r);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, n, r) {
    return d0(this, e, NW(this, e, n, r));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, n = 0) {
    return this.docView.posFromDOM(e, n);
  }
  posAtCoords(e, n = !0) {
    return this.readMeasured(), G6(this, e, n);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, n = 1) {
    this.readMeasured();
    let r = this.docView.coordsAt(e, n);
    if (!r || r.left == r.right)
      return r;
    let i = this.state.doc.lineAt(e), o = this.bidiSpans(i), s = o[Fi.find(o, e - i.from, -1, n)];
    return kl(r, s.dir == mt.LTR == n > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(F6) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > Az)
      return E6(e.length);
    let n = this.textDirectionAt(e.from), r;
    for (let o of this.bidiCache)
      if (o.from == e.from && o.dir == n && (o.fresh || R6(o.isolates, r = Q5(this, e))))
        return o.order;
    r || (r = Q5(this, e));
    let i = wW(e.text, n, r);
    return this.bidiCache.push(new eh(e.from, e.to, n, r, !0, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || me.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      d6(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, n = {}) {
    return Zc.of(new Ms(typeof e == "number" ? J.cursor(e) : e, n.y, n.x, n.yMargin, n.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: n } = this.scrollDOM, r = this.viewState.scrollAnchorAt(e);
    return Zc.of(new Ms(J.cursor(r.from), "start", "start", r.top - e, n, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(e) {
    e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return Mt.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return Mt.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, n) {
    let r = Ui.newName(), i = [ru.of(r), Ia.of(K1(`.${r}`, e))];
    return n && n.dark && i.push(z1.of(!0)), i;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return Wo.lowest(Ia.of(K1("." + U1, e, s4)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var n;
    let r = e.querySelector(".cm-content"), i = r && ft.get(r) || ft.get(e);
    return ((n = i?.rootView) === null || n === void 0 ? void 0 : n.view) || null;
  }
}
fe.styleModule = Ia;
fe.inputHandler = B6;
fe.clipboardInputFilter = Op;
fe.clipboardOutputFilter = Dp;
fe.scrollHandler = H6;
fe.focusChangeEffect = N6;
fe.perLineTextDirection = F6;
fe.exceptionSink = L6;
fe.updateListener = V1;
fe.editable = oi;
fe.mouseSelectionStyle = _6;
fe.dragMovesSelection = I6;
fe.clickAddsSelectionRange = D6;
fe.decorations = rl;
fe.outerDecorations = z6;
fe.atomicRanges = _p;
fe.bidiIsolatedRanges = U6;
fe.scrollMargins = K6;
fe.darkTheme = z1;
fe.cspNonce = /* @__PURE__ */ pe.define({ combine: (t) => t.length ? t[0] : "" });
fe.contentAttributes = Ip;
fe.editorAttributes = W6;
fe.lineWrapping = /* @__PURE__ */ fe.contentAttributes.of({ class: "cm-lineWrapping" });
fe.announce = /* @__PURE__ */ Ne.define();
const Az = 4096, Cb = {};
class eh {
  constructor(e, n, r, i, o, s) {
    this.from = e, this.to = n, this.dir = r, this.isolates = i, this.fresh = o, this.order = s;
  }
  static update(e, n) {
    if (n.empty && !e.some((o) => o.fresh))
      return e;
    let r = [], i = e.length ? e[e.length - 1].dir : mt.LTR;
    for (let o = Math.max(0, e.length - 10); o < e.length; o++) {
      let s = e[o];
      s.dir == i && !n.touchesRange(s.from, s.to) && r.push(new eh(n.mapPos(s.from, 1), n.mapPos(s.to, -1), s.dir, s.isolates, !1, s.order));
    }
    return r;
  }
}
function $b(t, e, n) {
  for (let r = t.state.facet(e), i = r.length - 1; i >= 0; i--) {
    let o = r[i], s = typeof o == "function" ? o(t) : o;
    s && I1(s, n);
  }
  return n;
}
const kz = me.mac ? "mac" : me.windows ? "win" : me.linux ? "linux" : "key";
function Mz(t, e) {
  const n = t.split(/-(?!$)/);
  let r = n[n.length - 1];
  r == "Space" && (r = " ");
  let i, o, s, a;
  for (let c = 0; c < n.length - 1; ++c) {
    const h = n[c];
    if (/^(cmd|meta|m)$/i.test(h))
      a = !0;
    else if (/^a(lt)?$/i.test(h))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(h))
      o = !0;
    else if (/^s(hift)?$/i.test(h))
      s = !0;
    else if (/^mod$/i.test(h))
      e == "mac" ? a = !0 : o = !0;
    else
      throw new Error("Unrecognized modifier name: " + h);
  }
  return i && (r = "Alt-" + r), o && (r = "Ctrl-" + r), a && (r = "Meta-" + r), s && (r = "Shift-" + r), r;
}
function iu(t, e, n) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n !== !1 && e.shiftKey && (t = "Shift-" + t), t;
}
const Tz = /* @__PURE__ */ Wo.default(/* @__PURE__ */ fe.domEventHandlers({
  keydown(t, e) {
    return l4(a4(e.state), t, e, "editor");
  }
})), Zh = /* @__PURE__ */ pe.define({ enables: Tz }), Sb = /* @__PURE__ */ new WeakMap();
function a4(t) {
  let e = t.facet(Zh), n = Sb.get(e);
  return n || Sb.set(e, n = Oz(e.reduce((r, i) => r.concat(i), []))), n;
}
function Rz(t, e, n) {
  return l4(a4(t.state), e, t, n);
}
let _i = null;
const Ez = 4e3;
function Oz(t, e = kz) {
  let n = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null), i = (s, a) => {
    let c = r[s];
    if (c == null)
      r[s] = a;
    else if (c != a)
      throw new Error("Key binding " + s + " is used both as a regular binding and as a multi-stroke prefix");
  }, o = (s, a, c, h, f) => {
    var d, p;
    let v = n[s] || (n[s] = /* @__PURE__ */ Object.create(null)), w = a.split(/ (?!$)/).map(($) => Mz($, e));
    for (let $ = 1; $ < w.length; $++) {
      let A = w.slice(0, $).join(" ");
      i(A, !0), v[A] || (v[A] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(k) => {
          let T = _i = { view: k, prefix: A, scope: s };
          return setTimeout(() => {
            _i == T && (_i = null);
          }, Ez), !0;
        }]
      });
    }
    let b = w.join(" ");
    i(b, !1);
    let y = v[b] || (v[b] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((p = (d = v._any) === null || d === void 0 ? void 0 : d.run) === null || p === void 0 ? void 0 : p.slice()) || []
    });
    c && y.run.push(c), h && (y.preventDefault = !0), f && (y.stopPropagation = !0);
  };
  for (let s of t) {
    let a = s.scope ? s.scope.split(" ") : ["editor"];
    if (s.any)
      for (let h of a) {
        let f = n[h] || (n[h] = /* @__PURE__ */ Object.create(null));
        f._any || (f._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: d } = s;
        for (let p in f)
          f[p].run.push((v) => d(v, q1));
      }
    let c = s[e] || s.key;
    if (c)
      for (let h of a)
        o(h, c, s.run, s.preventDefault, s.stopPropagation), s.shift && o(h, "Shift-" + c, s.shift, s.preventDefault, s.stopPropagation);
  }
  return n;
}
let q1 = null;
function l4(t, e, n, r) {
  q1 = e;
  let i = JP(e), o = wn(i, 0), s = Ar(o) == i.length && i != " ", a = "", c = !1, h = !1, f = !1;
  _i && _i.view == n && _i.scope == r && (a = _i.prefix + " ", X6.indexOf(e.keyCode) < 0 && (h = !0, _i = null));
  let d = /* @__PURE__ */ new Set(), p = (y) => {
    if (y) {
      for (let $ of y.run)
        if (!d.has($) && (d.add($), $(n)))
          return y.stopPropagation && (f = !0), !0;
      y.preventDefault && (y.stopPropagation && (f = !0), h = !0);
    }
    return !1;
  }, v = t[r], w, b;
  return v && (p(v[a + iu(i, e, !s)]) ? c = !0 : s && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(me.windows && e.ctrlKey && e.altKey) && (w = Ki[e.keyCode]) && w != i ? (p(v[a + iu(w, e, !0)]) || e.shiftKey && (b = tl[e.keyCode]) != i && b != w && p(v[a + iu(b, e, !1)])) && (c = !0) : s && e.shiftKey && p(v[a + iu(i, e, !0)]) && (c = !0), !c && p(v._any) && (c = !0)), h && (c = !0), c && f && e.stopPropagation(), q1 = null, c;
}
class Rl {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, n, r, i, o) {
    this.className = e, this.left = n, this.top = r, this.width = i, this.height = o;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, n) {
    return n.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, n, r) {
    if (r.empty) {
      let i = e.coordsAtPos(r.head, r.assoc || 1);
      if (!i)
        return [];
      let o = c4(e);
      return [new Rl(n, i.left - o.left, i.top - o.top, null, i.bottom - i.top)];
    } else
      return Dz(e, n, r);
  }
}
function c4(t) {
  let e = t.scrollDOM.getBoundingClientRect();
  return { left: (t.textDirection == mt.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX, top: e.top - t.scrollDOM.scrollTop * t.scaleY };
}
function Ab(t, e, n, r) {
  let i = t.coordsAtPos(e, n * 2);
  if (!i)
    return r;
  let o = t.dom.getBoundingClientRect(), s = (i.top + i.bottom) / 2, a = t.posAtCoords({ x: o.left + 1, y: s }), c = t.posAtCoords({ x: o.right - 1, y: s });
  return a == null || c == null ? r : { from: Math.max(r.from, Math.min(a, c)), to: Math.min(r.to, Math.max(a, c)) };
}
function Dz(t, e, n) {
  if (n.to <= t.viewport.from || n.from >= t.viewport.to)
    return [];
  let r = Math.max(n.from, t.viewport.from), i = Math.min(n.to, t.viewport.to), o = t.textDirection == mt.LTR, s = t.contentDOM, a = s.getBoundingClientRect(), c = c4(t), h = s.querySelector(".cm-line"), f = h && window.getComputedStyle(h), d = a.left + (f ? parseInt(f.paddingLeft) + Math.min(0, parseInt(f.textIndent)) : 0), p = a.right - (f ? parseInt(f.paddingRight) : 0), v = P1(t, r, 1), w = P1(t, i, -1), b = v.type == fn.Text ? v : null, y = w.type == fn.Text ? w : null;
  if (b && (t.lineWrapping || v.widgetLineBreaks) && (b = Ab(t, r, 1, b)), y && (t.lineWrapping || w.widgetLineBreaks) && (y = Ab(t, i, -1, y)), b && y && b.from == y.from && b.to == y.to)
    return A(k(n.from, n.to, b));
  {
    let R = b ? k(n.from, null, b) : T(v, !1), _ = y ? k(null, n.to, y) : T(w, !0), D = [];
    return (b || v).to < (y || w).from - (b && y ? 1 : 0) || v.widgetLineBreaks > 1 && R.bottom + t.defaultLineHeight / 2 < _.top ? D.push($(d, R.bottom, p, _.top)) : R.bottom < _.top && t.elementAtHeight((R.bottom + _.top) / 2).type == fn.Text && (R.bottom = _.top = (R.bottom + _.top) / 2), A(R).concat(D).concat(A(_));
  }
  function $(R, _, D, P) {
    return new Rl(e, R - c.left, _ - c.top, D - R, P - _);
  }
  function A({ top: R, bottom: _, horizontal: D }) {
    let P = [];
    for (let H = 0; H < D.length; H += 2)
      P.push($(D[H], R, D[H + 1], _));
    return P;
  }
  function k(R, _, D) {
    let P = 1e9, H = -1e9, z = [];
    function j(ee, re, de, ie, se) {
      let X = t.coordsAtPos(ee, ee == D.to ? -2 : 2), ce = t.coordsAtPos(de, de == D.from ? 2 : -2);
      !X || !ce || (P = Math.min(X.top, ce.top, P), H = Math.max(X.bottom, ce.bottom, H), se == mt.LTR ? z.push(o && re ? d : X.left, o && ie ? p : ce.right) : z.push(!o && ie ? d : ce.left, !o && re ? p : X.right));
    }
    let K = R ?? D.from, te = _ ?? D.to;
    for (let ee of t.visibleRanges)
      if (ee.to > K && ee.from < te)
        for (let re = Math.max(ee.from, K), de = Math.min(ee.to, te); ; ) {
          let ie = t.state.doc.lineAt(re);
          for (let se of t.bidiSpans(ie)) {
            let X = se.from + ie.from, ce = se.to + ie.from;
            if (X >= de)
              break;
            ce > re && j(Math.max(X, re), R == null && X <= K, Math.min(ce, de), _ == null && ce >= te, se.dir);
          }
          if (re = ie.to + 1, re >= de)
            break;
        }
    return z.length == 0 && j(K, R == null, te, _ == null, t.textDirection), { top: P, bottom: H, horizontal: z };
  }
  function T(R, _) {
    let D = a.top + (_ ? R.top : R.bottom);
    return { top: D, bottom: D, horizontal: [] };
  }
}
function Iz(t, e) {
  return t.constructor == e.constructor && t.eq(e);
}
class _z {
  constructor(e, n) {
    this.view = e, this.layer = n, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), n.above && this.dom.classList.add("cm-layer-above"), n.class && this.dom.classList.add(n.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), n.mount && n.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(ku) != e.state.facet(ku) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(e) {
    this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let n = 0, r = e.facet(ku);
    for (; n < r.length && r[n] != this.layer; )
      n++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - n);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: n } = this.view;
    (e != this.scaleX || n != this.scaleY) && (this.scaleX = e, this.scaleY = n, this.dom.style.transform = `scale(${1 / e}, ${1 / n})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((n, r) => !Iz(n, this.drawn[r]))) {
      let n = this.dom.firstChild, r = 0;
      for (let i of e)
        i.update && n && i.constructor && this.drawn[r].constructor && i.update(n, this.drawn[r]) ? (n = n.nextSibling, r++) : this.dom.insertBefore(i.draw(), n);
      for (; n; ) {
        let i = n.nextSibling;
        n.remove(), n = i;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const ku = /* @__PURE__ */ pe.define();
function u4(t) {
  return [
    Mt.define((e) => new _z(e, t)),
    ku.of(t)
  ];
}
const il = /* @__PURE__ */ pe.define({
  combine(t) {
    return Vr(t, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, n) => Math.min(e, n),
      drawRangeCursor: (e, n) => e || n
    });
  }
});
function Lz(t = {}) {
  return [
    il.of(t),
    Bz,
    Nz,
    Fz,
    V6.of(!0)
  ];
}
function h4(t) {
  return t.startState.facet(il) != t.state.facet(il);
}
const Bz = /* @__PURE__ */ u4({
  above: !0,
  markers(t) {
    let { state: e } = t, n = e.facet(il), r = [];
    for (let i of e.selection.ranges) {
      let o = i == e.selection.main;
      if (i.empty || n.drawRangeCursor) {
        let s = o ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", a = i.empty ? i : J.cursor(i.head, i.head > i.anchor ? -1 : 1);
        for (let c of Rl.forRange(t, s, a))
          r.push(c);
      }
    }
    return r;
  },
  update(t, e) {
    t.transactions.some((r) => r.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let n = h4(t);
    return n && kb(t.state, e), t.docChanged || t.selectionSet || n;
  },
  mount(t, e) {
    kb(e.state, t);
  },
  class: "cm-cursorLayer"
});
function kb(t, e) {
  e.style.animationDuration = t.facet(il).cursorBlinkRate + "ms";
}
const Nz = /* @__PURE__ */ u4({
  above: !1,
  markers(t) {
    return t.state.selection.ranges.map((e) => e.empty ? [] : Rl.forRange(t, "cm-selectionBackground", e)).reduce((e, n) => e.concat(n));
  },
  update(t, e) {
    return t.docChanged || t.selectionSet || t.viewportChanged || h4(t);
  },
  class: "cm-selectionLayer"
}), Fz = /* @__PURE__ */ Wo.highest(/* @__PURE__ */ fe.theme({
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-content": {
    caretColor: "transparent !important",
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
})), f4 = /* @__PURE__ */ Ne.define({
  map(t, e) {
    return t == null ? null : e.mapPos(t);
  }
}), Ba = /* @__PURE__ */ Kt.define({
  create() {
    return null;
  },
  update(t, e) {
    return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((n, r) => r.is(f4) ? r.value : n, t);
  }
}), Vz = /* @__PURE__ */ Mt.fromClass(class {
  constructor(t) {
    this.view = t, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(t) {
    var e;
    let n = t.state.field(Ba);
    n == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t.startState.field(Ba) != n || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: t } = this, e = t.state.field(Ba), n = e != null && t.coordsAtPos(e);
    if (!n)
      return null;
    let r = t.scrollDOM.getBoundingClientRect();
    return {
      left: n.left - r.left + t.scrollDOM.scrollLeft * t.scaleX,
      top: n.top - r.top + t.scrollDOM.scrollTop * t.scaleY,
      height: n.bottom - n.top
    };
  }
  drawCursor(t) {
    if (this.cursor) {
      let { scaleX: e, scaleY: n } = this.view;
      t ? (this.cursor.style.left = t.left / e + "px", this.cursor.style.top = t.top / n + "px", this.cursor.style.height = t.height / n + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(t) {
    this.view.state.field(Ba) != t && this.view.dispatch({ effects: f4.of(t) });
  }
}, {
  eventObservers: {
    dragover(t) {
      this.setDropPos(this.view.posAtCoords({ x: t.clientX, y: t.clientY }));
    },
    dragleave(t) {
      (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function Hz() {
  return [Ba, Vz];
}
function Mb(t, e, n, r, i) {
  e.lastIndex = 0;
  for (let o = t.iterRange(n, r), s = n, a; !o.next().done; s += o.value.length)
    if (!o.lineBreak)
      for (; a = e.exec(o.value); )
        i(s + a.index, a);
}
function Pz(t, e) {
  let n = t.visibleRanges;
  if (n.length == 1 && n[0].from == t.viewport.from && n[0].to == t.viewport.to)
    return n;
  let r = [];
  for (let { from: i, to: o } of n)
    i = Math.max(t.state.doc.lineAt(i).from, i - e), o = Math.min(t.state.doc.lineAt(o).to, o + e), r.length && r[r.length - 1].to >= i ? r[r.length - 1].to = o : r.push({ from: i, to: o });
  return r;
}
class Wz {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: n, decoration: r, decorate: i, boundary: o, maxLength: s = 1e3 } = e;
    if (!n.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = n, i)
      this.addMatch = (a, c, h, f) => i(f, h, h + a[0].length, a, c);
    else if (typeof r == "function")
      this.addMatch = (a, c, h, f) => {
        let d = r(a, c, h);
        d && f(h, h + a[0].length, d);
      };
    else if (r)
      this.addMatch = (a, c, h, f) => f(h, h + a[0].length, r);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = o, this.maxLength = s;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let n = new di(), r = n.add.bind(n);
    for (let { from: i, to: o } of Pz(e, this.maxLength))
      Mb(e.state.doc, this.regexp, i, o, (s, a) => this.addMatch(a, e, s, r));
    return n.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, n) {
    let r = 1e9, i = -1;
    return e.docChanged && e.changes.iterChanges((o, s, a, c) => {
      c >= e.view.viewport.from && a <= e.view.viewport.to && (r = Math.min(a, r), i = Math.max(c, i));
    }), e.viewportMoved || i - r > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, n.map(e.changes), r, i) : n;
  }
  updateRange(e, n, r, i) {
    for (let o of e.visibleRanges) {
      let s = Math.max(o.from, r), a = Math.min(o.to, i);
      if (a >= s) {
        let c = e.state.doc.lineAt(s), h = c.to < a ? e.state.doc.lineAt(a) : c, f = Math.max(o.from, c.from), d = Math.min(o.to, h.to);
        if (this.boundary) {
          for (; s > c.from; s--)
            if (this.boundary.test(c.text[s - 1 - c.from])) {
              f = s;
              break;
            }
          for (; a < h.to; a++)
            if (this.boundary.test(h.text[a - h.from])) {
              d = a;
              break;
            }
        }
        let p = [], v, w = (b, y, $) => p.push($.range(b, y));
        if (c == h)
          for (this.regexp.lastIndex = f - c.from; (v = this.regexp.exec(c.text)) && v.index < d - c.from; )
            this.addMatch(v, e, v.index + c.from, w);
        else
          Mb(e.state.doc, this.regexp, f, d, (b, y) => this.addMatch(y, e, b, w));
        n = n.update({ filterFrom: f, filterTo: d, filter: (b, y) => b < f || y > d, add: p });
      }
    }
    return n;
  }
}
const G1 = /x/.unicode != null ? "gu" : "g", zz = /* @__PURE__ */ new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`, G1), Uz = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let m0 = null;
function Kz() {
  var t;
  if (m0 == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    m0 = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;
  }
  return m0 || !1;
}
const Mu = /* @__PURE__ */ pe.define({
  combine(t) {
    let e = Vr(t, {
      render: null,
      specialChars: zz,
      addSpecialChars: null
    });
    return (e.replaceTabs = !Kz()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, G1)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, G1)), e;
  }
});
function qz(t = {}) {
  return [Mu.of(t), Gz()];
}
let Tb = null;
function Gz() {
  return Tb || (Tb = Mt.fromClass(class {
    constructor(t) {
      this.view = t, this.decorations = Se.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(t.state.facet(Mu)), this.decorations = this.decorator.createDeco(t);
    }
    makeDecorator(t) {
      return new Wz({
        regexp: t.specialChars,
        decoration: (e, n, r) => {
          let { doc: i } = n.state, o = wn(e[0], 0);
          if (o == 9) {
            let s = i.lineAt(r), a = n.state.tabSize, c = na(s.text, a, r - s.from);
            return Se.replace({
              widget: new Zz((a - c % a) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[o] || (this.decorationCache[o] = Se.replace({ widget: new Xz(t, o) }));
        },
        boundary: t.replaceTabs ? void 0 : /[^]/
      });
    }
    update(t) {
      let e = t.state.facet(Mu);
      t.startState.facet(Mu) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations);
    }
  }, {
    decorations: (t) => t.decorations
  }));
}
const Yz = "•";
function jz(t) {
  return t >= 32 ? Yz : t == 10 ? "␤" : String.fromCharCode(9216 + t);
}
class Xz extends xi {
  constructor(e, n) {
    super(), this.options = e, this.code = n;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let n = jz(this.code), r = e.state.phrase("Control character") + " " + (Uz[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, r, n);
    if (i)
      return i;
    let o = document.createElement("span");
    return o.textContent = n, o.title = r, o.setAttribute("aria-label", r), o.className = "cm-specialChar", o;
  }
  ignoreEvent() {
    return !1;
  }
}
class Zz extends xi {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function Qz() {
  return eU;
}
const Jz = /* @__PURE__ */ Se.line({ class: "cm-activeLine" }), eU = /* @__PURE__ */ Mt.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = -1, n = [];
    for (let r of t.state.selection.ranges) {
      let i = t.lineBlockAt(r.head);
      i.from > e && (n.push(Jz.range(i.from)), e = i.from);
    }
    return Se.set(n);
  }
}, {
  decorations: (t) => t.decorations
});
class tU extends xi {
  constructor(e) {
    super(), this.content = e;
  }
  toDOM(e) {
    let n = document.createElement("span");
    return n.className = "cm-placeholder", n.style.pointerEvents = "none", n.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : typeof this.content == "function" ? this.content(e) : this.content.cloneNode(!0)), n.setAttribute("aria-hidden", "true"), n;
  }
  coordsAt(e) {
    let n = e.firstChild ? Fs(e.firstChild) : [];
    if (!n.length)
      return null;
    let r = window.getComputedStyle(e.parentNode), i = kl(n[0], r.direction != "rtl"), o = parseInt(r.lineHeight);
    return i.bottom - i.top > o * 1.5 ? { left: i.left, right: i.right, top: i.top, bottom: i.top + o } : i;
  }
  ignoreEvent() {
    return !1;
  }
}
function nU(t) {
  let e = Mt.fromClass(class {
    constructor(n) {
      this.view = n, this.placeholder = t ? Se.set([Se.widget({ widget: new tU(t), side: 1 }).range(0)]) : Se.none;
    }
    get decorations() {
      return this.view.state.doc.length ? Se.none : this.placeholder;
    }
  }, { decorations: (n) => n.decorations });
  return typeof t == "string" ? [
    e,
    fe.contentAttributes.of({ "aria-placeholder": t })
  ] : e;
}
const Y1 = 2e3;
function rU(t, e, n) {
  let r = Math.min(e.line, n.line), i = Math.max(e.line, n.line), o = [];
  if (e.off > Y1 || n.off > Y1 || e.col < 0 || n.col < 0) {
    let s = Math.min(e.off, n.off), a = Math.max(e.off, n.off);
    for (let c = r; c <= i; c++) {
      let h = t.doc.line(c);
      h.length <= a && o.push(J.range(h.from + s, h.to + a));
    }
  } else {
    let s = Math.min(e.col, n.col), a = Math.max(e.col, n.col);
    for (let c = r; c <= i; c++) {
      let h = t.doc.line(c), f = k1(h.text, s, t.tabSize, !0);
      if (f < 0)
        o.push(J.cursor(h.to));
      else {
        let d = k1(h.text, a, t.tabSize);
        o.push(J.range(h.from + f, h.from + d));
      }
    }
  }
  return o;
}
function iU(t, e) {
  let n = t.coordsAtPos(t.viewport.from);
  return n ? Math.round(Math.abs((n.left - e) / t.defaultCharacterWidth)) : -1;
}
function Rb(t, e) {
  let n = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), r = t.state.doc.lineAt(n), i = n - r.from, o = i > Y1 ? -1 : i == r.length ? iU(t, e.clientX) : na(r.text, t.state.tabSize, n - r.from);
  return { line: r.number, col: o, off: i };
}
function oU(t, e) {
  let n = Rb(t, e), r = t.state.selection;
  return n ? {
    update(i) {
      if (i.docChanged) {
        let o = i.changes.mapPos(i.startState.doc.line(n.line).from), s = i.state.doc.lineAt(o);
        n = { line: s.number, col: n.col, off: Math.min(n.off, s.length) }, r = r.map(i.changes);
      }
    },
    get(i, o, s) {
      let a = Rb(t, i);
      if (!a)
        return r;
      let c = rU(t.state, n, a);
      return c.length ? s ? J.create(c.concat(r.ranges)) : J.create(c) : r;
    }
  } : null;
}
function sU(t) {
  let e = (n) => n.altKey && n.button == 0;
  return fe.mouseSelectionStyle.of((n, r) => e(r) ? oU(n, r) : null);
}
const aU = {
  Alt: [18, (t) => !!t.altKey],
  Control: [17, (t) => !!t.ctrlKey],
  Shift: [16, (t) => !!t.shiftKey],
  Meta: [91, (t) => !!t.metaKey]
}, lU = { style: "cursor: crosshair" };
function cU(t = {}) {
  let [e, n] = aU[t.key || "Alt"], r = Mt.fromClass(class {
    constructor(i) {
      this.view = i, this.isDown = !1;
    }
    set(i) {
      this.isDown != i && (this.isDown = i, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(i) {
        this.set(i.keyCode == e || n(i));
      },
      keyup(i) {
        (i.keyCode == e || !n(i)) && this.set(!1);
      },
      mousemove(i) {
        this.set(n(i));
      }
    }
  });
  return [
    r,
    fe.contentAttributes.of((i) => {
      var o;
      return !((o = i.plugin(r)) === null || o === void 0) && o.isDown ? lU : null;
    })
  ];
}
const ka = "-10000px";
class d4 {
  constructor(e, n, r, i) {
    this.facet = n, this.createTooltipView = r, this.removeTooltipView = i, this.input = e.state.facet(n), this.tooltips = this.input.filter((s) => s);
    let o = null;
    this.tooltipViews = this.tooltips.map((s) => o = r(s, o));
  }
  update(e, n) {
    var r;
    let i = e.state.facet(this.facet), o = i.filter((c) => c);
    if (i === this.input) {
      for (let c of this.tooltipViews)
        c.update && c.update(e);
      return !1;
    }
    let s = [], a = n ? [] : null;
    for (let c = 0; c < o.length; c++) {
      let h = o[c], f = -1;
      if (h) {
        for (let d = 0; d < this.tooltips.length; d++) {
          let p = this.tooltips[d];
          p && p.create == h.create && (f = d);
        }
        if (f < 0)
          s[c] = this.createTooltipView(h, c ? s[c - 1] : null), a && (a[c] = !!h.above);
        else {
          let d = s[c] = this.tooltipViews[f];
          a && (a[c] = n[f]), d.update && d.update(e);
        }
      }
    }
    for (let c of this.tooltipViews)
      s.indexOf(c) < 0 && (this.removeTooltipView(c), (r = c.destroy) === null || r === void 0 || r.call(c));
    return n && (a.forEach((c, h) => n[h] = c), n.length = a.length), this.input = i, this.tooltips = o, this.tooltipViews = s, !0;
  }
}
function uU(t) {
  let e = t.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: e.clientHeight, right: e.clientWidth };
}
const v0 = /* @__PURE__ */ pe.define({
  combine: (t) => {
    var e, n, r;
    return {
      position: me.ios ? "absolute" : ((e = t.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((n = t.find((i) => i.parent)) === null || n === void 0 ? void 0 : n.parent) || null,
      tooltipSpace: ((r = t.find((i) => i.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || uU
    };
  }
}), Eb = /* @__PURE__ */ new WeakMap(), Vp = /* @__PURE__ */ Mt.fromClass(class {
  constructor(t) {
    this.view = t, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = t.state.facet(v0);
    this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new d4(t, Hp, (n, r) => this.createTooltip(n, r), (n) => {
      this.resizeObserver && this.resizeObserver.unobserve(n.dom), n.dom.remove();
    }), this.above = this.manager.tooltips.map((n) => !!n.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((n) => {
      Date.now() > this.lastTransaction - 50 && n.length > 0 && n[n.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let t of this.manager.tooltipViews)
        this.intersectionObserver.observe(t.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(t) {
    t.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(t, this.above);
    e && this.observeIntersection();
    let n = e || t.geometryChanged, r = t.state.facet(v0);
    if (r.position != this.position && !this.madeAbsolute) {
      this.position = r.position;
      for (let i of this.manager.tooltipViews)
        i.dom.style.position = this.position;
      n = !0;
    }
    if (r.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = r.parent, this.createContainer();
      for (let i of this.manager.tooltipViews)
        this.container.appendChild(i.dom);
      n = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    n && this.maybeMeasure();
  }
  createTooltip(t, e) {
    let n = t.create(this.view), r = e ? e.dom : null;
    if (n.dom.classList.add("cm-tooltip"), t.arrow && !n.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let i = document.createElement("div");
      i.className = "cm-tooltip-arrow", n.dom.appendChild(i);
    }
    return n.dom.style.position = this.position, n.dom.style.top = ka, n.dom.style.left = "0px", this.container.insertBefore(n.dom, r), n.mount && n.mount(this.view), this.resizeObserver && this.resizeObserver.observe(n.dom), n;
  }
  destroy() {
    var t, e, n;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let r of this.manager.tooltipViews)
      r.dom.remove(), (t = r.destroy) === null || t === void 0 || t.call(r);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (n = this.intersectionObserver) === null || n === void 0 || n.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let t = 1, e = 1, n = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: o } = this.manager.tooltipViews[0];
      if (me.gecko)
        n = o.offsetParent != this.container.ownerDocument.body;
      else if (o.style.top == ka && o.style.left == "0px") {
        let s = o.getBoundingClientRect();
        n = Math.abs(s.top + 1e4) > 1 || Math.abs(s.left) > 1;
      }
    }
    if (n || this.position == "absolute")
      if (this.parent) {
        let o = this.parent.getBoundingClientRect();
        o.width && o.height && (t = o.width / this.parent.offsetWidth, e = o.height / this.parent.offsetHeight);
      } else
        ({ scaleX: t, scaleY: e } = this.view.viewState);
    let r = this.view.scrollDOM.getBoundingClientRect(), i = Lp(this.view);
    return {
      visible: {
        left: r.left + i.left,
        top: r.top + i.top,
        right: r.right - i.right,
        bottom: r.bottom - i.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((o, s) => {
        let a = this.manager.tooltipViews[s];
        return a.getCoords ? a.getCoords(o.pos) : this.view.coordsAtPos(o.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: o }) => o.getBoundingClientRect()),
      space: this.view.state.facet(v0).tooltipSpace(this.view),
      scaleX: t,
      scaleY: e,
      makeAbsolute: n
    };
  }
  writeMeasure(t) {
    var e;
    if (t.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let a of this.manager.tooltipViews)
        a.dom.style.position = "absolute";
    }
    let { visible: n, space: r, scaleX: i, scaleY: o } = t, s = [];
    for (let a = 0; a < this.manager.tooltips.length; a++) {
      let c = this.manager.tooltips[a], h = this.manager.tooltipViews[a], { dom: f } = h, d = t.pos[a], p = t.size[a];
      if (!d || c.clip !== !1 && (d.bottom <= Math.max(n.top, r.top) || d.top >= Math.min(n.bottom, r.bottom) || d.right < Math.max(n.left, r.left) - 0.1 || d.left > Math.min(n.right, r.right) + 0.1)) {
        f.style.top = ka;
        continue;
      }
      let v = c.arrow ? h.dom.querySelector(".cm-tooltip-arrow") : null, w = v ? 7 : 0, b = p.right - p.left, y = (e = Eb.get(h)) !== null && e !== void 0 ? e : p.bottom - p.top, $ = h.offset || fU, A = this.view.textDirection == mt.LTR, k = p.width > r.right - r.left ? A ? r.left : r.right - p.width : A ? Math.max(r.left, Math.min(d.left - (v ? 14 : 0) + $.x, r.right - b)) : Math.min(Math.max(r.left, d.left - b + (v ? 14 : 0) - $.x), r.right - b), T = this.above[a];
      !c.strictSide && (T ? d.top - y - w - $.y < r.top : d.bottom + y + w + $.y > r.bottom) && T == r.bottom - d.bottom > d.top - r.top && (T = this.above[a] = !T);
      let R = (T ? d.top - r.top : r.bottom - d.bottom) - w;
      if (R < y && h.resize !== !1) {
        if (R < this.view.defaultLineHeight) {
          f.style.top = ka;
          continue;
        }
        Eb.set(h, y), f.style.height = (y = R) / o + "px";
      } else f.style.height && (f.style.height = "");
      let _ = T ? d.top - y - w - $.y : d.bottom + w + $.y, D = k + b;
      if (h.overlap !== !0)
        for (let P of s)
          P.left < D && P.right > k && P.top < _ + y && P.bottom > _ && (_ = T ? P.top - y - 2 - w : P.bottom + w + 2);
      if (this.position == "absolute" ? (f.style.top = (_ - t.parent.top) / o + "px", Ob(f, (k - t.parent.left) / i)) : (f.style.top = _ / o + "px", Ob(f, k / i)), v) {
        let P = d.left + (A ? $.x : -$.x) - (k + 14 - 7);
        v.style.left = P / i + "px";
      }
      h.overlap !== !0 && s.push({ left: k, top: _, right: D, bottom: _ + y }), f.classList.toggle("cm-tooltip-above", T), f.classList.toggle("cm-tooltip-below", !T), h.positioned && h.positioned(t.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let t of this.manager.tooltipViews)
        t.dom.style.top = ka;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function Ob(t, e) {
  let n = parseInt(t.style.left, 10);
  (isNaN(n) || Math.abs(e - n) > 1) && (t.style.left = e + "px");
}
const hU = /* @__PURE__ */ fe.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), fU = { x: 0, y: 0 }, Hp = /* @__PURE__ */ pe.define({
  enables: [Vp, hU]
}), th = /* @__PURE__ */ pe.define({
  combine: (t) => t.reduce((e, n) => e.concat(n), [])
});
class Qh {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new Qh(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new d4(e, th, (n, r) => this.createHostedView(n, r), (n) => n.dom.remove());
  }
  createHostedView(e, n) {
    let r = e.create(this.view);
    return r.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(r.dom, n ? n.dom.nextSibling : this.dom.firstChild), this.mounted && r.mount && r.mount(this.view), r;
  }
  mount(e) {
    for (let n of this.manager.tooltipViews)
      n.mount && n.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let n of this.manager.tooltipViews)
      n.positioned && n.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let n of this.manager.tooltipViews)
      (e = n.destroy) === null || e === void 0 || e.call(n);
  }
  passProp(e) {
    let n;
    for (let r of this.manager.tooltipViews) {
      let i = r[e];
      if (i !== void 0) {
        if (n === void 0)
          n = i;
        else if (n !== i)
          return;
      }
    }
    return n;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const dU = /* @__PURE__ */ Hp.compute([th], (t) => {
  let e = t.facet(th);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((n) => n.pos)),
    end: Math.max(...e.map((n) => {
      var r;
      return (r = n.end) !== null && r !== void 0 ? r : n.pos;
    })),
    create: Qh.create,
    above: e[0].above,
    arrow: e.some((n) => n.arrow)
  };
});
class gU {
  constructor(e, n, r, i, o) {
    this.view = e, this.source = n, this.field = r, this.setHover = i, this.hoverTime = o, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: n } = this, r = e.docView.nearest(n.target);
    if (!r)
      return;
    let i, o = 1;
    if (r instanceof Ni)
      i = r.posAtStart;
    else {
      if (i = e.posAtCoords(n), i == null)
        return;
      let a = e.coordsAtPos(i);
      if (!a || n.y < a.top || n.y > a.bottom || n.x < a.left - e.defaultCharacterWidth || n.x > a.right + e.defaultCharacterWidth)
        return;
      let c = e.bidiSpans(e.state.doc.lineAt(i)).find((f) => f.from <= i && f.to >= i), h = c && c.dir == mt.RTL ? -1 : 1;
      o = n.x < a.left ? -h : h;
    }
    let s = this.source(e, i, o);
    if (s?.then) {
      let a = this.pending = { pos: i };
      s.then((c) => {
        this.pending == a && (this.pending = null, c && !(Array.isArray(c) && !c.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(c) ? c : [c]) }));
      }, (c) => Cn(e.state, c, "hover tooltip"));
    } else s && !(Array.isArray(s) && !s.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(s) ? s : [s]) });
  }
  get tooltip() {
    let e = this.view.plugin(Vp), n = e ? e.manager.tooltips.findIndex((r) => r.create == Qh.create) : -1;
    return n > -1 ? e.manager.tooltipViews[n] : null;
  }
  mousemove(e) {
    var n, r;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: i, tooltip: o } = this;
    if (i.length && o && !pU(o.dom, e) || this.pending) {
      let { pos: s } = i[0] || this.pending, a = (r = (n = i[0]) === null || n === void 0 ? void 0 : n.end) !== null && r !== void 0 ? r : s;
      (s == a ? this.view.posAtCoords(this.lastMove) != s : !mU(this.view, s, a, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: n } = this;
    if (n.length) {
      let { tooltip: r } = this;
      r && r.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(r.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let n = (r) => {
      e.removeEventListener("mouseleave", n), this.active.length && !this.view.dom.contains(r.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", n);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const ou = 4;
function pU(t, e) {
  let { left: n, right: r, top: i, bottom: o } = t.getBoundingClientRect(), s;
  if (s = t.querySelector(".cm-tooltip-arrow")) {
    let a = s.getBoundingClientRect();
    i = Math.min(a.top, i), o = Math.max(a.bottom, o);
  }
  return e.clientX >= n - ou && e.clientX <= r + ou && e.clientY >= i - ou && e.clientY <= o + ou;
}
function mU(t, e, n, r, i, o) {
  let s = t.scrollDOM.getBoundingClientRect(), a = t.documentTop + t.documentPadding.top + t.contentHeight;
  if (s.left > r || s.right < r || s.top > i || Math.min(s.bottom, a) < i)
    return !1;
  let c = t.posAtCoords({ x: r, y: i }, !1);
  return c >= e && c <= n;
}
function vU(t, e = {}) {
  let n = Ne.define(), r = Kt.define({
    create() {
      return [];
    },
    update(i, o) {
      if (i.length && (e.hideOnChange && (o.docChanged || o.selection) ? i = [] : e.hideOn && (i = i.filter((s) => !e.hideOn(o, s))), o.docChanged)) {
        let s = [];
        for (let a of i) {
          let c = o.changes.mapPos(a.pos, -1, hn.TrackDel);
          if (c != null) {
            let h = Object.assign(/* @__PURE__ */ Object.create(null), a);
            h.pos = c, h.end != null && (h.end = o.changes.mapPos(h.end)), s.push(h);
          }
        }
        i = s;
      }
      for (let s of o.effects)
        s.is(n) && (i = s.value), s.is(bU) && (i = []);
      return i;
    },
    provide: (i) => th.from(i)
  });
  return {
    active: r,
    extension: [
      r,
      Mt.define((i) => new gU(
        i,
        t,
        r,
        n,
        e.hoverTime || 300
        /* Hover.Time */
      )),
      dU
    ]
  };
}
function g4(t, e) {
  let n = t.plugin(Vp);
  if (!n)
    return null;
  let r = n.manager.tooltips.indexOf(e);
  return r < 0 ? null : n.manager.tooltipViews[r];
}
const bU = /* @__PURE__ */ Ne.define(), Db = /* @__PURE__ */ pe.define({
  combine(t) {
    let e, n;
    for (let r of t)
      e = e || r.topContainer, n = n || r.bottomContainer;
    return { topContainer: e, bottomContainer: n };
  }
});
function ol(t, e) {
  let n = t.plugin(p4), r = n ? n.specs.indexOf(e) : -1;
  return r > -1 ? n.panels[r] : null;
}
const p4 = /* @__PURE__ */ Mt.fromClass(class {
  constructor(t) {
    this.input = t.state.facet(sl), this.specs = this.input.filter((n) => n), this.panels = this.specs.map((n) => n(t));
    let e = t.state.facet(Db);
    this.top = new su(t, !0, e.topContainer), this.bottom = new su(t, !1, e.bottomContainer), this.top.sync(this.panels.filter((n) => n.top)), this.bottom.sync(this.panels.filter((n) => !n.top));
    for (let n of this.panels)
      n.dom.classList.add("cm-panel"), n.mount && n.mount();
  }
  update(t) {
    let e = t.state.facet(Db);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new su(t.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new su(t.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let n = t.state.facet(sl);
    if (n != this.input) {
      let r = n.filter((c) => c), i = [], o = [], s = [], a = [];
      for (let c of r) {
        let h = this.specs.indexOf(c), f;
        h < 0 ? (f = c(t.view), a.push(f)) : (f = this.panels[h], f.update && f.update(t)), i.push(f), (f.top ? o : s).push(f);
      }
      this.specs = r, this.panels = i, this.top.sync(o), this.bottom.sync(s);
      for (let c of a)
        c.dom.classList.add("cm-panel"), c.mount && c.mount();
    } else
      for (let r of this.panels)
        r.update && r.update(t);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (t) => fe.scrollMargins.of((e) => {
    let n = e.plugin(t);
    return n && { top: n.top.scrollMargin(), bottom: n.bottom.scrollMargin() };
  })
});
class su {
  constructor(e, n, r) {
    this.view = e, this.top = n, this.container = r, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let n of this.panels)
      n.destroy && e.indexOf(n) < 0 && n.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let n = this.container || this.view.dom;
      n.insertBefore(this.dom, this.top ? n.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let n of this.panels)
      if (n.dom.parentNode == this.dom) {
        for (; e != n.dom; )
          e = Ib(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(n.dom, e);
    for (; e; )
      e = Ib(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function Ib(t) {
  let e = t.nextSibling;
  return t.remove(), e;
}
const sl = /* @__PURE__ */ pe.define({
  enables: p4
});
class pi extends Ro {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
pi.prototype.elementClass = "";
pi.prototype.toDOM = void 0;
pi.prototype.mapMode = hn.TrackBefore;
pi.prototype.startSide = pi.prototype.endSide = -1;
pi.prototype.point = !0;
const Tu = /* @__PURE__ */ pe.define(), wU = /* @__PURE__ */ pe.define(), xU = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => tt.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, Wa = /* @__PURE__ */ pe.define();
function yU(t) {
  return [m4(), Wa.of(Object.assign(Object.assign({}, xU), t))];
}
const _b = /* @__PURE__ */ pe.define({
  combine: (t) => t.some((e) => e)
});
function m4(t) {
  return [
    CU
  ];
}
const CU = /* @__PURE__ */ Mt.fromClass(class {
  constructor(t) {
    this.view = t, this.prevViewport = t.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t.state.facet(Wa).map((e) => new Bb(t, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !t.state.facet(_b), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), t.scrollDOM.insertBefore(this.dom, t.contentDOM);
  }
  update(t) {
    if (this.updateGutters(t)) {
      let e = this.prevViewport, n = t.view.viewport, r = Math.min(e.to, n.to) - Math.max(e.from, n.from);
      this.syncGutters(r < (n.to - n.from) * 0.8);
    }
    t.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"), this.view.state.facet(_b) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = t.view.viewport;
  }
  syncGutters(t) {
    let e = this.dom.nextSibling;
    t && this.dom.remove();
    let n = tt.iter(this.view.state.facet(Tu), this.view.viewport.from), r = [], i = this.gutters.map((o) => new $U(o, this.view.viewport, -this.view.documentPadding.top));
    for (let o of this.view.viewportLineBlocks)
      if (r.length && (r = []), Array.isArray(o.type)) {
        let s = !0;
        for (let a of o.type)
          if (a.type == fn.Text && s) {
            j1(n, r, a.from);
            for (let c of i)
              c.line(this.view, a, r);
            s = !1;
          } else if (a.widget)
            for (let c of i)
              c.widget(this.view, a);
      } else if (o.type == fn.Text) {
        j1(n, r, o.from);
        for (let s of i)
          s.line(this.view, o, r);
      } else if (o.widget)
        for (let s of i)
          s.widget(this.view, o);
    for (let o of i)
      o.finish();
    t && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(t) {
    let e = t.startState.facet(Wa), n = t.state.facet(Wa), r = t.docChanged || t.heightChanged || t.viewportChanged || !tt.eq(t.startState.facet(Tu), t.state.facet(Tu), t.view.viewport.from, t.view.viewport.to);
    if (e == n)
      for (let i of this.gutters)
        i.update(t) && (r = !0);
    else {
      r = !0;
      let i = [];
      for (let o of n) {
        let s = e.indexOf(o);
        s < 0 ? i.push(new Bb(this.view, o)) : (this.gutters[s].update(t), i.push(this.gutters[s]));
      }
      for (let o of this.gutters)
        o.dom.remove(), i.indexOf(o) < 0 && o.destroy();
      for (let o of i)
        this.dom.appendChild(o.dom);
      this.gutters = i;
    }
    return r;
  }
  destroy() {
    for (let t of this.gutters)
      t.destroy();
    this.dom.remove();
  }
}, {
  provide: (t) => fe.scrollMargins.of((e) => {
    let n = e.plugin(t);
    return !n || n.gutters.length == 0 || !n.fixed ? null : e.textDirection == mt.LTR ? { left: n.dom.offsetWidth * e.scaleX } : { right: n.dom.offsetWidth * e.scaleX };
  })
});
function Lb(t) {
  return Array.isArray(t) ? t : [t];
}
function j1(t, e, n) {
  for (; t.value && t.from <= n; )
    t.from == n && e.push(t.value), t.next();
}
class $U {
  constructor(e, n, r) {
    this.gutter = e, this.height = r, this.i = 0, this.cursor = tt.iter(e.markers, n.from);
  }
  addElement(e, n, r) {
    let { gutter: i } = this, o = (n.top - this.height) / e.scaleY, s = n.height / e.scaleY;
    if (this.i == i.elements.length) {
      let a = new v4(e, s, o, r);
      i.elements.push(a), i.dom.appendChild(a.dom);
    } else
      i.elements[this.i].update(e, s, o, r);
    this.height = n.bottom, this.i++;
  }
  line(e, n, r) {
    let i = [];
    j1(this.cursor, i, n.from), r.length && (i = i.concat(r));
    let o = this.gutter.config.lineMarker(e, n, i);
    o && i.unshift(o);
    let s = this.gutter;
    i.length == 0 && !s.config.renderEmptyElements || this.addElement(e, n, i);
  }
  widget(e, n) {
    let r = this.gutter.config.widgetMarker(e, n.widget, n), i = r ? [r] : null;
    for (let o of e.state.facet(wU)) {
      let s = o(e, n.widget, n);
      s && (i || (i = [])).push(s);
    }
    i && this.addElement(e, n, i);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let n = e.elements.pop();
      e.dom.removeChild(n.dom), n.destroy();
    }
  }
}
class Bb {
  constructor(e, n) {
    this.view = e, this.config = n, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let r in n.domEventHandlers)
      this.dom.addEventListener(r, (i) => {
        let o = i.target, s;
        if (o != this.dom && this.dom.contains(o)) {
          for (; o.parentNode != this.dom; )
            o = o.parentNode;
          let c = o.getBoundingClientRect();
          s = (c.top + c.bottom) / 2;
        } else
          s = i.clientY;
        let a = e.lineBlockAtHeight(s - e.documentTop);
        n.domEventHandlers[r](e, a, i) && i.preventDefault();
      });
    this.markers = Lb(n.markers(e)), n.initialSpacer && (this.spacer = new v4(e, 0, 0, [n.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let n = this.markers;
    if (this.markers = Lb(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let i = this.config.updateSpacer(this.spacer.markers[0], e);
      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i]);
    }
    let r = e.view.viewport;
    return !tt.eq(this.markers, n, r.from, r.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class v4 {
  constructor(e, n, r, i) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, n, r, i);
  }
  update(e, n, r, i) {
    this.height != n && (this.height = n, this.dom.style.height = n + "px"), this.above != r && (this.dom.style.marginTop = (this.above = r) ? r + "px" : ""), SU(this.markers, i) || this.setMarkers(e, i);
  }
  setMarkers(e, n) {
    let r = "cm-gutterElement", i = this.dom.firstChild;
    for (let o = 0, s = 0; ; ) {
      let a = s, c = o < n.length ? n[o++] : null, h = !1;
      if (c) {
        let f = c.elementClass;
        f && (r += " " + f);
        for (let d = s; d < this.markers.length; d++)
          if (this.markers[d].compare(c)) {
            a = d, h = !0;
            break;
          }
      } else
        a = this.markers.length;
      for (; s < a; ) {
        let f = this.markers[s++];
        if (f.toDOM) {
          f.destroy(i);
          let d = i.nextSibling;
          i.remove(), i = d;
        }
      }
      if (!c)
        break;
      c.toDOM && (h ? i = i.nextSibling : this.dom.insertBefore(c.toDOM(e), i)), h && s++;
    }
    this.dom.className = r, this.markers = n;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function SU(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!t[n].compare(e[n]))
      return !1;
  return !0;
}
const AU = /* @__PURE__ */ pe.define(), kU = /* @__PURE__ */ pe.define(), ws = /* @__PURE__ */ pe.define({
  combine(t) {
    return Vr(t, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, n) {
        let r = Object.assign({}, e);
        for (let i in n) {
          let o = r[i], s = n[i];
          r[i] = o ? (a, c, h) => o(a, c, h) || s(a, c, h) : s;
        }
        return r;
      }
    });
  }
});
class b0 extends pi {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function w0(t, e) {
  return t.state.facet(ws).formatNumber(e, t.state);
}
const MU = /* @__PURE__ */ Wa.compute([ws], (t) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(AU);
  },
  lineMarker(e, n, r) {
    return r.some((i) => i.toDOM) ? null : new b0(w0(e, e.state.doc.lineAt(n.from).number));
  },
  widgetMarker: (e, n, r) => {
    for (let i of e.state.facet(kU)) {
      let o = i(e, n, r);
      if (o)
        return o;
    }
    return null;
  },
  lineMarkerChange: (e) => e.startState.facet(ws) != e.state.facet(ws),
  initialSpacer(e) {
    return new b0(w0(e, Nb(e.state.doc.lines)));
  },
  updateSpacer(e, n) {
    let r = w0(n.view, Nb(n.view.state.doc.lines));
    return r == e.number ? e : new b0(r);
  },
  domEventHandlers: t.facet(ws).domEventHandlers
}));
function TU(t = {}) {
  return [
    ws.of(t),
    m4(),
    MU
  ];
}
function Nb(t) {
  let e = 9;
  for (; e < t; )
    e = e * 10 + 9;
  return e;
}
const RU = /* @__PURE__ */ new class extends pi {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), EU = /* @__PURE__ */ Tu.compute(["selection"], (t) => {
  let e = [], n = -1;
  for (let r of t.selection.ranges) {
    let i = t.doc.lineAt(r.head).from;
    i > n && (n = i, e.push(RU.range(i)));
  }
  return tt.of(e);
});
function OU() {
  return EU;
}
var x0;
const xs = /* @__PURE__ */ new Ge();
function DU(t) {
  return pe.define({
    combine: t ? (e) => e.concat(t) : void 0
  });
}
const IU = /* @__PURE__ */ new Ge();
class ar {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, n, r = [], i = "") {
    this.data = e, this.name = i, et.prototype.hasOwnProperty("tree") || Object.defineProperty(et.prototype, "tree", { get() {
      return on(this);
    } }), this.parser = n, this.extension = [
      Gi.of(this),
      et.languageData.of((o, s, a) => {
        let c = Fb(o, s, a), h = c.type.prop(xs);
        if (!h)
          return [];
        let f = o.facet(h), d = c.type.prop(IU);
        if (d) {
          let p = c.resolve(s - c.from, a);
          for (let v of d)
            if (v.test(p, o)) {
              let w = o.facet(v.facet);
              return v.type == "replace" ? w : w.concat(f);
            }
        }
        return f;
      })
    ].concat(r);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, n, r = -1) {
    return Fb(e, n, r).type.prop(xs) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let n = e.facet(Gi);
    if (n?.data == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!n || !n.allowsNesting)
      return [];
    let r = [], i = (o, s) => {
      if (o.prop(xs) == this.data) {
        r.push({ from: s, to: s + o.length });
        return;
      }
      let a = o.prop(Ge.mounted);
      if (a) {
        if (a.tree.prop(xs) == this.data) {
          if (a.overlay)
            for (let c of a.overlay)
              r.push({ from: c.from + s, to: c.to + s });
          else
            r.push({ from: s, to: s + o.length });
          return;
        } else if (a.overlay) {
          let c = r.length;
          if (i(a.tree, a.overlay[0].from + s), r.length > c)
            return;
        }
      }
      for (let c = 0; c < o.children.length; c++) {
        let h = o.children[c];
        h instanceof Dt && i(h, o.positions[c] + s);
      }
    };
    return i(on(e), 0), r;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
ar.setState = /* @__PURE__ */ Ne.define();
function Fb(t, e, n) {
  let r = t.facet(Gi), i = on(t).topNode;
  if (!r || r.allowsNesting)
    for (let o = i; o; o = o.enter(e, n, Pt.ExcludeBuffers))
      o.type.isTop && (i = o);
  return i;
}
class nh extends ar {
  constructor(e, n, r) {
    super(e, n, [], r), this.parser = n;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let n = DU(e.languageData);
    return new nh(n, e.parser.configure({
      props: [xs.add((r) => r.isTop ? n : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, n) {
    return new nh(this.data, this.parser.configure(e), n || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function on(t) {
  let e = t.field(ar.state, !1);
  return e ? e.tree : Dt.empty;
}
class _U {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, n) {
    let r = this.cursorPos - this.string.length;
    return e < r || n >= this.cursorPos ? this.doc.sliceString(e, n) : this.string.slice(e - r, n - r);
  }
}
let Ma = null;
class rh {
  constructor(e, n, r = [], i, o, s, a, c) {
    this.parser = e, this.state = n, this.fragments = r, this.tree = i, this.treeLen = o, this.viewport = s, this.skipped = a, this.scheduleOn = c, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, n, r) {
    return new rh(e, n, [], Dt.empty, 0, r, [], null);
  }
  startParse() {
    return this.parser.startParse(new _U(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, n) {
    return n != null && n >= this.state.doc.length && (n = void 0), this.tree != Dt.empty && this.isDone(n ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var r;
      if (typeof e == "number") {
        let i = Date.now() + e;
        e = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), n != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > n) && n < this.state.doc.length && this.parse.stopAt(n); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped(Co.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (n ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, n;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(n = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = n, this.fragments = this.withoutTempSkipped(Co.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let n = Ma;
    Ma = this;
    try {
      return e();
    } finally {
      Ma = n;
    }
  }
  withoutTempSkipped(e) {
    for (let n; n = this.tempSkipped.pop(); )
      e = Vb(e, n.from, n.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, n) {
    let { fragments: r, tree: i, treeLen: o, viewport: s, skipped: a } = this;
    if (this.takeTree(), !e.empty) {
      let c = [];
      if (e.iterChangedRanges((h, f, d, p) => c.push({ fromA: h, toA: f, fromB: d, toB: p })), r = Co.applyChanges(r, c), i = Dt.empty, o = 0, s = { from: e.mapPos(s.from, -1), to: e.mapPos(s.to, 1) }, this.skipped.length) {
        a = [];
        for (let h of this.skipped) {
          let f = e.mapPos(h.from, 1), d = e.mapPos(h.to, -1);
          f < d && a.push({ from: f, to: d });
        }
      }
    }
    return new rh(this.parser, n, r, i, o, s, a, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let n = this.skipped.length;
    for (let r = 0; r < this.skipped.length; r++) {
      let { from: i, to: o } = this.skipped[r];
      i < e.to && o > e.from && (this.fragments = Vb(this.fragments, i, o), this.skipped.splice(r--, 1));
    }
    return this.skipped.length >= n ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, n) {
    this.skipped.push({ from: e, to: n });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends Uy {
      createParse(n, r, i) {
        let o = i[0].from, s = i[i.length - 1].to;
        return {
          parsedPos: o,
          advance() {
            let c = Ma;
            if (c) {
              for (let h of i)
                c.tempSkipped.push(h);
              e && (c.scheduleOn = c.scheduleOn ? Promise.all([c.scheduleOn, e]) : e);
            }
            return this.parsedPos = s, new Dt(Sn.none, [], [], s - o);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let n = this.fragments;
    return this.treeLen >= e && n.length && n[0].from == 0 && n[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Ma;
  }
}
function Vb(t, e, n) {
  return Co.applyChanges(t, [{ fromA: e, toA: n, fromB: e, toB: n }]);
}
class Ws {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let n = this.context.changes(e.changes, e.state), r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), n.viewport.to);
    return n.work(20, r) || n.takeTree(), new Ws(n);
  }
  static init(e) {
    let n = Math.min(3e3, e.doc.length), r = rh.create(e.facet(Gi).parser, e, { from: 0, to: n });
    return r.work(20, n) || r.takeTree(), new Ws(r);
  }
}
ar.state = /* @__PURE__ */ Kt.define({
  create: Ws.init,
  update(t, e) {
    for (let n of e.effects)
      if (n.is(ar.setState))
        return n.value;
    return e.startState.facet(Gi) != e.state.facet(Gi) ? Ws.init(e.state) : t.apply(e);
  }
});
let b4 = (t) => {
  let e = setTimeout(
    () => t(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (b4 = (t) => {
  let e = -1, n = setTimeout(
    () => {
      e = requestIdleCallback(t, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(n) : cancelIdleCallback(e);
});
const y0 = typeof navigator < "u" && (!((x0 = navigator.scheduling) === null || x0 === void 0) && x0.isInputPending) ? () => navigator.scheduling.isInputPending() : null, LU = /* @__PURE__ */ Mt.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let n = this.view.state.field(ar.state).context;
    (n.updateViewport(e.view.viewport) || this.view.viewport.to > n.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(n);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, n = e.field(ar.state);
    (n.tree != n.context.tree || !n.context.isDone(e.doc.length)) && (this.working = b4(this.work));
  }
  work(e) {
    this.working = null;
    let n = Date.now();
    if (this.chunkEnd < n && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = n + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: r, viewport: { to: i } } = this.view, o = r.field(ar.state);
    if (o.tree == o.context.tree && o.context.isDone(
      i + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let s = Date.now() + Math.min(this.chunkBudget, 100, e && !y0 ? Math.max(25, e.timeRemaining() - 5) : 1e9), a = o.context.treeLen < i && r.doc.length > i + 1e3, c = o.context.work(() => y0 && y0() || Date.now() > s, i + (a ? 0 : 1e5));
    this.chunkBudget -= Date.now() - n, (c || this.chunkBudget <= 0) && (o.context.takeTree(), this.view.dispatch({ effects: ar.setState.of(new Ws(o.context)) })), this.chunkBudget > 0 && !(c && !a) && this.scheduleWork(), this.checkAsyncSchedule(o.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((n) => Cn(this.view.state, n)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Gi = /* @__PURE__ */ pe.define({
  combine(t) {
    return t.length ? t[0] : null;
  },
  enables: (t) => [
    ar.state,
    LU,
    fe.contentAttributes.compute([t], (e) => {
      let n = e.facet(t);
      return n && n.name ? { "data-language": n.name } : {};
    })
  ]
});
class BU {
  /**
  Create a language support object.
  */
  constructor(e, n = []) {
    this.language = e, this.support = n, this.extension = [e, n];
  }
}
const NU = /* @__PURE__ */ pe.define(), Jh = /* @__PURE__ */ pe.define({
  combine: (t) => {
    if (!t.length)
      return "  ";
    let e = t[0];
    if (!e || /\S/.test(e) || Array.from(e).some((n) => n != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
    return e;
  }
});
function ih(t) {
  let e = t.facet(Jh);
  return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
}
function al(t, e) {
  let n = "", r = t.tabSize, i = t.facet(Jh)[0];
  if (i == "	") {
    for (; e >= r; )
      n += "	", e -= r;
    i = " ";
  }
  for (let o = 0; o < e; o++)
    n += i;
  return n;
}
function Pp(t, e) {
  t instanceof et && (t = new ef(t));
  for (let r of t.state.facet(NU)) {
    let i = r(t, e);
    if (i !== void 0)
      return i;
  }
  let n = on(t.state);
  return n.length >= e ? FU(t, n, e) : null;
}
class ef {
  /**
  Create an indent context.
  */
  constructor(e, n = {}) {
    this.state = e, this.options = n, this.unit = ih(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, n = 1) {
    let r = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: o } = this.options;
    return i != null && i >= r.from && i <= r.to ? o && i == e ? { text: "", from: e } : (n < 0 ? i < e : i <= e) ? { text: r.text.slice(i - r.from), from: i } : { text: r.text.slice(0, i - r.from), from: r.from } : r;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, n = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: r, from: i } = this.lineAt(e, n);
    return r.slice(e - i, Math.min(r.length, e + 100 - i));
  }
  /**
  Find the column for the given position.
  */
  column(e, n = 1) {
    let { text: r, from: i } = this.lineAt(e, n), o = this.countColumn(r, e - i), s = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return s > -1 && (o += s - this.countColumn(r, r.search(/\S|$/))), o;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, n = e.length) {
    return na(e, this.state.tabSize, n);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, n = 1) {
    let { text: r, from: i } = this.lineAt(e, n), o = this.options.overrideIndentation;
    if (o) {
      let s = o(i);
      if (s > -1)
        return s;
    }
    return this.countColumn(r, r.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const w4 = /* @__PURE__ */ new Ge();
function FU(t, e, n) {
  let r = e.resolveStack(n), i = e.resolveInner(n, -1).resolve(n, 0).enterUnfinishedNodesBefore(n);
  if (i != r.node) {
    let o = [];
    for (let s = i; s && !(s.from == r.node.from && s.type == r.node.type); s = s.parent)
      o.push(s);
    for (let s = o.length - 1; s >= 0; s--)
      r = { node: o[s], next: r };
  }
  return x4(r, t, n);
}
function x4(t, e, n) {
  for (let r = t; r; r = r.next) {
    let i = HU(r.node);
    if (i)
      return i(Wp.create(e, n, r));
  }
  return 0;
}
function VU(t) {
  return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
}
function HU(t) {
  let e = t.type.prop(w4);
  if (e)
    return e;
  let n = t.firstChild, r;
  if (n && (r = n.type.prop(Ge.closedBy))) {
    let i = t.lastChild, o = i && r.indexOf(i.name) > -1;
    return (s) => UU(s, !0, 1, void 0, o && !VU(s) ? i.from : void 0);
  }
  return t.parent == null ? PU : null;
}
function PU() {
  return 0;
}
class Wp extends ef {
  constructor(e, n, r) {
    super(e.state, e.options), this.base = e, this.pos = n, this.context = r;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, n, r) {
    return new Wp(e, n, r);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let n = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let r = e.resolve(n.from);
      for (; r.parent && r.parent.from == r.from; )
        r = r.parent;
      if (WU(r, e))
        break;
      n = this.state.doc.lineAt(r.from);
    }
    return this.lineIndent(n.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return x4(this.context.next, this.base, this.pos);
  }
}
function WU(t, e) {
  for (let n = e; n; n = n.parent)
    if (t == n)
      return !0;
  return !1;
}
function zU(t) {
  let e = t.node, n = e.childAfter(e.from), r = e.lastChild;
  if (!n)
    return null;
  let i = t.options.simulateBreak, o = t.state.doc.lineAt(n.from), s = i == null || i <= o.from ? o.to : Math.min(o.to, i);
  for (let a = n.to; ; ) {
    let c = e.childAfter(a);
    if (!c || c == r)
      return null;
    if (!c.type.isSkipped) {
      if (c.from >= s)
        return null;
      let h = /^ */.exec(o.text.slice(n.to - o.from))[0].length;
      return { from: n.from, to: n.to + h };
    }
    a = c.to;
  }
}
function UU(t, e, n, r, i) {
  let o = t.textAfter, s = o.match(/^\s*/)[0].length, a = r && o.slice(s, s + r.length) == r || i == t.pos + s, c = zU(t);
  return c ? a ? t.column(c.from) : t.column(c.to) : t.baseIndent + (a ? 0 : t.unit * n);
}
function Hb({ except: t, units: e = 1 } = {}) {
  return (n) => {
    let r = t && t.test(n.textAfter);
    return n.baseIndent + (r ? 0 : e * n.unit);
  };
}
const KU = 200;
function qU() {
  return et.transactionFilter.of((t) => {
    if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))
      return t;
    let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
    if (!e.length)
      return t;
    let n = t.newDoc, { head: r } = t.newSelection.main, i = n.lineAt(r);
    if (r > i.from + KU)
      return t;
    let o = n.sliceString(i.from, r);
    if (!e.some((h) => h.test(o)))
      return t;
    let { state: s } = t, a = -1, c = [];
    for (let { head: h } of s.selection.ranges) {
      let f = s.doc.lineAt(h);
      if (f.from == a)
        continue;
      a = f.from;
      let d = Pp(s, f.from);
      if (d == null)
        continue;
      let p = /^\s*/.exec(f.text)[0], v = al(s, d);
      p != v && c.push({ from: f.from, to: f.from + p.length, insert: v });
    }
    return c.length ? [t, { changes: c, sequential: !0 }] : t;
  });
}
const GU = /* @__PURE__ */ pe.define(), y4 = /* @__PURE__ */ new Ge();
function YU(t) {
  let e = t.firstChild, n = t.lastChild;
  return e && e.to < n.from ? { from: e.to, to: n.type.isError ? t.to : n.from } : null;
}
function jU(t, e, n) {
  let r = on(t);
  if (r.length < n)
    return null;
  let i = r.resolveStack(n, 1), o = null;
  for (let s = i; s; s = s.next) {
    let a = s.node;
    if (a.to <= n || a.from > n)
      continue;
    if (o && a.from < e)
      break;
    let c = a.type.prop(y4);
    if (c && (a.to < r.length - 50 || r.length == t.doc.length || !XU(a))) {
      let h = c(a, t);
      h && h.from <= n && h.from >= e && h.to > n && (o = h);
    }
  }
  return o;
}
function XU(t) {
  let e = t.lastChild;
  return e && e.to == t.to && e.type.isError;
}
function oh(t, e, n) {
  for (let r of t.facet(GU)) {
    let i = r(t, e, n);
    if (i)
      return i;
  }
  return jU(t, e, n);
}
function C4(t, e) {
  let n = e.mapPos(t.from, 1), r = e.mapPos(t.to, -1);
  return n >= r ? void 0 : { from: n, to: r };
}
const tf = /* @__PURE__ */ Ne.define({ map: C4 }), El = /* @__PURE__ */ Ne.define({ map: C4 });
function $4(t) {
  let e = [];
  for (let { head: n } of t.state.selection.ranges)
    e.some((r) => r.from <= n && r.to >= n) || e.push(t.lineBlockAt(n));
  return e;
}
const Io = /* @__PURE__ */ Kt.define({
  create() {
    return Se.none;
  },
  update(t, e) {
    t = t.map(e.changes);
    for (let n of e.effects)
      if (n.is(tf) && !ZU(t, n.value.from, n.value.to)) {
        let { preparePlaceholder: r } = e.state.facet(k4), i = r ? Se.replace({ widget: new iK(r(e.state, n.value)) }) : Pb;
        t = t.update({ add: [i.range(n.value.from, n.value.to)] });
      } else n.is(El) && (t = t.update({
        filter: (r, i) => n.value.from != r || n.value.to != i,
        filterFrom: n.value.from,
        filterTo: n.value.to
      }));
    if (e.selection) {
      let n = !1, { head: r } = e.selection.main;
      t.between(r, r, (i, o) => {
        i < r && o > r && (n = !0);
      }), n && (t = t.update({
        filterFrom: r,
        filterTo: r,
        filter: (i, o) => o <= r || i >= r
      }));
    }
    return t;
  },
  provide: (t) => fe.decorations.from(t),
  toJSON(t, e) {
    let n = [];
    return t.between(0, e.doc.length, (r, i) => {
      n.push(r, i);
    }), n;
  },
  fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let n = 0; n < t.length; ) {
      let r = t[n++], i = t[n++];
      if (typeof r != "number" || typeof i != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(Pb.range(r, i));
    }
    return Se.set(e, !0);
  }
});
function sh(t, e, n) {
  var r;
  let i = null;
  return (r = t.field(Io, !1)) === null || r === void 0 || r.between(e, n, (o, s) => {
    (!i || i.from > o) && (i = { from: o, to: s });
  }), i;
}
function ZU(t, e, n) {
  let r = !1;
  return t.between(e, e, (i, o) => {
    i == e && o == n && (r = !0);
  }), r;
}
function S4(t, e) {
  return t.field(Io, !1) ? e : e.concat(Ne.appendConfig.of(M4()));
}
const QU = (t) => {
  for (let e of $4(t)) {
    let n = oh(t.state, e.from, e.to);
    if (n)
      return t.dispatch({ effects: S4(t.state, [tf.of(n), A4(t, n)]) }), !0;
  }
  return !1;
}, JU = (t) => {
  if (!t.state.field(Io, !1))
    return !1;
  let e = [];
  for (let n of $4(t)) {
    let r = sh(t.state, n.from, n.to);
    r && e.push(El.of(r), A4(t, r, !1));
  }
  return e.length && t.dispatch({ effects: e }), e.length > 0;
};
function A4(t, e, n = !0) {
  let r = t.state.doc.lineAt(e.from).number, i = t.state.doc.lineAt(e.to).number;
  return fe.announce.of(`${t.state.phrase(n ? "Folded lines" : "Unfolded lines")} ${r} ${t.state.phrase("to")} ${i}.`);
}
const eK = (t) => {
  let { state: e } = t, n = [];
  for (let r = 0; r < e.doc.length; ) {
    let i = t.lineBlockAt(r), o = oh(e, i.from, i.to);
    o && n.push(tf.of(o)), r = (o ? t.lineBlockAt(o.to) : i).to + 1;
  }
  return n.length && t.dispatch({ effects: S4(t.state, n) }), !!n.length;
}, tK = (t) => {
  let e = t.state.field(Io, !1);
  if (!e || !e.size)
    return !1;
  let n = [];
  return e.between(0, t.state.doc.length, (r, i) => {
    n.push(El.of({ from: r, to: i }));
  }), t.dispatch({ effects: n }), !0;
}, nK = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: QU },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: JU },
  { key: "Ctrl-Alt-[", run: eK },
  { key: "Ctrl-Alt-]", run: tK }
], rK = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "…"
}, k4 = /* @__PURE__ */ pe.define({
  combine(t) {
    return Vr(t, rK);
  }
});
function M4(t) {
  return [Io, aK];
}
function T4(t, e) {
  let { state: n } = t, r = n.facet(k4), i = (s) => {
    let a = t.lineBlockAt(t.posAtDOM(s.target)), c = sh(t.state, a.from, a.to);
    c && t.dispatch({ effects: El.of(c) }), s.preventDefault();
  };
  if (r.placeholderDOM)
    return r.placeholderDOM(t, i, e);
  let o = document.createElement("span");
  return o.textContent = r.placeholderText, o.setAttribute("aria-label", n.phrase("folded code")), o.title = n.phrase("unfold"), o.className = "cm-foldPlaceholder", o.onclick = i, o;
}
const Pb = /* @__PURE__ */ Se.replace({ widget: /* @__PURE__ */ new class extends xi {
  toDOM(t) {
    return T4(t, null);
  }
}() });
class iK extends xi {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return T4(e, this.value);
  }
}
const oK = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class C0 extends pi {
  constructor(e, n) {
    super(), this.config = e, this.open = n;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let n = document.createElement("span");
    return n.textContent = this.open ? this.config.openText : this.config.closedText, n.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), n;
  }
}
function sK(t = {}) {
  let e = Object.assign(Object.assign({}, oK), t), n = new C0(e, !0), r = new C0(e, !1), i = Mt.fromClass(class {
    constructor(s) {
      this.from = s.viewport.from, this.markers = this.buildMarkers(s);
    }
    update(s) {
      (s.docChanged || s.viewportChanged || s.startState.facet(Gi) != s.state.facet(Gi) || s.startState.field(Io, !1) != s.state.field(Io, !1) || on(s.startState) != on(s.state) || e.foldingChanged(s)) && (this.markers = this.buildMarkers(s.view));
    }
    buildMarkers(s) {
      let a = new di();
      for (let c of s.viewportLineBlocks) {
        let h = sh(s.state, c.from, c.to) ? r : oh(s.state, c.from, c.to) ? n : null;
        h && a.add(c.from, c.from, h);
      }
      return a.finish();
    }
  }), { domEventHandlers: o } = e;
  return [
    i,
    yU({
      class: "cm-foldGutter",
      markers(s) {
        var a;
        return ((a = s.plugin(i)) === null || a === void 0 ? void 0 : a.markers) || tt.empty;
      },
      initialSpacer() {
        return new C0(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, o), { click: (s, a, c) => {
        if (o.click && o.click(s, a, c))
          return !0;
        let h = sh(s.state, a.from, a.to);
        if (h)
          return s.dispatch({ effects: El.of(h) }), !0;
        let f = oh(s.state, a.from, a.to);
        return f ? (s.dispatch({ effects: tf.of(f) }), !0) : !1;
      } })
    }),
    M4()
  ];
}
const aK = /* @__PURE__ */ fe.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class Ol {
  constructor(e, n) {
    this.specs = e;
    let r;
    function i(a) {
      let c = Ui.newName();
      return (r || (r = /* @__PURE__ */ Object.create(null)))["." + c] = a, c;
    }
    const o = typeof n.all == "string" ? n.all : n.all ? i(n.all) : void 0, s = n.scope;
    this.scope = s instanceof ar ? (a) => a.prop(xs) == s.data : s ? (a) => a == s : void 0, this.style = Gy(e.map((a) => ({
      tag: a.tag,
      class: a.class || i(Object.assign({}, a, { tag: null }))
    })), {
      all: o
    }).style, this.module = r ? new Ui(r) : null, this.themeType = n.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, n) {
    return new Ol(e, n || {});
  }
}
const X1 = /* @__PURE__ */ pe.define(), R4 = /* @__PURE__ */ pe.define({
  combine(t) {
    return t.length ? [t[0]] : null;
  }
});
function $0(t) {
  let e = t.facet(X1);
  return e.length ? e : t.facet(R4);
}
function E4(t, e) {
  let n = [cK], r;
  return t instanceof Ol && (t.module && n.push(fe.styleModule.of(t.module)), r = t.themeType), e?.fallback ? n.push(R4.of(t)) : r ? n.push(X1.computeN([fe.darkTheme], (i) => i.facet(fe.darkTheme) == (r == "dark") ? [t] : [])) : n.push(X1.of(t)), n;
}
class lK {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = on(e.state), this.decorations = this.buildDeco(e, $0(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let n = on(e.state), r = $0(e.state), i = r != $0(e.startState), { viewport: o } = e.view, s = e.changes.mapPos(this.decoratedTo, 1);
    n.length < o.to && !i && n.type == this.tree.type && s >= o.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = s) : (n != this.tree || e.viewportChanged || i) && (this.tree = n, this.decorations = this.buildDeco(e.view, r), this.decoratedTo = o.to);
  }
  buildDeco(e, n) {
    if (!n || !this.tree.length)
      return Se.none;
    let r = new di();
    for (let { from: i, to: o } of e.visibleRanges)
      kP(this.tree, n, (s, a, c) => {
        r.add(s, a, this.markCache[c] || (this.markCache[c] = Se.mark({ class: c })));
      }, i, o);
    return r.finish();
  }
}
const cK = /* @__PURE__ */ Wo.high(/* @__PURE__ */ Mt.fromClass(lK, {
  decorations: (t) => t.decorations
})), uK = /* @__PURE__ */ Ol.define([
  {
    tag: q.meta,
    color: "#404740"
  },
  {
    tag: q.link,
    textDecoration: "underline"
  },
  {
    tag: q.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: q.emphasis,
    fontStyle: "italic"
  },
  {
    tag: q.strong,
    fontWeight: "bold"
  },
  {
    tag: q.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: q.keyword,
    color: "#708"
  },
  {
    tag: [q.atom, q.bool, q.url, q.contentSeparator, q.labelName],
    color: "#219"
  },
  {
    tag: [q.literal, q.inserted],
    color: "#164"
  },
  {
    tag: [q.string, q.deleted],
    color: "#a11"
  },
  {
    tag: [q.regexp, q.escape, /* @__PURE__ */ q.special(q.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ q.definition(q.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ q.local(q.variableName),
    color: "#30a"
  },
  {
    tag: [q.typeName, q.namespace],
    color: "#085"
  },
  {
    tag: q.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ q.special(q.variableName), q.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ q.definition(q.propertyName),
    color: "#00c"
  },
  {
    tag: q.comment,
    color: "#940"
  },
  {
    tag: q.invalid,
    color: "#f00"
  }
]), hK = /* @__PURE__ */ fe.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), O4 = 1e4, D4 = "()[]{}", I4 = /* @__PURE__ */ pe.define({
  combine(t) {
    return Vr(t, {
      afterCursor: !0,
      brackets: D4,
      maxScanDistance: O4,
      renderMatch: gK
    });
  }
}), fK = /* @__PURE__ */ Se.mark({ class: "cm-matchingBracket" }), dK = /* @__PURE__ */ Se.mark({ class: "cm-nonmatchingBracket" });
function gK(t) {
  let e = [], n = t.matched ? fK : dK;
  return e.push(n.range(t.start.from, t.start.to)), t.end && e.push(n.range(t.end.from, t.end.to)), e;
}
const pK = /* @__PURE__ */ Kt.define({
  create() {
    return Se.none;
  },
  update(t, e) {
    if (!e.docChanged && !e.selection)
      return t;
    let n = [], r = e.state.facet(I4);
    for (let i of e.state.selection.ranges) {
      if (!i.empty)
        continue;
      let o = Mr(e.state, i.head, -1, r) || i.head > 0 && Mr(e.state, i.head - 1, 1, r) || r.afterCursor && (Mr(e.state, i.head, 1, r) || i.head < e.state.doc.length && Mr(e.state, i.head + 1, -1, r));
      o && (n = n.concat(r.renderMatch(o, e.state)));
    }
    return Se.set(n, !0);
  },
  provide: (t) => fe.decorations.from(t)
}), mK = [
  pK,
  hK
];
function vK(t = {}) {
  return [I4.of(t), mK];
}
const bK = /* @__PURE__ */ new Ge();
function Z1(t, e, n) {
  let r = t.prop(e < 0 ? Ge.openedBy : Ge.closedBy);
  if (r)
    return r;
  if (t.name.length == 1) {
    let i = n.indexOf(t.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
      return [n[i + e]];
  }
  return null;
}
function Q1(t) {
  let e = t.type.prop(bK);
  return e ? e(t.node) : t;
}
function Mr(t, e, n, r = {}) {
  let i = r.maxScanDistance || O4, o = r.brackets || D4, s = on(t), a = s.resolveInner(e, n);
  for (let c = a; c; c = c.parent) {
    let h = Z1(c.type, n, o);
    if (h && c.from < c.to) {
      let f = Q1(c);
      if (f && (n > 0 ? e >= f.from && e < f.to : e > f.from && e <= f.to))
        return wK(t, e, n, c, f, h, o);
    }
  }
  return xK(t, e, n, s, a.type, i, o);
}
function wK(t, e, n, r, i, o, s) {
  let a = r.parent, c = { from: i.from, to: i.to }, h = 0, f = a?.cursor();
  if (f && (n < 0 ? f.childBefore(r.from) : f.childAfter(r.to)))
    do
      if (n < 0 ? f.to <= r.from : f.from >= r.to) {
        if (h == 0 && o.indexOf(f.type.name) > -1 && f.from < f.to) {
          let d = Q1(f);
          return { start: c, end: d ? { from: d.from, to: d.to } : void 0, matched: !0 };
        } else if (Z1(f.type, n, s))
          h++;
        else if (Z1(f.type, -n, s)) {
          if (h == 0) {
            let d = Q1(f);
            return {
              start: c,
              end: d && d.from < d.to ? { from: d.from, to: d.to } : void 0,
              matched: !1
            };
          }
          h--;
        }
      }
    while (n < 0 ? f.prevSibling() : f.nextSibling());
  return { start: c, matched: !1 };
}
function xK(t, e, n, r, i, o, s) {
  let a = n < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), c = s.indexOf(a);
  if (c < 0 || c % 2 == 0 != n > 0)
    return null;
  let h = { from: n < 0 ? e - 1 : e, to: n > 0 ? e + 1 : e }, f = t.doc.iterRange(e, n > 0 ? t.doc.length : 0), d = 0;
  for (let p = 0; !f.next().done && p <= o; ) {
    let v = f.value;
    n < 0 && (p += v.length);
    let w = e + p * n;
    for (let b = n > 0 ? 0 : v.length - 1, y = n > 0 ? v.length : -1; b != y; b += n) {
      let $ = s.indexOf(v[b]);
      if (!($ < 0 || r.resolveInner(w + b, 1).type != i))
        if ($ % 2 == 0 == n > 0)
          d++;
        else {
          if (d == 1)
            return { start: h, end: { from: w + b, to: w + b + 1 }, matched: $ >> 1 == c >> 1 };
          d--;
        }
    }
    n > 0 && (p += v.length);
  }
  return f.done ? { start: h, matched: !1 } : null;
}
const yK = /* @__PURE__ */ Object.create(null), Wb = [Sn.none], zb = [], Ub = /* @__PURE__ */ Object.create(null), CK = /* @__PURE__ */ Object.create(null);
for (let [t, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  CK[t] = /* @__PURE__ */ $K(yK, e);
function S0(t, e) {
  zb.indexOf(t) > -1 || (zb.push(t), console.warn(e));
}
function $K(t, e) {
  let n = [];
  for (let a of e.split(" ")) {
    let c = [];
    for (let h of a.split(".")) {
      let f = t[h] || q[h];
      f ? typeof f == "function" ? c.length ? c = c.map(f) : S0(h, `Modifier ${h} used at start of tag`) : c.length ? S0(h, `Tag ${h} used as modifier`) : c = Array.isArray(f) ? f : [f] : S0(h, `Unknown highlighting tag ${h}`);
    }
    for (let h of c)
      n.push(h);
  }
  if (!n.length)
    return 0;
  let r = e.replace(/ /g, "_"), i = r + " " + n.map((a) => a.id), o = Ub[i];
  if (o)
    return o.id;
  let s = Ub[i] = Sn.define({
    id: Wb.length,
    name: r,
    props: [Ky({ [r]: n })]
  });
  return Wb.push(s), s.id;
}
mt.RTL, mt.LTR;
const SK = () => (t) => {
  try {
    JSON.parse(t.state.doc.toString());
  } catch (e) {
    if (!(e instanceof SyntaxError))
      throw e;
    const n = AK(e, t.state.doc);
    return [{
      from: n,
      message: e.message,
      severity: "error",
      to: n
    }];
  }
  return [];
};
function AK(t, e) {
  let n;
  return (n = t.message.match(/at position (\d+)/)) ? Math.min(+n[1], e.length) : (n = t.message.match(/at line (\d+) column (\d+)/)) ? Math.min(e.line(+n[1]).from + +n[2] - 1, e.length) : 0;
}
const kK = /* @__PURE__ */ nh.define({
  name: "json",
  parser: /* @__PURE__ */ EP.configure({
    props: [
      /* @__PURE__ */ w4.add({
        Object: /* @__PURE__ */ Hb({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ Hb({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ y4.add({
        "Object Array": YU
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function MK() {
  return new BU(kK);
}
function TK(t, e) {
  if (t == null) return {};
  var n = {};
  for (var r in t) if ({}.hasOwnProperty.call(t, r)) {
    if (e.indexOf(r) !== -1) continue;
    n[r] = t[r];
  }
  return n;
}
const RK = (t) => {
  let { state: e } = t, n = e.doc.lineAt(e.selection.main.from), r = Up(t.state, n.from);
  return r.line ? EK(t) : r.block ? DK(t) : !1;
};
function zp(t, e) {
  return ({ state: n, dispatch: r }) => {
    if (n.readOnly)
      return !1;
    let i = t(e, n);
    return i ? (r(n.update(i)), !0) : !1;
  };
}
const EK = /* @__PURE__ */ zp(
  LK,
  0
  /* CommentOption.Toggle */
), OK = /* @__PURE__ */ zp(
  _4,
  0
  /* CommentOption.Toggle */
), DK = /* @__PURE__ */ zp(
  (t, e) => _4(t, e, _K(e)),
  0
  /* CommentOption.Toggle */
);
function Up(t, e) {
  let n = t.languageDataAt("commentTokens", e, 1);
  return n.length ? n[0] : {};
}
const Ta = 50;
function IK(t, { open: e, close: n }, r, i) {
  let o = t.sliceDoc(r - Ta, r), s = t.sliceDoc(i, i + Ta), a = /\s*$/.exec(o)[0].length, c = /^\s*/.exec(s)[0].length, h = o.length - a;
  if (o.slice(h - e.length, h) == e && s.slice(c, c + n.length) == n)
    return {
      open: { pos: r - a, margin: a && 1 },
      close: { pos: i + c, margin: c && 1 }
    };
  let f, d;
  i - r <= 2 * Ta ? f = d = t.sliceDoc(r, i) : (f = t.sliceDoc(r, r + Ta), d = t.sliceDoc(i - Ta, i));
  let p = /^\s*/.exec(f)[0].length, v = /\s*$/.exec(d)[0].length, w = d.length - v - n.length;
  return f.slice(p, p + e.length) == e && d.slice(w, w + n.length) == n ? {
    open: {
      pos: r + p + e.length,
      margin: /\s/.test(f.charAt(p + e.length)) ? 1 : 0
    },
    close: {
      pos: i - v - n.length,
      margin: /\s/.test(d.charAt(w - 1)) ? 1 : 0
    }
  } : null;
}
function _K(t) {
  let e = [];
  for (let n of t.selection.ranges) {
    let r = t.doc.lineAt(n.from), i = n.to <= r.to ? r : t.doc.lineAt(n.to);
    i.from > r.from && i.from == n.to && (i = n.to == r.to + 1 ? r : t.doc.lineAt(n.to - 1));
    let o = e.length - 1;
    o >= 0 && e[o].to > r.from ? e[o].to = i.to : e.push({ from: r.from + /^\s*/.exec(r.text)[0].length, to: i.to });
  }
  return e;
}
function _4(t, e, n = e.selection.ranges) {
  let r = n.map((o) => Up(e, o.from).block);
  if (!r.every((o) => o))
    return null;
  let i = n.map((o, s) => IK(e, r[s], o.from, o.to));
  if (t != 2 && !i.every((o) => o))
    return { changes: e.changes(n.map((o, s) => i[s] ? [] : [{ from: o.from, insert: r[s].open + " " }, { from: o.to, insert: " " + r[s].close }])) };
  if (t != 1 && i.some((o) => o)) {
    let o = [];
    for (let s = 0, a; s < i.length; s++)
      if (a = i[s]) {
        let c = r[s], { open: h, close: f } = a;
        o.push({ from: h.pos - c.open.length, to: h.pos + h.margin }, { from: f.pos - f.margin, to: f.pos + c.close.length });
      }
    return { changes: o };
  }
  return null;
}
function LK(t, e, n = e.selection.ranges) {
  let r = [], i = -1;
  for (let { from: o, to: s } of n) {
    let a = r.length, c = 1e9, h = Up(e, o).line;
    if (h) {
      for (let f = o; f <= s; ) {
        let d = e.doc.lineAt(f);
        if (d.from > i && (o == s || s > d.from)) {
          i = d.from;
          let p = /^\s*/.exec(d.text)[0].length, v = p == d.length, w = d.text.slice(p, p + h.length) == h ? p : -1;
          p < d.text.length && p < c && (c = p), r.push({ line: d, comment: w, token: h, indent: p, empty: v, single: !1 });
        }
        f = d.to + 1;
      }
      if (c < 1e9)
        for (let f = a; f < r.length; f++)
          r[f].indent < r[f].line.text.length && (r[f].indent = c);
      r.length == a + 1 && (r[a].single = !0);
    }
  }
  if (t != 2 && r.some((o) => o.comment < 0 && (!o.empty || o.single))) {
    let o = [];
    for (let { line: a, token: c, indent: h, empty: f, single: d } of r)
      (d || !f) && o.push({ from: a.from + h, insert: c + " " });
    let s = e.changes(o);
    return { changes: s, selection: e.selection.map(s, 1) };
  } else if (t != 1 && r.some((o) => o.comment >= 0)) {
    let o = [];
    for (let { line: s, comment: a, token: c } of r)
      if (a >= 0) {
        let h = s.from + a, f = h + c.length;
        s.text[f - s.from] == " " && f++, o.push({ from: h, to: f });
      }
    return { changes: o };
  }
  return null;
}
const J1 = /* @__PURE__ */ Fr.define(), BK = /* @__PURE__ */ Fr.define(), NK = /* @__PURE__ */ pe.define(), L4 = /* @__PURE__ */ pe.define({
  combine(t) {
    return Vr(t, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, n) => n
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, n) => (r, i) => e(r, i) || n(r, i)
    });
  }
}), B4 = /* @__PURE__ */ Kt.define({
  create() {
    return Tr.empty;
  },
  update(t, e) {
    let n = e.state.facet(L4), r = e.annotation(J1);
    if (r) {
      let c = $n.fromTransaction(e, r.selection), h = r.side, f = h == 0 ? t.undone : t.done;
      return c ? f = ah(f, f.length, n.minDepth, c) : f = V4(f, e.startState.selection), new Tr(h == 0 ? r.rest : f, h == 0 ? f : r.rest);
    }
    let i = e.annotation(BK);
    if ((i == "full" || i == "before") && (t = t.isolate()), e.annotation(Ft.addToHistory) === !1)
      return e.changes.empty ? t : t.addMapping(e.changes.desc);
    let o = $n.fromTransaction(e), s = e.annotation(Ft.time), a = e.annotation(Ft.userEvent);
    return o ? t = t.addChanges(o, s, a, n, e) : e.selection && (t = t.addSelection(e.startState.selection, s, a, n.newGroupDelay)), (i == "full" || i == "after") && (t = t.isolate()), t;
  },
  toJSON(t) {
    return { done: t.done.map((e) => e.toJSON()), undone: t.undone.map((e) => e.toJSON()) };
  },
  fromJSON(t) {
    return new Tr(t.done.map($n.fromJSON), t.undone.map($n.fromJSON));
  }
});
function FK(t = {}) {
  return [
    B4,
    L4.of(t),
    fe.domEventHandlers({
      beforeinput(e, n) {
        let r = e.inputType == "historyUndo" ? N4 : e.inputType == "historyRedo" ? eg : null;
        return r ? (e.preventDefault(), r(n)) : !1;
      }
    })
  ];
}
function nf(t, e) {
  return function({ state: n, dispatch: r }) {
    if (!e && n.readOnly)
      return !1;
    let i = n.field(B4, !1);
    if (!i)
      return !1;
    let o = i.pop(t, n, e);
    return o ? (r(o), !0) : !1;
  };
}
const N4 = /* @__PURE__ */ nf(0, !1), eg = /* @__PURE__ */ nf(1, !1), VK = /* @__PURE__ */ nf(0, !0), HK = /* @__PURE__ */ nf(1, !0);
class $n {
  constructor(e, n, r, i, o) {
    this.changes = e, this.effects = n, this.mapped = r, this.startSelection = i, this.selectionsAfter = o;
  }
  setSelAfter(e) {
    return new $n(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, n, r;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (n = this.mapped) === null || n === void 0 ? void 0 : n.toJSON(),
      startSelection: (r = this.startSelection) === null || r === void 0 ? void 0 : r.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
    };
  }
  static fromJSON(e) {
    return new $n(e.changes && Nt.fromJSON(e.changes), [], e.mapped && Er.fromJSON(e.mapped), e.startSelection && J.fromJSON(e.startSelection), e.selectionsAfter.map(J.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, n) {
    let r = Yn;
    for (let i of e.startState.facet(NK)) {
      let o = i(e);
      o.length && (r = r.concat(o));
    }
    return !r.length && e.changes.empty ? null : new $n(e.changes.invert(e.startState.doc), r, void 0, n || e.startState.selection, Yn);
  }
  static selection(e) {
    return new $n(void 0, Yn, void 0, void 0, e);
  }
}
function ah(t, e, n, r) {
  let i = e + 1 > n + 20 ? e - n - 1 : 0, o = t.slice(i, e);
  return o.push(r), o;
}
function PK(t, e) {
  let n = [], r = !1;
  return t.iterChangedRanges((i, o) => n.push(i, o)), e.iterChangedRanges((i, o, s, a) => {
    for (let c = 0; c < n.length; ) {
      let h = n[c++], f = n[c++];
      a >= h && s <= f && (r = !0);
    }
  }), r;
}
function WK(t, e) {
  return t.ranges.length == e.ranges.length && t.ranges.filter((n, r) => n.empty != e.ranges[r].empty).length === 0;
}
function F4(t, e) {
  return t.length ? e.length ? t.concat(e) : t : e;
}
const Yn = [], zK = 200;
function V4(t, e) {
  if (t.length) {
    let n = t[t.length - 1], r = n.selectionsAfter.slice(Math.max(0, n.selectionsAfter.length - zK));
    return r.length && r[r.length - 1].eq(e) ? t : (r.push(e), ah(t, t.length - 1, 1e9, n.setSelAfter(r)));
  } else
    return [$n.selection([e])];
}
function UK(t) {
  let e = t[t.length - 1], n = t.slice();
  return n[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), n;
}
function A0(t, e) {
  if (!t.length)
    return t;
  let n = t.length, r = Yn;
  for (; n; ) {
    let i = KK(t[n - 1], e, r);
    if (i.changes && !i.changes.empty || i.effects.length) {
      let o = t.slice(0, n);
      return o[n - 1] = i, o;
    } else
      e = i.mapped, n--, r = i.selectionsAfter;
  }
  return r.length ? [$n.selection(r)] : Yn;
}
function KK(t, e, n) {
  let r = F4(t.selectionsAfter.length ? t.selectionsAfter.map((a) => a.map(e)) : Yn, n);
  if (!t.changes)
    return $n.selection(r);
  let i = t.changes.map(e), o = e.mapDesc(t.changes, !0), s = t.mapped ? t.mapped.composeDesc(o) : o;
  return new $n(i, Ne.mapEffects(t.effects, e), s, t.startSelection.map(o), r);
}
const qK = /^(input\.type|delete)($|\.)/;
class Tr {
  constructor(e, n, r = 0, i = void 0) {
    this.done = e, this.undone = n, this.prevTime = r, this.prevUserEvent = i;
  }
  isolate() {
    return this.prevTime ? new Tr(this.done, this.undone) : this;
  }
  addChanges(e, n, r, i, o) {
    let s = this.done, a = s[s.length - 1];
    return a && a.changes && !a.changes.empty && e.changes && (!r || qK.test(r)) && (!a.selectionsAfter.length && n - this.prevTime < i.newGroupDelay && i.joinToEvent(o, PK(a.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    r == "input.type.compose") ? s = ah(s, s.length - 1, i.minDepth, new $n(e.changes.compose(a.changes), F4(Ne.mapEffects(e.effects, a.changes), a.effects), a.mapped, a.startSelection, Yn)) : s = ah(s, s.length, i.minDepth, e), new Tr(s, Yn, n, r);
  }
  addSelection(e, n, r, i) {
    let o = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Yn;
    return o.length > 0 && n - this.prevTime < i && r == this.prevUserEvent && r && /^select($|\.)/.test(r) && WK(o[o.length - 1], e) ? this : new Tr(V4(this.done, e), this.undone, n, r);
  }
  addMapping(e) {
    return new Tr(A0(this.done, e), A0(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, n, r) {
    let i = e == 0 ? this.done : this.undone;
    if (i.length == 0)
      return null;
    let o = i[i.length - 1], s = o.selectionsAfter[0] || n.selection;
    if (r && o.selectionsAfter.length)
      return n.update({
        selection: o.selectionsAfter[o.selectionsAfter.length - 1],
        annotations: J1.of({ side: e, rest: UK(i), selection: s }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (o.changes) {
      let a = i.length == 1 ? Yn : i.slice(0, i.length - 1);
      return o.mapped && (a = A0(a, o.mapped)), n.update({
        changes: o.changes,
        selection: o.startSelection,
        effects: o.effects,
        annotations: J1.of({ side: e, rest: a, selection: s }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
Tr.empty = /* @__PURE__ */ new Tr(Yn, Yn);
const GK = [
  { key: "Mod-z", run: N4, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: eg, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: eg, preventDefault: !0 },
  { key: "Mod-u", run: VK, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: HK, preventDefault: !0 }
];
function ra(t, e) {
  return J.create(t.ranges.map(e), t.mainIndex);
}
function Hr(t, e) {
  return t.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function pr({ state: t, dispatch: e }, n) {
  let r = ra(t.selection, n);
  return r.eq(t.selection, !0) ? !1 : (e(Hr(t, r)), !0);
}
function rf(t, e) {
  return J.cursor(e ? t.to : t.from);
}
function H4(t, e) {
  return pr(t, (n) => n.empty ? t.moveByChar(n, e) : rf(n, e));
}
function sn(t) {
  return t.textDirectionAt(t.state.selection.main.head) == mt.LTR;
}
const P4 = (t) => H4(t, !sn(t)), W4 = (t) => H4(t, sn(t));
function z4(t, e) {
  return pr(t, (n) => n.empty ? t.moveByGroup(n, e) : rf(n, e));
}
const YK = (t) => z4(t, !sn(t)), jK = (t) => z4(t, sn(t));
function XK(t, e, n) {
  if (e.type.prop(n))
    return !0;
  let r = e.to - e.from;
  return r && (r > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to))) || e.firstChild;
}
function of(t, e, n) {
  let r = on(t).resolveInner(e.head), i = n ? Ge.closedBy : Ge.openedBy;
  for (let c = e.head; ; ) {
    let h = n ? r.childAfter(c) : r.childBefore(c);
    if (!h)
      break;
    XK(t, h, i) ? r = h : c = n ? h.to : h.from;
  }
  let o = r.type.prop(i), s, a;
  return o && (s = n ? Mr(t, r.from, 1) : Mr(t, r.to, -1)) && s.matched ? a = n ? s.end.to : s.end.from : a = n ? r.to : r.from, J.cursor(a, n ? -1 : 1);
}
const ZK = (t) => pr(t, (e) => of(t.state, e, !sn(t))), QK = (t) => pr(t, (e) => of(t.state, e, sn(t)));
function U4(t, e) {
  return pr(t, (n) => {
    if (!n.empty)
      return rf(n, e);
    let r = t.moveVertically(n, e);
    return r.head != n.head ? r : t.moveToLineBoundary(n, e);
  });
}
const K4 = (t) => U4(t, !1), q4 = (t) => U4(t, !0);
function G4(t) {
  let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2, n = 0, r = 0, i;
  if (e) {
    for (let o of t.state.facet(fe.scrollMargins)) {
      let s = o(t);
      s?.top && (n = Math.max(s?.top, n)), s?.bottom && (r = Math.max(s?.bottom, r));
    }
    i = t.scrollDOM.clientHeight - n - r;
  } else
    i = (t.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: n,
    marginBottom: r,
    selfScroll: e,
    height: Math.max(t.defaultLineHeight, i - 5)
  };
}
function Y4(t, e) {
  let n = G4(t), { state: r } = t, i = ra(r.selection, (s) => s.empty ? t.moveVertically(s, e, n.height) : rf(s, e));
  if (i.eq(r.selection))
    return !1;
  let o;
  if (n.selfScroll) {
    let s = t.coordsAtPos(r.selection.main.head), a = t.scrollDOM.getBoundingClientRect(), c = a.top + n.marginTop, h = a.bottom - n.marginBottom;
    s && s.top > c && s.bottom < h && (o = fe.scrollIntoView(i.main.head, { y: "start", yMargin: s.top - c }));
  }
  return t.dispatch(Hr(r, i), { effects: o }), !0;
}
const Kb = (t) => Y4(t, !1), tg = (t) => Y4(t, !0);
function Zi(t, e, n) {
  let r = t.lineBlockAt(e.head), i = t.moveToLineBoundary(e, n);
  if (i.head == e.head && i.head != (n ? r.to : r.from) && (i = t.moveToLineBoundary(e, n, !1)), !n && i.head == r.from && r.length) {
    let o = /^\s*/.exec(t.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length;
    o && e.head != r.from + o && (i = J.cursor(r.from + o));
  }
  return i;
}
const JK = (t) => pr(t, (e) => Zi(t, e, !0)), eq = (t) => pr(t, (e) => Zi(t, e, !1)), tq = (t) => pr(t, (e) => Zi(t, e, !sn(t))), nq = (t) => pr(t, (e) => Zi(t, e, sn(t))), rq = (t) => pr(t, (e) => J.cursor(t.lineBlockAt(e.head).from, 1)), iq = (t) => pr(t, (e) => J.cursor(t.lineBlockAt(e.head).to, -1));
function oq(t, e, n) {
  let r = !1, i = ra(t.selection, (o) => {
    let s = Mr(t, o.head, -1) || Mr(t, o.head, 1) || o.head > 0 && Mr(t, o.head - 1, 1) || o.head < t.doc.length && Mr(t, o.head + 1, -1);
    if (!s || !s.end)
      return o;
    r = !0;
    let a = s.start.from == o.head ? s.end.to : s.end.from;
    return J.cursor(a);
  });
  return r ? (e(Hr(t, i)), !0) : !1;
}
const sq = ({ state: t, dispatch: e }) => oq(t, e);
function Jn(t, e) {
  let n = ra(t.state.selection, (r) => {
    let i = e(r);
    return J.range(r.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
  });
  return n.eq(t.state.selection) ? !1 : (t.dispatch(Hr(t.state, n)), !0);
}
function j4(t, e) {
  return Jn(t, (n) => t.moveByChar(n, e));
}
const X4 = (t) => j4(t, !sn(t)), Z4 = (t) => j4(t, sn(t));
function Q4(t, e) {
  return Jn(t, (n) => t.moveByGroup(n, e));
}
const aq = (t) => Q4(t, !sn(t)), lq = (t) => Q4(t, sn(t)), cq = (t) => Jn(t, (e) => of(t.state, e, !sn(t))), uq = (t) => Jn(t, (e) => of(t.state, e, sn(t)));
function J4(t, e) {
  return Jn(t, (n) => t.moveVertically(n, e));
}
const eC = (t) => J4(t, !1), tC = (t) => J4(t, !0);
function nC(t, e) {
  return Jn(t, (n) => t.moveVertically(n, e, G4(t).height));
}
const qb = (t) => nC(t, !1), Gb = (t) => nC(t, !0), hq = (t) => Jn(t, (e) => Zi(t, e, !0)), fq = (t) => Jn(t, (e) => Zi(t, e, !1)), dq = (t) => Jn(t, (e) => Zi(t, e, !sn(t))), gq = (t) => Jn(t, (e) => Zi(t, e, sn(t))), pq = (t) => Jn(t, (e) => J.cursor(t.lineBlockAt(e.head).from)), mq = (t) => Jn(t, (e) => J.cursor(t.lineBlockAt(e.head).to)), Yb = ({ state: t, dispatch: e }) => (e(Hr(t, { anchor: 0 })), !0), jb = ({ state: t, dispatch: e }) => (e(Hr(t, { anchor: t.doc.length })), !0), Xb = ({ state: t, dispatch: e }) => (e(Hr(t, { anchor: t.selection.main.anchor, head: 0 })), !0), Zb = ({ state: t, dispatch: e }) => (e(Hr(t, { anchor: t.selection.main.anchor, head: t.doc.length })), !0), vq = ({ state: t, dispatch: e }) => (e(t.update({ selection: { anchor: 0, head: t.doc.length }, userEvent: "select" })), !0), bq = ({ state: t, dispatch: e }) => {
  let n = sf(t).map(({ from: r, to: i }) => J.range(r, Math.min(i + 1, t.doc.length)));
  return e(t.update({ selection: J.create(n), userEvent: "select" })), !0;
}, wq = ({ state: t, dispatch: e }) => {
  let n = ra(t.selection, (r) => {
    let i = on(t), o = i.resolveStack(r.from, 1);
    if (r.empty) {
      let s = i.resolveStack(r.from, -1);
      s.node.from >= o.node.from && s.node.to <= o.node.to && (o = s);
    }
    for (let s = o; s; s = s.next) {
      let { node: a } = s;
      if ((a.from < r.from && a.to >= r.to || a.to > r.to && a.from <= r.from) && s.next)
        return J.range(a.to, a.from);
    }
    return r;
  });
  return n.eq(t.selection) ? !1 : (e(Hr(t, n)), !0);
}, xq = ({ state: t, dispatch: e }) => {
  let n = t.selection, r = null;
  return n.ranges.length > 1 ? r = J.create([n.main]) : n.main.empty || (r = J.create([J.cursor(n.main.head)])), r ? (e(Hr(t, r)), !0) : !1;
};
function Dl(t, e) {
  if (t.state.readOnly)
    return !1;
  let n = "delete.selection", { state: r } = t, i = r.changeByRange((o) => {
    let { from: s, to: a } = o;
    if (s == a) {
      let c = e(o);
      c < s ? (n = "delete.backward", c = au(t, c, !1)) : c > s && (n = "delete.forward", c = au(t, c, !0)), s = Math.min(s, c), a = Math.max(a, c);
    } else
      s = au(t, s, !1), a = au(t, a, !0);
    return s == a ? { range: o } : { changes: { from: s, to: a }, range: J.cursor(s, s < o.head ? -1 : 1) };
  });
  return i.changes.empty ? !1 : (t.dispatch(r.update(i, {
    scrollIntoView: !0,
    userEvent: n,
    effects: n == "delete.selection" ? fe.announce.of(r.phrase("Selection deleted")) : void 0
  })), !0);
}
function au(t, e, n) {
  if (t instanceof fe)
    for (let r of t.state.facet(fe.atomicRanges).map((i) => i(t)))
      r.between(e, e, (i, o) => {
        i < e && o > e && (e = n ? o : i);
      });
  return e;
}
const rC = (t, e, n) => Dl(t, (r) => {
  let i = r.from, { state: o } = t, s = o.doc.lineAt(i), a, c;
  if (n && !e && i > s.from && i < s.from + 200 && !/[^ \t]/.test(a = s.text.slice(0, i - s.from))) {
    if (a[a.length - 1] == "	")
      return i - 1;
    let h = na(a, o.tabSize), f = h % ih(o) || ih(o);
    for (let d = 0; d < f && a[a.length - 1 - d] == " "; d++)
      i--;
    c = i;
  } else
    c = Zt(s.text, i - s.from, e, e) + s.from, c == i && s.number != (e ? o.doc.lines : 1) ? c += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(s.text.slice(c - s.from, i - s.from)) && (c = Zt(s.text, c - s.from, !1, !1) + s.from);
  return c;
}), ng = (t) => rC(t, !1, !0), iC = (t) => rC(t, !0, !1), oC = (t, e) => Dl(t, (n) => {
  let r = n.head, { state: i } = t, o = i.doc.lineAt(r), s = i.charCategorizer(r);
  for (let a = null; ; ) {
    if (r == (e ? o.to : o.from)) {
      r == n.head && o.number != (e ? i.doc.lines : 1) && (r += e ? 1 : -1);
      break;
    }
    let c = Zt(o.text, r - o.from, e) + o.from, h = o.text.slice(Math.min(r, c) - o.from, Math.max(r, c) - o.from), f = s(h);
    if (a != null && f != a)
      break;
    (h != " " || r != n.head) && (a = f), r = c;
  }
  return r;
}), sC = (t) => oC(t, !1), yq = (t) => oC(t, !0), Cq = (t) => Dl(t, (e) => {
  let n = t.lineBlockAt(e.head).to;
  return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1);
}), $q = (t) => Dl(t, (e) => {
  let n = t.moveToLineBoundary(e, !1).head;
  return e.head > n ? n : Math.max(0, e.head - 1);
}), Sq = (t) => Dl(t, (e) => {
  let n = t.moveToLineBoundary(e, !0).head;
  return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1);
}), Aq = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let n = t.changeByRange((r) => ({
    changes: { from: r.from, to: r.to, insert: nt.of(["", ""]) },
    range: J.cursor(r.from)
  }));
  return e(t.update(n, { scrollIntoView: !0, userEvent: "input" })), !0;
}, kq = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let n = t.changeByRange((r) => {
    if (!r.empty || r.from == 0 || r.from == t.doc.length)
      return { range: r };
    let i = r.from, o = t.doc.lineAt(i), s = i == o.from ? i - 1 : Zt(o.text, i - o.from, !1) + o.from, a = i == o.to ? i + 1 : Zt(o.text, i - o.from, !0) + o.from;
    return {
      changes: { from: s, to: a, insert: t.doc.slice(i, a).append(t.doc.slice(s, i)) },
      range: J.cursor(a)
    };
  });
  return n.changes.empty ? !1 : (e(t.update(n, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function sf(t) {
  let e = [], n = -1;
  for (let r of t.selection.ranges) {
    let i = t.doc.lineAt(r.from), o = t.doc.lineAt(r.to);
    if (!r.empty && r.to == o.from && (o = t.doc.lineAt(r.to - 1)), n >= i.number) {
      let s = e[e.length - 1];
      s.to = o.to, s.ranges.push(r);
    } else
      e.push({ from: i.from, to: o.to, ranges: [r] });
    n = o.number + 1;
  }
  return e;
}
function aC(t, e, n) {
  if (t.readOnly)
    return !1;
  let r = [], i = [];
  for (let o of sf(t)) {
    if (n ? o.to == t.doc.length : o.from == 0)
      continue;
    let s = t.doc.lineAt(n ? o.to + 1 : o.from - 1), a = s.length + 1;
    if (n) {
      r.push({ from: o.to, to: s.to }, { from: o.from, insert: s.text + t.lineBreak });
      for (let c of o.ranges)
        i.push(J.range(Math.min(t.doc.length, c.anchor + a), Math.min(t.doc.length, c.head + a)));
    } else {
      r.push({ from: s.from, to: o.from }, { from: o.to, insert: t.lineBreak + s.text });
      for (let c of o.ranges)
        i.push(J.range(c.anchor - a, c.head - a));
    }
  }
  return r.length ? (e(t.update({
    changes: r,
    scrollIntoView: !0,
    selection: J.create(i, t.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const Mq = ({ state: t, dispatch: e }) => aC(t, e, !1), Tq = ({ state: t, dispatch: e }) => aC(t, e, !0);
function lC(t, e, n) {
  if (t.readOnly)
    return !1;
  let r = [];
  for (let i of sf(t))
    n ? r.push({ from: i.from, insert: t.doc.slice(i.from, i.to) + t.lineBreak }) : r.push({ from: i.to, insert: t.lineBreak + t.doc.slice(i.from, i.to) });
  return e(t.update({ changes: r, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const Rq = ({ state: t, dispatch: e }) => lC(t, e, !1), Eq = ({ state: t, dispatch: e }) => lC(t, e, !0), Oq = (t) => {
  if (t.state.readOnly)
    return !1;
  let { state: e } = t, n = e.changes(sf(e).map(({ from: i, to: o }) => (i > 0 ? i-- : o < e.doc.length && o++, { from: i, to: o }))), r = ra(e.selection, (i) => {
    let o;
    if (t.lineWrapping) {
      let s = t.lineBlockAt(i.head), a = t.coordsAtPos(i.head, i.assoc || 1);
      a && (o = s.bottom + t.documentTop - a.bottom + t.defaultLineHeight / 2);
    }
    return t.moveVertically(i, !0, o);
  }).map(n);
  return t.dispatch({ changes: n, selection: r, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function Dq(t, e) {
  if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let n = on(t).resolveInner(e), r = n.childBefore(e), i = n.childAfter(e), o;
  return r && i && r.to <= e && i.from >= e && (o = r.type.prop(Ge.closedBy)) && o.indexOf(i.name) > -1 && t.doc.lineAt(r.to).from == t.doc.lineAt(i.from).from && !/\S/.test(t.sliceDoc(r.to, i.from)) ? { from: r.to, to: i.from } : null;
}
const Qb = /* @__PURE__ */ cC(!1), Iq = /* @__PURE__ */ cC(!0);
function cC(t) {
  return ({ state: e, dispatch: n }) => {
    if (e.readOnly)
      return !1;
    let r = e.changeByRange((i) => {
      let { from: o, to: s } = i, a = e.doc.lineAt(o), c = !t && o == s && Dq(e, o);
      t && (o = s = (s <= a.to ? a : e.doc.lineAt(s)).to);
      let h = new ef(e, { simulateBreak: o, simulateDoubleBreak: !!c }), f = Pp(h, o);
      for (f == null && (f = na(/^\s*/.exec(e.doc.lineAt(o).text)[0], e.tabSize)); s < a.to && /\s/.test(a.text[s - a.from]); )
        s++;
      c ? { from: o, to: s } = c : o > a.from && o < a.from + 100 && !/\S/.test(a.text.slice(0, o)) && (o = a.from);
      let d = ["", al(e, f)];
      return c && d.push(al(e, h.lineIndent(a.from, -1))), {
        changes: { from: o, to: s, insert: nt.of(d) },
        range: J.cursor(o + 1 + d[1].length)
      };
    });
    return n(e.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function Kp(t, e) {
  let n = -1;
  return t.changeByRange((r) => {
    let i = [];
    for (let s = r.from; s <= r.to; ) {
      let a = t.doc.lineAt(s);
      a.number > n && (r.empty || r.to > a.from) && (e(a, i, r), n = a.number), s = a.to + 1;
    }
    let o = t.changes(i);
    return {
      changes: i,
      range: J.range(o.mapPos(r.anchor, 1), o.mapPos(r.head, 1))
    };
  });
}
const _q = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let n = /* @__PURE__ */ Object.create(null), r = new ef(t, { overrideIndentation: (o) => {
    let s = n[o];
    return s ?? -1;
  } }), i = Kp(t, (o, s, a) => {
    let c = Pp(r, o.from);
    if (c == null)
      return;
    /\S/.test(o.text) || (c = 0);
    let h = /^\s*/.exec(o.text)[0], f = al(t, c);
    (h != f || a.from < o.from + h.length) && (n[o.from] = c, s.push({ from: o.from, to: o.from + h.length, insert: f }));
  });
  return i.changes.empty || e(t.update(i, { userEvent: "indent" })), !0;
}, uC = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(Kp(t, (n, r) => {
  r.push({ from: n.from, insert: t.facet(Jh) });
}), { userEvent: "input.indent" })), !0), hC = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(Kp(t, (n, r) => {
  let i = /^\s*/.exec(n.text)[0];
  if (!i)
    return;
  let o = na(i, t.tabSize), s = 0, a = al(t, Math.max(0, o - ih(t)));
  for (; s < i.length && s < a.length && i.charCodeAt(s) == a.charCodeAt(s); )
    s++;
  r.push({ from: n.from + s, to: n.from + i.length, insert: a.slice(s) });
}), { userEvent: "delete.dedent" })), !0), Lq = (t) => (t.setTabFocusMode(), !0), Bq = [
  { key: "Ctrl-b", run: P4, shift: X4, preventDefault: !0 },
  { key: "Ctrl-f", run: W4, shift: Z4 },
  { key: "Ctrl-p", run: K4, shift: eC },
  { key: "Ctrl-n", run: q4, shift: tC },
  { key: "Ctrl-a", run: rq, shift: pq },
  { key: "Ctrl-e", run: iq, shift: mq },
  { key: "Ctrl-d", run: iC },
  { key: "Ctrl-h", run: ng },
  { key: "Ctrl-k", run: Cq },
  { key: "Ctrl-Alt-h", run: sC },
  { key: "Ctrl-o", run: Aq },
  { key: "Ctrl-t", run: kq },
  { key: "Ctrl-v", run: tg }
], Nq = /* @__PURE__ */ [
  { key: "ArrowLeft", run: P4, shift: X4, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: YK, shift: aq, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: tq, shift: dq, preventDefault: !0 },
  { key: "ArrowRight", run: W4, shift: Z4, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: jK, shift: lq, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: nq, shift: gq, preventDefault: !0 },
  { key: "ArrowUp", run: K4, shift: eC, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: Yb, shift: Xb },
  { mac: "Ctrl-ArrowUp", run: Kb, shift: qb },
  { key: "ArrowDown", run: q4, shift: tC, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: jb, shift: Zb },
  { mac: "Ctrl-ArrowDown", run: tg, shift: Gb },
  { key: "PageUp", run: Kb, shift: qb },
  { key: "PageDown", run: tg, shift: Gb },
  { key: "Home", run: eq, shift: fq, preventDefault: !0 },
  { key: "Mod-Home", run: Yb, shift: Xb },
  { key: "End", run: JK, shift: hq, preventDefault: !0 },
  { key: "Mod-End", run: jb, shift: Zb },
  { key: "Enter", run: Qb, shift: Qb },
  { key: "Mod-a", run: vq },
  { key: "Backspace", run: ng, shift: ng },
  { key: "Delete", run: iC },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: sC },
  { key: "Mod-Delete", mac: "Alt-Delete", run: yq },
  { mac: "Mod-Backspace", run: $q },
  { mac: "Mod-Delete", run: Sq }
].concat(/* @__PURE__ */ Bq.map((t) => ({ mac: t.key, run: t.run, shift: t.shift }))), Fq = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: ZK, shift: cq },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: QK, shift: uq },
  { key: "Alt-ArrowUp", run: Mq },
  { key: "Shift-Alt-ArrowUp", run: Rq },
  { key: "Alt-ArrowDown", run: Tq },
  { key: "Shift-Alt-ArrowDown", run: Eq },
  { key: "Escape", run: xq },
  { key: "Mod-Enter", run: Iq },
  { key: "Alt-l", mac: "Ctrl-l", run: bq },
  { key: "Mod-i", run: wq, preventDefault: !0 },
  { key: "Mod-[", run: hC },
  { key: "Mod-]", run: uC },
  { key: "Mod-Alt-\\", run: _q },
  { key: "Shift-Mod-k", run: Oq },
  { key: "Shift-Mod-\\", run: sq },
  { key: "Mod-/", run: RK },
  { key: "Alt-A", run: OK },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: Lq }
].concat(Nq), Vq = { key: "Tab", run: uC, shift: hC };
function ut() {
  var t = arguments[0];
  typeof t == "string" && (t = document.createElement(t));
  var e = 1, n = arguments[1];
  if (n && typeof n == "object" && n.nodeType == null && !Array.isArray(n)) {
    for (var r in n) if (Object.prototype.hasOwnProperty.call(n, r)) {
      var i = n[r];
      typeof i == "string" ? t.setAttribute(r, i) : i != null && (t[r] = i);
    }
    e++;
  }
  for (; e < arguments.length; e++) fC(t, arguments[e]);
  return t;
}
function fC(t, e) {
  if (typeof e == "string")
    t.appendChild(document.createTextNode(e));
  else if (e != null) if (e.nodeType != null)
    t.appendChild(e);
  else if (Array.isArray(e))
    for (var n = 0; n < e.length; n++) fC(t, e[n]);
  else
    throw new RangeError("Unsupported child node: " + e);
}
const Jb = typeof String.prototype.normalize == "function" ? (t) => t.normalize("NFKD") : (t) => t;
class zs {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, n, r = 0, i = e.length, o, s) {
    this.test = s, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(r, i), this.bufferStart = r, this.normalize = o ? (a) => o(Jb(a)) : Jb, this.query = this.normalize(n);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return wn(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let n = Ap(e), r = this.bufferStart + this.bufferPos;
      this.bufferPos += Ar(e);
      let i = this.normalize(n);
      if (i.length)
        for (let o = 0, s = r; ; o++) {
          let a = i.charCodeAt(o), c = this.match(a, s, this.bufferPos + this.bufferStart);
          if (o == i.length - 1) {
            if (c)
              return this.value = c, this;
            break;
          }
          s == r && o < n.length && n.charCodeAt(o) == a && s++;
        }
    }
  }
  match(e, n, r) {
    let i = null;
    for (let o = 0; o < this.matches.length; o += 2) {
      let s = this.matches[o], a = !1;
      this.query.charCodeAt(s) == e && (s == this.query.length - 1 ? i = { from: this.matches[o + 1], to: r } : (this.matches[o]++, a = !0)), a || (this.matches.splice(o, 2), o -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: n, to: r } : this.matches.push(1, n)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null), i;
  }
}
typeof Symbol < "u" && (zs.prototype[Symbol.iterator] = function() {
  return this;
});
const dC = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, qp = "gm" + (/x/.unicode == null ? "" : "u");
class gC {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, n, r, i = 0, o = e.length) {
    if (this.text = e, this.to = o, this.curLine = "", this.done = !1, this.value = dC, /\\[sWDnr]|\n|\r|\[\^/.test(n))
      return new pC(e, n, r, i, o);
    this.re = new RegExp(n, qp + (r?.ignoreCase ? "i" : "")), this.test = r?.test, this.iter = e.iter();
    let s = e.lineAt(i);
    this.curLineStart = s.from, this.matchPos = lh(e, i), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let n = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (n) {
        let r = this.curLineStart + n.index, i = r + n[0].length;
        if (this.matchPos = lh(this.text, i + (r == i ? 1 : 0)), r == this.curLineStart + this.curLine.length && this.nextLine(), (r < i || r > this.value.to) && (!this.test || this.test(r, i, n)))
          return this.value = { from: r, to: i, match: n }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const k0 = /* @__PURE__ */ new WeakMap();
class Ts {
  constructor(e, n) {
    this.from = e, this.text = n;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, n, r) {
    let i = k0.get(e);
    if (!i || i.from >= r || i.to <= n) {
      let a = new Ts(n, e.sliceString(n, r));
      return k0.set(e, a), a;
    }
    if (i.from == n && i.to == r)
      return i;
    let { text: o, from: s } = i;
    return s > n && (o = e.sliceString(n, s) + o, s = n), i.to < r && (o += e.sliceString(i.to, r)), k0.set(e, new Ts(s, o)), new Ts(n, o.slice(n - s, r - s));
  }
}
class pC {
  constructor(e, n, r, i, o) {
    this.text = e, this.to = o, this.done = !1, this.value = dC, this.matchPos = lh(e, i), this.re = new RegExp(n, qp + (r?.ignoreCase ? "i" : "")), this.test = r?.test, this.flat = Ts.get(e, i, this.chunkEnd(
      i + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, n = this.re.exec(this.flat.text);
      if (n && !n[0] && n.index == e && (this.re.lastIndex = e + 1, n = this.re.exec(this.flat.text)), n) {
        let r = this.flat.from + n.index, i = r + n[0].length;
        if ((this.flat.to >= this.to || n.index + n[0].length <= this.flat.text.length - 10) && (!this.test || this.test(r, i, n)))
          return this.value = { from: r, to: i, match: n }, this.matchPos = lh(this.text, i + (r == i ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = Ts.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (gC.prototype[Symbol.iterator] = pC.prototype[Symbol.iterator] = function() {
  return this;
});
function Hq(t) {
  try {
    return new RegExp(t, qp), !0;
  } catch {
    return !1;
  }
}
function lh(t, e) {
  if (e >= t.length)
    return e;
  let n = t.lineAt(e), r;
  for (; e < n.to && (r = n.text.charCodeAt(e - n.from)) >= 56320 && r < 57344; )
    e++;
  return e;
}
function rg(t) {
  let e = String(t.state.doc.lineAt(t.state.selection.main.head).number), n = ut("input", { class: "cm-textfield", name: "line", value: e }), r = ut("form", {
    class: "cm-gotoLine",
    onkeydown: (o) => {
      o.keyCode == 27 ? (o.preventDefault(), t.dispatch({ effects: za.of(!1) }), t.focus()) : o.keyCode == 13 && (o.preventDefault(), i());
    },
    onsubmit: (o) => {
      o.preventDefault(), i();
    }
  }, ut("label", t.state.phrase("Go to line"), ": ", n), " ", ut("button", { class: "cm-button", type: "submit" }, t.state.phrase("go")), ut("button", {
    name: "close",
    onclick: () => {
      t.dispatch({ effects: za.of(!1) }), t.focus();
    },
    "aria-label": t.state.phrase("close"),
    type: "button"
  }, ["×"]));
  function i() {
    let o = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(n.value);
    if (!o)
      return;
    let { state: s } = t, a = s.doc.lineAt(s.selection.main.head), [, c, h, f, d] = o, p = f ? +f.slice(1) : 0, v = h ? +h : a.number;
    if (h && d) {
      let y = v / 100;
      c && (y = y * (c == "-" ? -1 : 1) + a.number / s.doc.lines), v = Math.round(s.doc.lines * y);
    } else h && c && (v = v * (c == "-" ? -1 : 1) + a.number);
    let w = s.doc.line(Math.max(1, Math.min(s.doc.lines, v))), b = J.cursor(w.from + Math.max(0, Math.min(p, w.length)));
    t.dispatch({
      effects: [za.of(!1), fe.scrollIntoView(b.from, { y: "center" })],
      selection: b
    }), t.focus();
  }
  return { dom: r };
}
const za = /* @__PURE__ */ Ne.define(), ew = /* @__PURE__ */ Kt.define({
  create() {
    return !0;
  },
  update(t, e) {
    for (let n of e.effects)
      n.is(za) && (t = n.value);
    return t;
  },
  provide: (t) => sl.from(t, (e) => e ? rg : null)
}), Pq = (t) => {
  let e = ol(t, rg);
  if (!e) {
    let n = [za.of(!0)];
    t.state.field(ew, !1) == null && n.push(Ne.appendConfig.of([ew, Wq])), t.dispatch({ effects: n }), e = ol(t, rg);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, Wq = /* @__PURE__ */ fe.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    position: "relative",
    "& label": { fontSize: "80%" },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      bottom: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: "0"
    }
  }
}), zq = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, Uq = /* @__PURE__ */ pe.define({
  combine(t) {
    return Vr(t, zq, {
      highlightWordAroundCursor: (e, n) => e || n,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function Kq(t) {
  return [Xq, jq];
}
const qq = /* @__PURE__ */ Se.mark({ class: "cm-selectionMatch" }), Gq = /* @__PURE__ */ Se.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function tw(t, e, n, r) {
  return (n == 0 || t(e.sliceDoc(n - 1, n)) != bt.Word) && (r == e.doc.length || t(e.sliceDoc(r, r + 1)) != bt.Word);
}
function Yq(t, e, n, r) {
  return t(e.sliceDoc(n, n + 1)) == bt.Word && t(e.sliceDoc(r - 1, r)) == bt.Word;
}
const jq = /* @__PURE__ */ Mt.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = t.state.facet(Uq), { state: n } = t, r = n.selection;
    if (r.ranges.length > 1)
      return Se.none;
    let i = r.main, o, s = null;
    if (i.empty) {
      if (!e.highlightWordAroundCursor)
        return Se.none;
      let c = n.wordAt(i.head);
      if (!c)
        return Se.none;
      s = n.charCategorizer(i.head), o = n.sliceDoc(c.from, c.to);
    } else {
      let c = i.to - i.from;
      if (c < e.minSelectionLength || c > 200)
        return Se.none;
      if (e.wholeWords) {
        if (o = n.sliceDoc(i.from, i.to), s = n.charCategorizer(i.head), !(tw(s, n, i.from, i.to) && Yq(s, n, i.from, i.to)))
          return Se.none;
      } else if (o = n.sliceDoc(i.from, i.to), !o)
        return Se.none;
    }
    let a = [];
    for (let c of t.visibleRanges) {
      let h = new zs(n.doc, o, c.from, c.to);
      for (; !h.next().done; ) {
        let { from: f, to: d } = h.value;
        if ((!s || tw(s, n, f, d)) && (i.empty && f <= i.from && d >= i.to ? a.push(Gq.range(f, d)) : (f >= i.to || d <= i.from) && a.push(qq.range(f, d)), a.length > e.maxMatches))
          return Se.none;
      }
    }
    return Se.set(a);
  }
}, {
  decorations: (t) => t.decorations
}), Xq = /* @__PURE__ */ fe.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), Zq = ({ state: t, dispatch: e }) => {
  let { selection: n } = t, r = J.create(n.ranges.map((i) => t.wordAt(i.head) || J.cursor(i.head)), n.mainIndex);
  return r.eq(n) ? !1 : (e(t.update({ selection: r })), !0);
};
function Qq(t, e) {
  let { main: n, ranges: r } = t.selection, i = t.wordAt(n.head), o = i && i.from == n.from && i.to == n.to;
  for (let s = !1, a = new zs(t.doc, e, r[r.length - 1].to); ; )
    if (a.next(), a.done) {
      if (s)
        return null;
      a = new zs(t.doc, e, 0, Math.max(0, r[r.length - 1].from - 1)), s = !0;
    } else {
      if (s && r.some((c) => c.from == a.value.from))
        continue;
      if (o) {
        let c = t.wordAt(a.value.from);
        if (!c || c.from != a.value.from || c.to != a.value.to)
          continue;
      }
      return a.value;
    }
}
const Jq = ({ state: t, dispatch: e }) => {
  let { ranges: n } = t.selection;
  if (n.some((o) => o.from === o.to))
    return Zq({ state: t, dispatch: e });
  let r = t.sliceDoc(n[0].from, n[0].to);
  if (t.selection.ranges.some((o) => t.sliceDoc(o.from, o.to) != r))
    return !1;
  let i = Qq(t, r);
  return i ? (e(t.update({
    selection: t.selection.addRange(J.range(i.from, i.to), !1),
    effects: fe.scrollIntoView(i.to)
  })), !0) : !1;
}, ia = /* @__PURE__ */ pe.define({
  combine(t) {
    return Vr(t, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new hG(e),
      scrollToMatch: (e) => fe.scrollIntoView(e)
    });
  }
});
class mC {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || Hq(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (n, r) => r == "n" ? `
` : r == "r" ? "\r" : r == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new rG(this) : new tG(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, n = 0, r) {
    let i = e.doc ? e : et.create({ doc: e });
    return r == null && (r = i.doc.length), this.regexp ? bs(this, i, n, r) : vs(this, i, n, r);
  }
}
class vC {
  constructor(e) {
    this.spec = e;
  }
}
function vs(t, e, n, r) {
  return new zs(e.doc, t.unquoted, n, r, t.caseSensitive ? void 0 : (i) => i.toLowerCase(), t.wholeWord ? eG(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function eG(t, e) {
  return (n, r, i, o) => ((o > n || o + i.length < r) && (o = Math.max(0, n - 2), i = t.sliceString(o, Math.min(t.length, r + 2))), (e(ch(i, n - o)) != bt.Word || e(uh(i, n - o)) != bt.Word) && (e(uh(i, r - o)) != bt.Word || e(ch(i, r - o)) != bt.Word));
}
class tG extends vC {
  constructor(e) {
    super(e);
  }
  nextMatch(e, n, r) {
    let i = vs(this.spec, e, r, e.doc.length).nextOverlapping();
    if (i.done) {
      let o = Math.min(e.doc.length, n + this.spec.unquoted.length);
      i = vs(this.spec, e, 0, o).nextOverlapping();
    }
    return i.done || i.value.from == n && i.value.to == r ? null : i.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, n, r) {
    for (let i = r; ; ) {
      let o = Math.max(n, i - 1e4 - this.spec.unquoted.length), s = vs(this.spec, e, o, i), a = null;
      for (; !s.nextOverlapping().done; )
        a = s.value;
      if (a)
        return a;
      if (o == n)
        return null;
      i -= 1e4;
    }
  }
  prevMatch(e, n, r) {
    let i = this.prevMatchInRange(e, 0, n);
    return i || (i = this.prevMatchInRange(e, Math.max(0, r - this.spec.unquoted.length), e.doc.length)), i && (i.from != n || i.to != r) ? i : null;
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, n) {
    let r = vs(this.spec, e, 0, e.doc.length), i = [];
    for (; !r.next().done; ) {
      if (i.length >= n)
        return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, n, r, i) {
    let o = vs(this.spec, e, Math.max(0, n - this.spec.unquoted.length), Math.min(r + this.spec.unquoted.length, e.doc.length));
    for (; !o.next().done; )
      i(o.value.from, o.value.to);
  }
}
function bs(t, e, n, r) {
  return new gC(e.doc, t.search, {
    ignoreCase: !t.caseSensitive,
    test: t.wholeWord ? nG(e.charCategorizer(e.selection.main.head)) : void 0
  }, n, r);
}
function ch(t, e) {
  return t.slice(Zt(t, e, !1), e);
}
function uh(t, e) {
  return t.slice(e, Zt(t, e));
}
function nG(t) {
  return (e, n, r) => !r[0].length || (t(ch(r.input, r.index)) != bt.Word || t(uh(r.input, r.index)) != bt.Word) && (t(uh(r.input, r.index + r[0].length)) != bt.Word || t(ch(r.input, r.index + r[0].length)) != bt.Word);
}
class rG extends vC {
  nextMatch(e, n, r) {
    let i = bs(this.spec, e, r, e.doc.length).next();
    return i.done && (i = bs(this.spec, e, 0, n).next()), i.done ? null : i.value;
  }
  prevMatchInRange(e, n, r) {
    for (let i = 1; ; i++) {
      let o = Math.max(
        n,
        r - i * 1e4
        /* FindPrev.ChunkSize */
      ), s = bs(this.spec, e, o, r), a = null;
      for (; !s.next().done; )
        a = s.value;
      if (a && (o == n || a.from > o + 10))
        return a;
      if (o == n)
        return null;
    }
  }
  prevMatch(e, n, r) {
    return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, r, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (n, r) => {
      if (r == "&")
        return e.match[0];
      if (r == "$")
        return "$";
      for (let i = r.length; i > 0; i--) {
        let o = +r.slice(0, i);
        if (o > 0 && o < e.match.length)
          return e.match[o] + r.slice(i);
      }
      return n;
    });
  }
  matchAll(e, n) {
    let r = bs(this.spec, e, 0, e.doc.length), i = [];
    for (; !r.next().done; ) {
      if (i.length >= n)
        return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, n, r, i) {
    let o = bs(this.spec, e, Math.max(
      0,
      n - 250
      /* RegExp.HighlightMargin */
    ), Math.min(r + 250, e.doc.length));
    for (; !o.next().done; )
      i(o.value.from, o.value.to);
  }
}
const ll = /* @__PURE__ */ Ne.define(), Gp = /* @__PURE__ */ Ne.define(), Vi = /* @__PURE__ */ Kt.define({
  create(t) {
    return new M0(ig(t).create(), null);
  },
  update(t, e) {
    for (let n of e.effects)
      n.is(ll) ? t = new M0(n.value.create(), t.panel) : n.is(Gp) && (t = new M0(t.query, n.value ? Yp : null));
    return t;
  },
  provide: (t) => sl.from(t, (e) => e.panel)
});
class M0 {
  constructor(e, n) {
    this.query = e, this.panel = n;
  }
}
const iG = /* @__PURE__ */ Se.mark({ class: "cm-searchMatch" }), oG = /* @__PURE__ */ Se.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), sG = /* @__PURE__ */ Mt.fromClass(class {
  constructor(t) {
    this.view = t, this.decorations = this.highlight(t.state.field(Vi));
  }
  update(t) {
    let e = t.state.field(Vi);
    (e != t.startState.field(Vi) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: t, panel: e }) {
    if (!e || !t.spec.valid)
      return Se.none;
    let { view: n } = this, r = new di();
    for (let i = 0, o = n.visibleRanges, s = o.length; i < s; i++) {
      let { from: a, to: c } = o[i];
      for (; i < s - 1 && c > o[i + 1].from - 2 * 250; )
        c = o[++i].to;
      t.highlight(n.state, a, c, (h, f) => {
        let d = n.state.selection.ranges.some((p) => p.from == h && p.to == f);
        r.add(h, f, d ? oG : iG);
      });
    }
    return r.finish();
  }
}, {
  decorations: (t) => t.decorations
});
function Il(t) {
  return (e) => {
    let n = e.state.field(Vi, !1);
    return n && n.query.spec.valid ? t(e, n) : xC(e);
  };
}
const hh = /* @__PURE__ */ Il((t, { query: e }) => {
  let { to: n } = t.state.selection.main, r = e.nextMatch(t.state, n, n);
  if (!r)
    return !1;
  let i = J.single(r.from, r.to), o = t.state.facet(ia);
  return t.dispatch({
    selection: i,
    effects: [jp(t, r), o.scrollToMatch(i.main, t)],
    userEvent: "select.search"
  }), wC(t), !0;
}), fh = /* @__PURE__ */ Il((t, { query: e }) => {
  let { state: n } = t, { from: r } = n.selection.main, i = e.prevMatch(n, r, r);
  if (!i)
    return !1;
  let o = J.single(i.from, i.to), s = t.state.facet(ia);
  return t.dispatch({
    selection: o,
    effects: [jp(t, i), s.scrollToMatch(o.main, t)],
    userEvent: "select.search"
  }), wC(t), !0;
}), aG = /* @__PURE__ */ Il((t, { query: e }) => {
  let n = e.matchAll(t.state, 1e3);
  return !n || !n.length ? !1 : (t.dispatch({
    selection: J.create(n.map((r) => J.range(r.from, r.to))),
    userEvent: "select.search.matches"
  }), !0);
}), lG = ({ state: t, dispatch: e }) => {
  let n = t.selection;
  if (n.ranges.length > 1 || n.main.empty)
    return !1;
  let { from: r, to: i } = n.main, o = [], s = 0;
  for (let a = new zs(t.doc, t.sliceDoc(r, i)); !a.next().done; ) {
    if (o.length > 1e3)
      return !1;
    a.value.from == r && (s = o.length), o.push(J.range(a.value.from, a.value.to));
  }
  return e(t.update({
    selection: J.create(o, s),
    userEvent: "select.search.matches"
  })), !0;
}, nw = /* @__PURE__ */ Il((t, { query: e }) => {
  let { state: n } = t, { from: r, to: i } = n.selection.main;
  if (n.readOnly)
    return !1;
  let o = e.nextMatch(n, r, r);
  if (!o)
    return !1;
  let s = o, a = [], c, h, f = [];
  s.from == r && s.to == i && (h = n.toText(e.getReplacement(s)), a.push({ from: s.from, to: s.to, insert: h }), s = e.nextMatch(n, s.from, s.to), f.push(fe.announce.of(n.phrase("replaced match on line $", n.doc.lineAt(r).number) + ".")));
  let d = t.state.changes(a);
  return s && (c = J.single(s.from, s.to).map(d), f.push(jp(t, s)), f.push(n.facet(ia).scrollToMatch(c.main, t))), t.dispatch({
    changes: d,
    selection: c,
    effects: f,
    userEvent: "input.replace"
  }), !0;
}), cG = /* @__PURE__ */ Il((t, { query: e }) => {
  if (t.state.readOnly)
    return !1;
  let n = e.matchAll(t.state, 1e9).map((i) => {
    let { from: o, to: s } = i;
    return { from: o, to: s, insert: e.getReplacement(i) };
  });
  if (!n.length)
    return !1;
  let r = t.state.phrase("replaced $ matches", n.length) + ".";
  return t.dispatch({
    changes: n,
    effects: fe.announce.of(r),
    userEvent: "input.replace.all"
  }), !0;
});
function Yp(t) {
  return t.state.facet(ia).createPanel(t);
}
function ig(t, e) {
  var n, r, i, o, s;
  let a = t.selection.main, c = a.empty || a.to > a.from + 100 ? "" : t.sliceDoc(a.from, a.to);
  if (e && !c)
    return e;
  let h = t.facet(ia);
  return new mC({
    search: ((n = e?.literal) !== null && n !== void 0 ? n : h.literal) ? c : c.replace(/\n/g, "\\n"),
    caseSensitive: (r = e?.caseSensitive) !== null && r !== void 0 ? r : h.caseSensitive,
    literal: (i = e?.literal) !== null && i !== void 0 ? i : h.literal,
    regexp: (o = e?.regexp) !== null && o !== void 0 ? o : h.regexp,
    wholeWord: (s = e?.wholeWord) !== null && s !== void 0 ? s : h.wholeWord
  });
}
function bC(t) {
  let e = ol(t, Yp);
  return e && e.dom.querySelector("[main-field]");
}
function wC(t) {
  let e = bC(t);
  e && e == t.root.activeElement && e.select();
}
const xC = (t) => {
  let e = t.state.field(Vi, !1);
  if (e && e.panel) {
    let n = bC(t);
    if (n && n != t.root.activeElement) {
      let r = ig(t.state, e.query.spec);
      r.valid && t.dispatch({ effects: ll.of(r) }), n.focus(), n.select();
    }
  } else
    t.dispatch({ effects: [
      Gp.of(!0),
      e ? ll.of(ig(t.state, e.query.spec)) : Ne.appendConfig.of(dG)
    ] });
  return !0;
}, yC = (t) => {
  let e = t.state.field(Vi, !1);
  if (!e || !e.panel)
    return !1;
  let n = ol(t, Yp);
  return n && n.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: Gp.of(!1) }), !0;
}, uG = [
  { key: "Mod-f", run: xC, scope: "editor search-panel" },
  { key: "F3", run: hh, shift: fh, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: hh, shift: fh, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: yC, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: lG },
  { key: "Mod-Alt-g", run: Pq },
  { key: "Mod-d", run: Jq, preventDefault: !0 }
];
class hG {
  constructor(e) {
    this.view = e;
    let n = this.query = e.state.field(Vi).query.spec;
    this.commit = this.commit.bind(this), this.searchField = ut("input", {
      value: n.search,
      placeholder: _n(e, "Find"),
      "aria-label": _n(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = ut("input", {
      value: n.replace,
      placeholder: _n(e, "Replace"),
      "aria-label": _n(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = ut("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: n.caseSensitive,
      onchange: this.commit
    }), this.reField = ut("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: n.regexp,
      onchange: this.commit
    }), this.wordField = ut("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: n.wholeWord,
      onchange: this.commit
    });
    function r(i, o, s) {
      return ut("button", { class: "cm-button", name: i, onclick: o, type: "button" }, s);
    }
    this.dom = ut("div", { onkeydown: (i) => this.keydown(i), class: "cm-search" }, [
      this.searchField,
      r("next", () => hh(e), [_n(e, "next")]),
      r("prev", () => fh(e), [_n(e, "previous")]),
      r("select", () => aG(e), [_n(e, "all")]),
      ut("label", null, [this.caseField, _n(e, "match case")]),
      ut("label", null, [this.reField, _n(e, "regexp")]),
      ut("label", null, [this.wordField, _n(e, "by word")]),
      ...e.state.readOnly ? [] : [
        ut("br"),
        this.replaceField,
        r("replace", () => nw(e), [_n(e, "replace")]),
        r("replaceAll", () => cG(e), [_n(e, "replace all")])
      ],
      ut("button", {
        name: "close",
        onclick: () => yC(e),
        "aria-label": _n(e, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let e = new mC({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: ll.of(e) }));
  }
  keydown(e) {
    Rz(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? fh : hh)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), nw(this.view));
  }
  update(e) {
    for (let n of e.transactions)
      for (let r of n.effects)
        r.is(ll) && !r.value.eq(this.query) && this.setQuery(r.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(ia).top;
  }
}
function _n(t, e) {
  return t.state.phrase(e);
}
const lu = 30, cu = /[\s\.,:;?!]/;
function jp(t, { from: e, to: n }) {
  let r = t.state.doc.lineAt(e), i = t.state.doc.lineAt(n).to, o = Math.max(r.from, e - lu), s = Math.min(i, n + lu), a = t.state.sliceDoc(o, s);
  if (o != r.from) {
    for (let c = 0; c < lu; c++)
      if (!cu.test(a[c + 1]) && cu.test(a[c])) {
        a = a.slice(c);
        break;
      }
  }
  if (s != i) {
    for (let c = a.length - 1; c > a.length - lu; c--)
      if (!cu.test(a[c - 1]) && cu.test(a[c])) {
        a = a.slice(0, c);
        break;
      }
  }
  return fe.announce.of(`${t.state.phrase("current match")}. ${a} ${t.state.phrase("on line")} ${r.number}.`);
}
const fG = /* @__PURE__ */ fe.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), dG = [
  Vi,
  /* @__PURE__ */ Wo.low(sG),
  fG
];
class CC {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(e, n, r, i) {
    this.state = e, this.pos = n, this.explicit = r, this.view = i, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let n = on(this.state).resolveInner(this.pos, -1);
    for (; n && e.indexOf(n.name) < 0; )
      n = n.parent;
    return n ? {
      from: n.from,
      to: this.pos,
      text: this.state.sliceDoc(n.from, this.pos),
      type: n.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let n = this.state.doc.lineAt(this.pos), r = Math.max(n.from, this.pos - 250), i = n.text.slice(r - n.from, this.pos - n.from), o = i.search($C(e, !1));
    return o < 0 ? null : { from: r + o, to: this.pos, text: i.slice(o) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(e, n, r) {
    e == "abort" && this.abortListeners && (this.abortListeners.push(n), r && r.onDocChange && (this.abortOnDocChange = !0));
  }
}
function rw(t) {
  let e = Object.keys(t).join(""), n = /\w/.test(e);
  return n && (e = e.replace(/\w/g, "")), `[${n ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function gG(t) {
  let e = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  for (let { label: i } of t) {
    e[i[0]] = !0;
    for (let o = 1; o < i.length; o++)
      n[i[o]] = !0;
  }
  let r = rw(e) + rw(n) + "*$";
  return [new RegExp("^" + r), new RegExp(r)];
}
function pG(t) {
  let e = t.map((i) => typeof i == "string" ? { label: i } : i), [n, r] = e.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : gG(e);
  return (i) => {
    let o = i.matchBefore(r);
    return o || i.explicit ? { from: o ? o.from : i.pos, options: e, validFor: n } : null;
  };
}
let iw = class {
  constructor(e, n, r, i) {
    this.completion = e, this.source = n, this.match = r, this.score = i;
  }
};
function $o(t) {
  return t.selection.main.from;
}
function $C(t, e) {
  var n;
  let { source: r } = t, i = e && r[0] != "^", o = r[r.length - 1] != "$";
  return !i && !o ? t : new RegExp(`${i ? "^" : ""}(?:${r})${o ? "$" : ""}`, (n = t.flags) !== null && n !== void 0 ? n : t.ignoreCase ? "i" : "");
}
const SC = /* @__PURE__ */ Fr.define();
function mG(t, e, n, r) {
  let { main: i } = t.selection, o = n - i.from, s = r - i.from;
  return Object.assign(Object.assign({}, t.changeByRange((a) => {
    if (a != i && n != r && t.sliceDoc(a.from + o, a.from + s) != t.sliceDoc(n, r))
      return { range: a };
    let c = t.toText(e);
    return {
      changes: { from: a.from + o, to: r == i.from ? a.to : a.from + s, insert: c },
      range: J.cursor(a.from + o + c.length)
    };
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const ow = /* @__PURE__ */ new WeakMap();
function vG(t) {
  if (!Array.isArray(t))
    return t;
  let e = ow.get(t);
  return e || ow.set(t, e = pG(t)), e;
}
const dh = /* @__PURE__ */ Ne.define(), cl = /* @__PURE__ */ Ne.define();
class bG {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let n = 0; n < e.length; ) {
      let r = wn(e, n), i = Ar(r);
      this.chars.push(r);
      let o = e.slice(n, n + i), s = o.toUpperCase();
      this.folded.push(wn(s == o ? o.toLowerCase() : s, 0)), n += i;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, n) {
    return this.score = e, this.matched = n, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return null;
    let { chars: n, folded: r, any: i, precise: o, byWord: s } = this;
    if (n.length == 1) {
      let A = wn(e, 0), k = Ar(A), T = k == e.length ? 0 : -100;
      if (A != n[0]) if (A == r[0])
        T += -200;
      else
        return null;
      return this.ret(T, [0, k]);
    }
    let a = e.indexOf(this.pattern);
    if (a == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let c = n.length, h = 0;
    if (a < 0) {
      for (let A = 0, k = Math.min(e.length, 200); A < k && h < c; ) {
        let T = wn(e, A);
        (T == n[h] || T == r[h]) && (i[h++] = A), A += Ar(T);
      }
      if (h < c)
        return null;
    }
    let f = 0, d = 0, p = !1, v = 0, w = -1, b = -1, y = /[a-z]/.test(e), $ = !0;
    for (let A = 0, k = Math.min(e.length, 200), T = 0; A < k && d < c; ) {
      let R = wn(e, A);
      a < 0 && (f < c && R == n[f] && (o[f++] = A), v < c && (R == n[v] || R == r[v] ? (v == 0 && (w = A), b = A + 1, v++) : v = 0));
      let _, D = R < 255 ? R >= 48 && R <= 57 || R >= 97 && R <= 122 ? 2 : R >= 65 && R <= 90 ? 1 : 0 : (_ = Ap(R)) != _.toLowerCase() ? 1 : _ != _.toUpperCase() ? 2 : 0;
      (!A || D == 1 && y || T == 0 && D != 0) && (n[d] == R || r[d] == R && (p = !0) ? s[d++] = A : s.length && ($ = !1)), T = D, A += Ar(R);
    }
    return d == c && s[0] == 0 && $ ? this.result(-100 + (p ? -200 : 0), s, e) : v == c && w == 0 ? this.ret(-200 - e.length + (b == e.length ? 0 : -100), [0, b]) : a > -1 ? this.ret(-700 - e.length, [a, a + this.pattern.length]) : v == c ? this.ret(-900 - e.length, [w, b]) : d == c ? this.result(-100 + (p ? -200 : 0) + -700 + ($ ? 0 : -1100), s, e) : n.length == 2 ? null : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
  }
  result(e, n, r) {
    let i = [], o = 0;
    for (let s of n) {
      let a = s + (this.astral ? Ar(wn(r, s)) : 1);
      o && i[o - 1] == s ? i[o - 1] = a : (i[o++] = s, i[o++] = a);
    }
    return this.ret(e - r.length, i);
  }
}
class wG {
  constructor(e) {
    this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
  }
  match(e) {
    if (e.length < this.pattern.length)
      return null;
    let n = e.slice(0, this.pattern.length), r = n == this.pattern ? 0 : n.toLowerCase() == this.folded ? -200 : null;
    return r == null ? null : (this.matched = [0, n.length], this.score = r + (e.length == this.pattern.length ? 0 : -100), this);
  }
}
const Wt = /* @__PURE__ */ pe.define({
  combine(t) {
    return Vr(t, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: xG,
      filterStrict: !1,
      compareCompletions: (e, n) => e.label.localeCompare(n.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, n) => e && n,
      closeOnBlur: (e, n) => e && n,
      icons: (e, n) => e && n,
      tooltipClass: (e, n) => (r) => sw(e(r), n(r)),
      optionClass: (e, n) => (r) => sw(e(r), n(r)),
      addToOptions: (e, n) => e.concat(n),
      filterStrict: (e, n) => e || n
    });
  }
});
function sw(t, e) {
  return t ? e ? t + " " + e : t : e;
}
function xG(t, e, n, r, i, o) {
  let s = t.textDirection == mt.RTL, a = s, c = !1, h = "top", f, d, p = e.left - i.left, v = i.right - e.right, w = r.right - r.left, b = r.bottom - r.top;
  if (a && p < Math.min(w, v) ? a = !1 : !a && v < Math.min(w, p) && (a = !0), w <= (a ? p : v))
    f = Math.max(i.top, Math.min(n.top, i.bottom - b)) - e.top, d = Math.min(400, a ? p : v);
  else {
    c = !0, d = Math.min(
      400,
      (s ? e.right : i.right - e.left) - 30
      /* Info.Margin */
    );
    let A = i.bottom - e.bottom;
    A >= b || A > e.top ? f = n.bottom - e.top : (h = "bottom", f = e.bottom - n.top);
  }
  let y = (e.bottom - e.top) / o.offsetHeight, $ = (e.right - e.left) / o.offsetWidth;
  return {
    style: `${h}: ${f / y}px; max-width: ${d / $}px`,
    class: "cm-completionInfo-" + (c ? s ? "left-narrow" : "right-narrow" : a ? "left" : "right")
  };
}
function yG(t) {
  let e = t.addToOptions.slice();
  return t.icons && e.push({
    render(n) {
      let r = document.createElement("div");
      return r.classList.add("cm-completionIcon"), n.type && r.classList.add(...n.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), r.setAttribute("aria-hidden", "true"), r;
    },
    position: 20
  }), e.push({
    render(n, r, i, o) {
      let s = document.createElement("span");
      s.className = "cm-completionLabel";
      let a = n.displayLabel || n.label, c = 0;
      for (let h = 0; h < o.length; ) {
        let f = o[h++], d = o[h++];
        f > c && s.appendChild(document.createTextNode(a.slice(c, f)));
        let p = s.appendChild(document.createElement("span"));
        p.appendChild(document.createTextNode(a.slice(f, d))), p.className = "cm-completionMatchedText", c = d;
      }
      return c < a.length && s.appendChild(document.createTextNode(a.slice(c))), s;
    },
    position: 50
  }, {
    render(n) {
      if (!n.detail)
        return null;
      let r = document.createElement("span");
      return r.className = "cm-completionDetail", r.textContent = n.detail, r;
    },
    position: 80
  }), e.sort((n, r) => n.position - r.position).map((n) => n.render);
}
function T0(t, e, n) {
  if (t <= n)
    return { from: 0, to: t };
  if (e < 0 && (e = 0), e <= t >> 1) {
    let i = Math.floor(e / n);
    return { from: i * n, to: (i + 1) * n };
  }
  let r = Math.floor((t - e) / n);
  return { from: t - (r + 1) * n, to: t - r * n };
}
class CG {
  constructor(e, n, r) {
    this.view = e, this.stateField = n, this.applyCompletion = r, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (c) => this.placeInfo(c),
      key: this
    }, this.space = null, this.currentClass = "";
    let i = e.state.field(n), { options: o, selected: s } = i.open, a = e.state.facet(Wt);
    this.optionContent = yG(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = T0(o.length, s, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (c) => {
      let { options: h } = e.state.field(n).open;
      for (let f = c.target, d; f && f != this.dom; f = f.parentNode)
        if (f.nodeName == "LI" && (d = /-(\d+)$/.exec(f.id)) && +d[1] < h.length) {
          this.applyCompletion(e, h[+d[1]]), c.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (c) => {
      let h = e.state.field(this.stateField, !1);
      h && h.tooltip && e.state.facet(Wt).closeOnBlur && c.relatedTarget != e.contentDOM && e.dispatch({ effects: cl.of(null) });
    }), this.showOptions(o, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, n) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, n, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var n;
    let r = e.state.field(this.stateField), i = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), r != i) {
      let { options: o, selected: s, disabled: a } = r.open;
      (!i.open || i.open.options != o) && (this.range = T0(o.length, s, e.state.facet(Wt).maxRenderedOptions), this.showOptions(o, r.id)), this.updateSel(), a != ((n = i.open) === null || n === void 0 ? void 0 : n.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a);
    }
  }
  updateTooltipClass(e) {
    let n = this.tooltipClass(e);
    if (n != this.currentClass) {
      for (let r of this.currentClass.split(" "))
        r && this.dom.classList.remove(r);
      for (let r of n.split(" "))
        r && this.dom.classList.add(r);
      this.currentClass = n;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), n = e.open;
    if ((n.selected > -1 && n.selected < this.range.from || n.selected >= this.range.to) && (this.range = T0(n.options.length, n.selected, this.view.state.facet(Wt).maxRenderedOptions), this.showOptions(n.options, e.id)), this.updateSelectedOption(n.selected)) {
      this.destroyInfo();
      let { completion: r } = n.options[n.selected], { info: i } = r;
      if (!i)
        return;
      let o = typeof i == "string" ? document.createTextNode(i) : i(r);
      if (!o)
        return;
      "then" in o ? o.then((s) => {
        s && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(s, r);
      }).catch((s) => Cn(this.view.state, s, "completion info")) : this.addInfoPane(o, r);
    }
  }
  addInfoPane(e, n) {
    this.destroyInfo();
    let r = this.info = document.createElement("div");
    if (r.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      r.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: i, destroy: o } = e;
      r.appendChild(i), this.infoDestroy = o || null;
    }
    this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let n = null;
    for (let r = this.list.firstChild, i = this.range.from; r; r = r.nextSibling, i++)
      r.nodeName != "LI" || !r.id ? i-- : i == e ? r.hasAttribute("aria-selected") || (r.setAttribute("aria-selected", "true"), n = r) : r.hasAttribute("aria-selected") && r.removeAttribute("aria-selected");
    return n && SG(this.list, n), n;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let n = this.dom.getBoundingClientRect(), r = this.info.getBoundingClientRect(), i = e.getBoundingClientRect(), o = this.space;
    if (!o) {
      let s = this.dom.ownerDocument.documentElement;
      o = { left: 0, top: 0, right: s.clientWidth, bottom: s.clientHeight };
    }
    return i.top > Math.min(o.bottom, n.bottom) - 10 || i.bottom < Math.max(o.top, n.top) + 10 ? null : this.view.state.facet(Wt).positionInfo(this.view, n, i, r, o, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, n, r) {
    const i = document.createElement("ul");
    i.id = n, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions")), i.addEventListener("mousedown", (s) => {
      s.target == i && s.preventDefault();
    });
    let o = null;
    for (let s = r.from; s < r.to; s++) {
      let { completion: a, match: c } = e[s], { section: h } = a;
      if (h) {
        let p = typeof h == "string" ? h : h.name;
        if (p != o && (s > r.from || r.from == 0))
          if (o = p, typeof h != "string" && h.header)
            i.appendChild(h.header(h));
          else {
            let v = i.appendChild(document.createElement("completion-section"));
            v.textContent = p;
          }
      }
      const f = i.appendChild(document.createElement("li"));
      f.id = n + "-" + s, f.setAttribute("role", "option");
      let d = this.optionClass(a);
      d && (f.className = d);
      for (let p of this.optionContent) {
        let v = p(a, this.view.state, this.view, c);
        v && f.appendChild(v);
      }
    }
    return r.from && i.classList.add("cm-completionListIncompleteTop"), r.to < e.length && i.classList.add("cm-completionListIncompleteBottom"), i;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function $G(t, e) {
  return (n) => new CG(n, t, e);
}
function SG(t, e) {
  let n = t.getBoundingClientRect(), r = e.getBoundingClientRect(), i = n.height / t.offsetHeight;
  r.top < n.top ? t.scrollTop -= (n.top - r.top) / i : r.bottom > n.bottom && (t.scrollTop += (r.bottom - n.bottom) / i);
}
function aw(t) {
  return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
}
function AG(t, e) {
  let n = [], r = null, i = (h) => {
    n.push(h);
    let { section: f } = h.completion;
    if (f) {
      r || (r = []);
      let d = typeof f == "string" ? f : f.name;
      r.some((p) => p.name == d) || r.push(typeof f == "string" ? { name: d } : f);
    }
  }, o = e.facet(Wt);
  for (let h of t)
    if (h.hasResult()) {
      let f = h.result.getMatch;
      if (h.result.filter === !1)
        for (let d of h.result.options)
          i(new iw(d, h.source, f ? f(d) : [], 1e9 - n.length));
      else {
        let d = e.sliceDoc(h.from, h.to), p, v = o.filterStrict ? new wG(d) : new bG(d);
        for (let w of h.result.options)
          if (p = v.match(w.label)) {
            let b = w.displayLabel ? f ? f(w, p.matched) : [] : p.matched;
            i(new iw(w, h.source, b, p.score + (w.boost || 0)));
          }
      }
    }
  if (r) {
    let h = /* @__PURE__ */ Object.create(null), f = 0, d = (p, v) => {
      var w, b;
      return ((w = p.rank) !== null && w !== void 0 ? w : 1e9) - ((b = v.rank) !== null && b !== void 0 ? b : 1e9) || (p.name < v.name ? -1 : 1);
    };
    for (let p of r.sort(d))
      f -= 1e5, h[p.name] = f;
    for (let p of n) {
      let { section: v } = p.completion;
      v && (p.score += h[typeof v == "string" ? v : v.name]);
    }
  }
  let s = [], a = null, c = o.compareCompletions;
  for (let h of n.sort((f, d) => d.score - f.score || c(f.completion, d.completion))) {
    let f = h.completion;
    !a || a.label != f.label || a.detail != f.detail || a.type != null && f.type != null && a.type != f.type || a.apply != f.apply || a.boost != f.boost ? s.push(h) : aw(h.completion) > aw(a) && (s[s.length - 1] = h), a = h.completion;
  }
  return s;
}
class ys {
  constructor(e, n, r, i, o, s) {
    this.options = e, this.attrs = n, this.tooltip = r, this.timestamp = i, this.selected = o, this.disabled = s;
  }
  setSelected(e, n) {
    return e == this.selected || e >= this.options.length ? this : new ys(this.options, lw(n, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, n, r, i, o, s) {
    if (i && !s && e.some((h) => h.isPending))
      return i.setDisabled();
    let a = AG(e, n);
    if (!a.length)
      return i && e.some((h) => h.isPending) ? i.setDisabled() : null;
    let c = n.facet(Wt).selectOnOpen ? 0 : -1;
    if (i && i.selected != c && i.selected != -1) {
      let h = i.options[i.selected].completion;
      for (let f = 0; f < a.length; f++)
        if (a[f].completion == h) {
          c = f;
          break;
        }
    }
    return new ys(a, lw(r, c), {
      pos: e.reduce((h, f) => f.hasResult() ? Math.min(h, f.from) : h, 1e8),
      create: OG,
      above: o.aboveCursor
    }, i ? i.timestamp : Date.now(), c, !1);
  }
  map(e) {
    return new ys(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new ys(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}
class gh {
  constructor(e, n, r) {
    this.active = e, this.id = n, this.open = r;
  }
  static start() {
    return new gh(RG, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: n } = e, r = n.facet(Wt), o = (r.override || n.languageDataAt("autocomplete", $o(n)).map(vG)).map((c) => (this.active.find((f) => f.source == c) || new jn(
      c,
      this.active.some(
        (f) => f.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, r));
    o.length == this.active.length && o.every((c, h) => c == this.active[h]) && (o = this.active);
    let s = this.open, a = e.effects.some((c) => c.is(Xp));
    s && e.docChanged && (s = s.map(e.changes)), e.selection || o.some((c) => c.hasResult() && e.changes.touchesRange(c.from, c.to)) || !kG(o, this.active) || a ? s = ys.build(o, n, this.id, s, r, a) : s && s.disabled && !o.some((c) => c.isPending) && (s = null), !s && o.every((c) => !c.isPending) && o.some((c) => c.hasResult()) && (o = o.map((c) => c.hasResult() ? new jn(
      c.source,
      0
      /* State.Inactive */
    ) : c));
    for (let c of e.effects)
      c.is(kC) && (s = s && s.setSelected(c.value, this.id));
    return o == this.active && s == this.open ? this : new gh(o, this.id, s);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? MG : TG;
  }
}
function kG(t, e) {
  if (t == e)
    return !0;
  for (let n = 0, r = 0; ; ) {
    for (; n < t.length && !t[n].hasResult(); )
      n++;
    for (; r < e.length && !e[r].hasResult(); )
      r++;
    let i = n == t.length, o = r == e.length;
    if (i || o)
      return i == o;
    if (t[n++].result != e[r++].result)
      return !1;
  }
}
const MG = {
  "aria-autocomplete": "list"
}, TG = {};
function lw(t, e) {
  let n = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": t
  };
  return e > -1 && (n["aria-activedescendant"] = t + "-" + e), n;
}
const RG = [];
function AC(t, e) {
  if (t.isUserEvent("input.complete")) {
    let r = t.annotation(SC);
    if (r && e.activateOnCompletion(r))
      return 12;
  }
  let n = t.isUserEvent("input.type");
  return n && e.activateOnTyping ? 5 : n ? 1 : t.isUserEvent("delete.backward") ? 2 : t.selection ? 8 : t.docChanged ? 16 : 0;
}
class jn {
  constructor(e, n, r = !1) {
    this.source = e, this.state = n, this.explicit = r;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(e, n) {
    let r = AC(e, n), i = this;
    (r & 8 || r & 16 && this.touches(e)) && (i = new jn(
      i.source,
      0
      /* State.Inactive */
    )), r & 4 && i.state == 0 && (i = new jn(
      this.source,
      1
      /* State.Pending */
    )), i = i.updateFor(e, r);
    for (let o of e.effects)
      if (o.is(dh))
        i = new jn(i.source, 1, o.value);
      else if (o.is(cl))
        i = new jn(
          i.source,
          0
          /* State.Inactive */
        );
      else if (o.is(Xp))
        for (let s of o.value)
          s.source == i.source && (i = s);
    return i;
  }
  updateFor(e, n) {
    return this.map(e.changes);
  }
  map(e) {
    return this;
  }
  touches(e) {
    return e.changes.touchesRange($o(e.state));
  }
}
class Rs extends jn {
  constructor(e, n, r, i, o, s) {
    super(e, 3, n), this.limit = r, this.result = i, this.from = o, this.to = s;
  }
  hasResult() {
    return !0;
  }
  updateFor(e, n) {
    var r;
    if (!(n & 3))
      return this.map(e.changes);
    let i = this.result;
    i.map && !e.changes.empty && (i = i.map(i, e.changes));
    let o = e.changes.mapPos(this.from), s = e.changes.mapPos(this.to, 1), a = $o(e.state);
    if (a > s || !i || n & 2 && ($o(e.startState) == this.from || a < this.limit))
      return new jn(
        this.source,
        n & 4 ? 1 : 0
        /* State.Inactive */
      );
    let c = e.changes.mapPos(this.limit);
    return EG(i.validFor, e.state, o, s) ? new Rs(this.source, this.explicit, c, i, o, s) : i.update && (i = i.update(i, o, s, new CC(e.state, a, !1))) ? new Rs(this.source, this.explicit, c, i, i.from, (r = i.to) !== null && r !== void 0 ? r : $o(e.state)) : new jn(this.source, 1, this.explicit);
  }
  map(e) {
    return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new Rs(this.source, this.explicit, e.mapPos(this.limit), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new jn(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(e) {
    return e.changes.touchesRange(this.from, this.to);
  }
}
function EG(t, e, n, r) {
  if (!t)
    return !1;
  let i = e.sliceDoc(n, r);
  return typeof t == "function" ? t(i, n, r, e) : $C(t, !0).test(i);
}
const Xp = /* @__PURE__ */ Ne.define({
  map(t, e) {
    return t.map((n) => n.map(e));
  }
}), kC = /* @__PURE__ */ Ne.define(), yn = /* @__PURE__ */ Kt.define({
  create() {
    return gh.start();
  },
  update(t, e) {
    return t.update(e);
  },
  provide: (t) => [
    Hp.from(t, (e) => e.tooltip),
    fe.contentAttributes.from(t, (e) => e.attrs)
  ]
});
function Zp(t, e) {
  const n = e.completion.apply || e.completion.label;
  let r = t.state.field(yn).active.find((i) => i.source == e.source);
  return r instanceof Rs ? (typeof n == "string" ? t.dispatch(Object.assign(Object.assign({}, mG(t.state, n, r.from, r.to)), { annotations: SC.of(e.completion) })) : n(t, e.completion, r.from, r.to), !0) : !1;
}
const OG = /* @__PURE__ */ $G(yn, Zp);
function uu(t, e = "option") {
  return (n) => {
    let r = n.state.field(yn, !1);
    if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < n.state.facet(Wt).interactionDelay)
      return !1;
    let i = 1, o;
    e == "page" && (o = g4(n, r.open.tooltip)) && (i = Math.max(2, Math.floor(o.dom.offsetHeight / o.dom.querySelector("li").offsetHeight) - 1));
    let { length: s } = r.open.options, a = r.open.selected > -1 ? r.open.selected + i * (t ? 1 : -1) : t ? 0 : s - 1;
    return a < 0 ? a = e == "page" ? 0 : s - 1 : a >= s && (a = e == "page" ? s - 1 : 0), n.dispatch({ effects: kC.of(a) }), !0;
  };
}
const DG = (t) => {
  let e = t.state.field(yn, !1);
  return t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(Wt).interactionDelay ? !1 : Zp(t, e.open.options[e.open.selected]);
}, cw = (t) => t.state.field(yn, !1) ? (t.dispatch({ effects: dh.of(!0) }), !0) : !1, IG = (t) => {
  let e = t.state.field(yn, !1);
  return !e || !e.active.some(
    (n) => n.state != 0
    /* State.Inactive */
  ) ? !1 : (t.dispatch({ effects: cl.of(null) }), !0);
};
class _G {
  constructor(e, n) {
    this.active = e, this.context = n, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const LG = 50, BG = 1e3, NG = /* @__PURE__ */ Mt.fromClass(class {
  constructor(t) {
    this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of t.state.field(yn).active)
      e.isPending && this.startQuery(e);
  }
  update(t) {
    let e = t.state.field(yn), n = t.state.facet(Wt);
    if (!t.selectionSet && !t.docChanged && t.startState.field(yn) == e)
      return;
    let r = t.transactions.some((o) => {
      let s = AC(o, n);
      return s & 8 || (o.selection || o.docChanged) && !(s & 3);
    });
    for (let o = 0; o < this.running.length; o++) {
      let s = this.running[o];
      if (r || s.context.abortOnDocChange && t.docChanged || s.updates.length + t.transactions.length > LG && Date.now() - s.time > BG) {
        for (let a of s.context.abortListeners)
          try {
            a();
          } catch (c) {
            Cn(this.view.state, c);
          }
        s.context.abortListeners = null, this.running.splice(o--, 1);
      } else
        s.updates.push(...t.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), t.transactions.some((o) => o.effects.some((s) => s.is(dh))) && (this.pendingStart = !0);
    let i = this.pendingStart ? 50 : n.activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((o) => o.isPending && !this.running.some((s) => s.active.source == o.source)) ? setTimeout(() => this.startUpdate(), i) : -1, this.composing != 0)
      for (let o of t.transactions)
        o.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && o.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: t } = this.view, e = t.field(yn);
    for (let n of e.active)
      n.isPending && !this.running.some((r) => r.active.source == n.source) && this.startQuery(n);
    this.running.length && e.open && e.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Wt).updateSyncTime));
  }
  startQuery(t) {
    let { state: e } = this.view, n = $o(e), r = new CC(e, n, t.explicit, this.view), i = new _G(t, r);
    this.running.push(i), Promise.resolve(t.source(r)).then((o) => {
      i.context.aborted || (i.done = o || null, this.scheduleAccept());
    }, (o) => {
      this.view.dispatch({ effects: cl.of(null) }), Cn(this.view.state, o);
    });
  }
  scheduleAccept() {
    this.running.every((t) => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Wt).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var t;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], n = this.view.state.facet(Wt), r = this.view.state.field(yn);
    for (let i = 0; i < this.running.length; i++) {
      let o = this.running[i];
      if (o.done === void 0)
        continue;
      if (this.running.splice(i--, 1), o.done) {
        let a = $o(o.updates.length ? o.updates[0].startState : this.view.state), c = Math.min(a, o.done.from + (o.active.explicit ? 0 : 1)), h = new Rs(o.active.source, o.active.explicit, c, o.done, o.done.from, (t = o.done.to) !== null && t !== void 0 ? t : a);
        for (let f of o.updates)
          h = h.update(f, n);
        if (h.hasResult()) {
          e.push(h);
          continue;
        }
      }
      let s = r.active.find((a) => a.source == o.active.source);
      if (s && s.isPending)
        if (o.done == null) {
          let a = new jn(
            o.active.source,
            0
            /* State.Inactive */
          );
          for (let c of o.updates)
            a = a.update(c, n);
          a.isPending || e.push(a);
        } else
          this.startQuery(s);
    }
    (e.length || r.open && r.open.disabled) && this.view.dispatch({ effects: Xp.of(e) });
  }
}, {
  eventHandlers: {
    blur(t) {
      let e = this.view.state.field(yn, !1);
      if (e && e.tooltip && this.view.state.facet(Wt).closeOnBlur) {
        let n = e.open && g4(this.view, e.open.tooltip);
        (!n || !n.dom.contains(t.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: cl.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: dh.of(!1) }), 20), this.composing = 0;
    }
  }
}), FG = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), VG = /* @__PURE__ */ Wo.highest(/* @__PURE__ */ fe.domEventHandlers({
  keydown(t, e) {
    let n = e.state.field(yn, !1);
    if (!n || !n.open || n.open.disabled || n.open.selected < 0 || t.key.length > 1 || t.ctrlKey && !(FG && t.altKey) || t.metaKey)
      return !1;
    let r = n.open.options[n.open.selected], i = n.active.find((s) => s.source == r.source), o = r.completion.commitCharacters || i.result.commitCharacters;
    return o && o.indexOf(t.key) > -1 && Zp(e, r), !1;
  }
})), HG = /* @__PURE__ */ fe.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
}), ul = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, mo = /* @__PURE__ */ Ne.define({
  map(t, e) {
    let n = e.mapPos(t, -1, hn.TrackAfter);
    return n ?? void 0;
  }
}), Qp = /* @__PURE__ */ new class extends Ro {
}();
Qp.startSide = 1;
Qp.endSide = -1;
const MC = /* @__PURE__ */ Kt.define({
  create() {
    return tt.empty;
  },
  update(t, e) {
    if (t = t.map(e.changes), e.selection) {
      let n = e.state.doc.lineAt(e.selection.main.head);
      t = t.update({ filter: (r) => r >= n.from && r <= n.to });
    }
    for (let n of e.effects)
      n.is(mo) && (t = t.update({ add: [Qp.range(n.value, n.value + 1)] }));
    return t;
  }
});
function PG() {
  return [zG, MC];
}
const R0 = "()[]{}<>«»»«［］｛｝";
function TC(t) {
  for (let e = 0; e < R0.length; e += 2)
    if (R0.charCodeAt(e) == t)
      return R0.charAt(e + 1);
  return Ap(t < 128 ? t : t + 1);
}
function RC(t, e) {
  return t.languageDataAt("closeBrackets", e)[0] || ul;
}
const WG = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), zG = /* @__PURE__ */ fe.inputHandler.of((t, e, n, r) => {
  if ((WG ? t.composing : t.compositionStarted) || t.state.readOnly)
    return !1;
  let i = t.state.selection.main;
  if (r.length > 2 || r.length == 2 && Ar(wn(r, 0)) == 1 || e != i.from || n != i.to)
    return !1;
  let o = qG(t.state, r);
  return o ? (t.dispatch(o), !0) : !1;
}), UG = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = RC(t, t.selection.main.head).brackets || ul.brackets, i = null, o = t.changeByRange((s) => {
    if (s.empty) {
      let a = GG(t.doc, s.head);
      for (let c of r)
        if (c == a && af(t.doc, s.head) == TC(wn(c, 0)))
          return {
            changes: { from: s.head - c.length, to: s.head + c.length },
            range: J.cursor(s.head - c.length)
          };
    }
    return { range: i = s };
  });
  return i || e(t.update(o, { scrollIntoView: !0, userEvent: "delete.backward" })), !i;
}, KG = [
  { key: "Backspace", run: UG }
];
function qG(t, e) {
  let n = RC(t, t.selection.main.head), r = n.brackets || ul.brackets;
  for (let i of r) {
    let o = TC(wn(i, 0));
    if (e == i)
      return o == i ? XG(t, i, r.indexOf(i + i + i) > -1, n) : YG(t, i, o, n.before || ul.before);
    if (e == o && EC(t, t.selection.main.from))
      return jG(t, i, o);
  }
  return null;
}
function EC(t, e) {
  let n = !1;
  return t.field(MC).between(0, t.doc.length, (r) => {
    r == e && (n = !0);
  }), n;
}
function af(t, e) {
  let n = t.sliceString(e, e + 2);
  return n.slice(0, Ar(wn(n, 0)));
}
function GG(t, e) {
  let n = t.sliceString(e - 2, e);
  return Ar(wn(n, 0)) == n.length ? n : n.slice(1);
}
function YG(t, e, n, r) {
  let i = null, o = t.changeByRange((s) => {
    if (!s.empty)
      return {
        changes: [{ insert: e, from: s.from }, { insert: n, from: s.to }],
        effects: mo.of(s.to + e.length),
        range: J.range(s.anchor + e.length, s.head + e.length)
      };
    let a = af(t.doc, s.head);
    return !a || /\s/.test(a) || r.indexOf(a) > -1 ? {
      changes: { insert: e + n, from: s.head },
      effects: mo.of(s.head + e.length),
      range: J.cursor(s.head + e.length)
    } : { range: i = s };
  });
  return i ? null : t.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function jG(t, e, n) {
  let r = null, i = t.changeByRange((o) => o.empty && af(t.doc, o.head) == n ? {
    changes: { from: o.head, to: o.head + n.length, insert: n },
    range: J.cursor(o.head + n.length)
  } : r = { range: o });
  return r ? null : t.update(i, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function XG(t, e, n, r) {
  let i = r.stringPrefixes || ul.stringPrefixes, o = null, s = t.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: e, from: a.to }],
        effects: mo.of(a.to + e.length),
        range: J.range(a.anchor + e.length, a.head + e.length)
      };
    let c = a.head, h = af(t.doc, c), f;
    if (h == e) {
      if (uw(t, c))
        return {
          changes: { insert: e + e, from: c },
          effects: mo.of(c + e.length),
          range: J.cursor(c + e.length)
        };
      if (EC(t, c)) {
        let p = n && t.sliceDoc(c, c + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: c, to: c + p.length, insert: p },
          range: J.cursor(c + p.length)
        };
      }
    } else {
      if (n && t.sliceDoc(c - 2 * e.length, c) == e + e && (f = hw(t, c - 2 * e.length, i)) > -1 && uw(t, f))
        return {
          changes: { insert: e + e + e + e, from: c },
          effects: mo.of(c + e.length),
          range: J.cursor(c + e.length)
        };
      if (t.charCategorizer(c)(h) != bt.Word && hw(t, c, i) > -1 && !ZG(t, c, e, i))
        return {
          changes: { insert: e + e, from: c },
          effects: mo.of(c + e.length),
          range: J.cursor(c + e.length)
        };
    }
    return { range: o = a };
  });
  return o ? null : t.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function uw(t, e) {
  let n = on(t).resolveInner(e + 1);
  return n.parent && n.from == e;
}
function ZG(t, e, n, r) {
  let i = on(t).resolveInner(e, -1), o = r.reduce((s, a) => Math.max(s, a.length), 0);
  for (let s = 0; s < 5; s++) {
    let a = t.sliceDoc(i.from, Math.min(i.to, i.from + n.length + o)), c = a.indexOf(n);
    if (!c || c > -1 && r.indexOf(a.slice(0, c)) > -1) {
      let f = i.firstChild;
      for (; f && f.from == i.from && f.to - f.from > n.length + c; ) {
        if (t.sliceDoc(f.to - n.length, f.to) == n)
          return !1;
        f = f.firstChild;
      }
      return !0;
    }
    let h = i.to == e && i.parent;
    if (!h)
      break;
    i = h;
  }
  return !1;
}
function hw(t, e, n) {
  let r = t.charCategorizer(e);
  if (r(t.sliceDoc(e - 1, e)) != bt.Word)
    return e;
  for (let i of n) {
    let o = e - i.length;
    if (t.sliceDoc(o, e) == i && r(t.sliceDoc(o - 1, o)) != bt.Word)
      return o;
  }
  return -1;
}
function QG(t = {}) {
  return [
    VG,
    yn,
    Wt.of(t),
    NG,
    JG,
    HG
  ];
}
const OC = [
  { key: "Ctrl-Space", run: cw },
  { mac: "Alt-`", run: cw },
  { key: "Escape", run: IG },
  { key: "ArrowDown", run: /* @__PURE__ */ uu(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ uu(!1) },
  { key: "PageDown", run: /* @__PURE__ */ uu(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ uu(!1, "page") },
  { key: "Enter", run: DG }
], JG = /* @__PURE__ */ Wo.highest(/* @__PURE__ */ Zh.computeN([Wt], (t) => t.facet(Wt).defaultKeymap ? [OC] : []));
class fw {
  constructor(e, n, r) {
    this.from = e, this.to = n, this.diagnostic = r;
  }
}
class fo {
  constructor(e, n, r) {
    this.diagnostics = e, this.panel = n, this.selected = r;
  }
  static init(e, n, r) {
    let i = r.facet(hl).markerFilter;
    i && (e = i(e, r));
    let o = e.slice().sort((f, d) => f.from - d.from || f.to - d.to), s = new di(), a = [], c = 0;
    for (let f = 0; ; ) {
      let d = f == o.length ? null : o[f];
      if (!d && !a.length)
        break;
      let p, v;
      for (a.length ? (p = c, v = a.reduce((b, y) => Math.min(b, y.to), d && d.from > p ? d.from : 1e8)) : (p = d.from, v = d.to, a.push(d), f++); f < o.length; ) {
        let b = o[f];
        if (b.from == p && (b.to > b.from || b.to == p))
          a.push(b), f++, v = Math.min(b.to, v);
        else {
          v = Math.min(b.from, v);
          break;
        }
      }
      let w = fY(a);
      if (a.some((b) => b.from == b.to || b.from == b.to - 1 && r.doc.lineAt(b.from).to == b.from))
        s.add(p, p, Se.widget({
          widget: new lY(w),
          diagnostics: a.slice()
        }));
      else {
        let b = a.reduce((y, $) => $.markClass ? y + " " + $.markClass : y, "");
        s.add(p, v, Se.mark({
          class: "cm-lintRange cm-lintRange-" + w + b,
          diagnostics: a.slice(),
          inclusiveEnd: a.some((y) => y.to > v)
        }));
      }
      c = v;
      for (let b = 0; b < a.length; b++)
        a[b].to <= c && a.splice(b--, 1);
    }
    let h = s.finish();
    return new fo(h, n, Us(h));
  }
}
function Us(t, e = null, n = 0) {
  let r = null;
  return t.between(n, 1e9, (i, o, { spec: s }) => {
    if (!(e && s.diagnostics.indexOf(e) < 0))
      if (!r)
        r = new fw(i, o, e || s.diagnostics[0]);
      else {
        if (s.diagnostics.indexOf(r.diagnostic) < 0)
          return !1;
        r = new fw(r.from, o, r.diagnostic);
      }
  }), r;
}
function eY(t, e) {
  let n = e.pos, r = e.end || n, i = t.state.facet(hl).hideOn(t, n, r);
  if (i != null)
    return i;
  let o = t.startState.doc.lineAt(e.pos);
  return !!(t.effects.some((s) => s.is(DC)) || t.changes.touchesRange(o.from, Math.max(o.to, r)));
}
function tY(t, e) {
  return t.field(Nn, !1) ? e : e.concat(Ne.appendConfig.of(dY));
}
const DC = /* @__PURE__ */ Ne.define(), Jp = /* @__PURE__ */ Ne.define(), IC = /* @__PURE__ */ Ne.define(), Nn = /* @__PURE__ */ Kt.define({
  create() {
    return new fo(Se.none, null, null);
  },
  update(t, e) {
    if (e.docChanged && t.diagnostics.size) {
      let n = t.diagnostics.map(e.changes), r = null, i = t.panel;
      if (t.selected) {
        let o = e.changes.mapPos(t.selected.from, 1);
        r = Us(n, t.selected.diagnostic, o) || Us(n, null, o);
      }
      !n.size && i && e.state.facet(hl).autoPanel && (i = null), t = new fo(n, i, r);
    }
    for (let n of e.effects)
      if (n.is(DC)) {
        let r = e.state.facet(hl).autoPanel ? n.value.length ? fl.open : null : t.panel;
        t = fo.init(n.value, r, e.state);
      } else n.is(Jp) ? t = new fo(t.diagnostics, n.value ? fl.open : null, t.selected) : n.is(IC) && (t = new fo(t.diagnostics, t.panel, n.value));
    return t;
  },
  provide: (t) => [
    sl.from(t, (e) => e.panel),
    fe.decorations.from(t, (e) => e.diagnostics)
  ]
}), nY = /* @__PURE__ */ Se.mark({ class: "cm-lintRange cm-lintRange-active" });
function rY(t, e, n) {
  let { diagnostics: r } = t.state.field(Nn), i, o = -1, s = -1;
  r.between(e - (n < 0 ? 1 : 0), e + (n > 0 ? 1 : 0), (c, h, { spec: f }) => {
    if (e >= c && e <= h && (c == h || (e > c || n > 0) && (e < h || n < 0)))
      return i = f.diagnostics, o = c, s = h, !1;
  });
  let a = t.state.facet(hl).tooltipFilter;
  return i && a && (i = a(i, t.state)), i ? {
    pos: o,
    end: s,
    above: t.state.doc.lineAt(o).to < s,
    create() {
      return { dom: iY(t, i) };
    }
  } : null;
}
function iY(t, e) {
  return ut("ul", { class: "cm-tooltip-lint" }, e.map((n) => LC(t, n, !1)));
}
const oY = (t) => {
  let e = t.state.field(Nn, !1);
  (!e || !e.panel) && t.dispatch({ effects: tY(t.state, [Jp.of(!0)]) });
  let n = ol(t, fl.open);
  return n && n.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, dw = (t) => {
  let e = t.state.field(Nn, !1);
  return !e || !e.panel ? !1 : (t.dispatch({ effects: Jp.of(!1) }), !0);
}, sY = (t) => {
  let e = t.state.field(Nn, !1);
  if (!e)
    return !1;
  let n = t.state.selection.main, r = e.diagnostics.iter(n.to + 1);
  return !r.value && (r = e.diagnostics.iter(0), !r.value || r.from == n.from && r.to == n.to) ? !1 : (t.dispatch({ selection: { anchor: r.from, head: r.to }, scrollIntoView: !0 }), !0);
}, aY = [
  { key: "Mod-Shift-m", run: oY, preventDefault: !0 },
  { key: "F8", run: sY }
], hl = /* @__PURE__ */ pe.define({
  combine(t) {
    return Object.assign({ sources: t.map((e) => e.source).filter((e) => e != null) }, Vr(t.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (e, n) => e ? n ? (r) => e(r) || n(r) : e : n
    }));
  }
});
function _C(t) {
  let e = [];
  if (t)
    e: for (let { name: n } of t) {
      for (let r = 0; r < n.length; r++) {
        let i = n[r];
        if (/[a-zA-Z]/.test(i) && !e.some((o) => o.toLowerCase() == i.toLowerCase())) {
          e.push(i);
          continue e;
        }
      }
      e.push("");
    }
  return e;
}
function LC(t, e, n) {
  var r;
  let i = n ? _C(e.actions) : [];
  return ut("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, ut("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(t) : e.message), (r = e.actions) === null || r === void 0 ? void 0 : r.map((o, s) => {
    let a = !1, c = (p) => {
      if (p.preventDefault(), a)
        return;
      a = !0;
      let v = Us(t.state.field(Nn).diagnostics, e);
      v && o.apply(t, v.from, v.to);
    }, { name: h } = o, f = i[s] ? h.indexOf(i[s]) : -1, d = f < 0 ? h : [
      h.slice(0, f),
      ut("u", h.slice(f, f + 1)),
      h.slice(f + 1)
    ];
    return ut("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: c,
      onmousedown: c,
      "aria-label": ` Action: ${h}${f < 0 ? "" : ` (access key "${i[s]})"`}.`
    }, d);
  }), e.source && ut("div", { class: "cm-diagnosticSource" }, e.source));
}
class lY extends xi {
  constructor(e) {
    super(), this.sev = e;
  }
  eq(e) {
    return e.sev == this.sev;
  }
  toDOM() {
    return ut("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
}
class gw {
  constructor(e, n) {
    this.diagnostic = n, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = LC(e, n, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class fl {
  constructor(e) {
    this.view = e, this.items = [];
    let n = (i) => {
      if (i.keyCode == 27)
        dw(this.view), this.view.focus();
      else if (i.keyCode == 38 || i.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (i.keyCode == 40 || i.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (i.keyCode == 36)
        this.moveSelection(0);
      else if (i.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (i.keyCode == 13)
        this.view.focus();
      else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: o } = this.items[this.selectedIndex], s = _C(o.actions);
        for (let a = 0; a < s.length; a++)
          if (s[a].toUpperCase().charCodeAt(0) == i.keyCode) {
            let c = Us(this.view.state.field(Nn).diagnostics, o);
            c && o.actions[a].apply(e, c.from, c.to);
          }
      } else
        return;
      i.preventDefault();
    }, r = (i) => {
      for (let o = 0; o < this.items.length; o++)
        this.items[o].dom.contains(i.target) && this.moveSelection(o);
    };
    this.list = ut("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: n,
      onclick: r
    }), this.dom = ut("div", { class: "cm-panel-lint" }, this.list, ut("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => dw(this.view)
    }, "×")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(Nn).selected;
    if (!e)
      return -1;
    for (let n = 0; n < this.items.length; n++)
      if (this.items[n].diagnostic == e.diagnostic)
        return n;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: n } = this.view.state.field(Nn), r = 0, i = !1, o = null, s = /* @__PURE__ */ new Set();
    for (e.between(0, this.view.state.doc.length, (a, c, { spec: h }) => {
      for (let f of h.diagnostics) {
        if (s.has(f))
          continue;
        s.add(f);
        let d = -1, p;
        for (let v = r; v < this.items.length; v++)
          if (this.items[v].diagnostic == f) {
            d = v;
            break;
          }
        d < 0 ? (p = new gw(this.view, f), this.items.splice(r, 0, p), i = !0) : (p = this.items[d], d > r && (this.items.splice(r, d - r), i = !0)), n && p.diagnostic == n.diagnostic ? p.dom.hasAttribute("aria-selected") || (p.dom.setAttribute("aria-selected", "true"), o = p) : p.dom.hasAttribute("aria-selected") && p.dom.removeAttribute("aria-selected"), r++;
      }
    }); r < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      i = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new gw(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), i = !0), o ? (this.list.setAttribute("aria-activedescendant", o.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: o.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: a, panel: c }) => {
        let h = c.height / this.list.offsetHeight;
        a.top < c.top ? this.list.scrollTop -= (c.top - a.top) / h : a.bottom > c.bottom && (this.list.scrollTop += (a.bottom - c.bottom) / h);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), i && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function n() {
      let r = e;
      e = r.nextSibling, r.remove();
    }
    for (let r of this.items)
      if (r.dom.parentNode == this.list) {
        for (; e != r.dom; )
          n();
        e = r.dom.nextSibling;
      } else
        this.list.insertBefore(r.dom, e);
    for (; e; )
      n();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let n = this.view.state.field(Nn), r = Us(n.diagnostics, this.items[e].diagnostic);
    r && this.view.dispatch({
      selection: { anchor: r.from, head: r.to },
      scrollIntoView: !0,
      effects: IC.of(r)
    });
  }
  static open(e) {
    return new fl(e);
  }
}
function cY(t, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')`;
}
function hu(t) {
  return cY(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const uY = /* @__PURE__ */ fe.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ hu("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ hu("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ hu("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ hu("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function hY(t) {
  return t == "error" ? 4 : t == "warning" ? 3 : t == "info" ? 2 : 1;
}
function fY(t) {
  let e = "hint", n = 1;
  for (let r of t) {
    let i = hY(r.severity);
    i > n && (n = i, e = r.severity);
  }
  return e;
}
const dY = [
  Nn,
  /* @__PURE__ */ fe.decorations.compute([Nn], (t) => {
    let { selected: e, panel: n } = t.field(Nn);
    return !e || !n || e.from == e.to ? Se.none : Se.set([
      nY.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ vU(rY, { hideOn: eY }),
  uY
];
var pw = function(e) {
  e === void 0 && (e = {});
  var {
    crosshairCursor: n = !1
  } = e, r = [];
  e.closeBracketsKeymap !== !1 && (r = r.concat(KG)), e.defaultKeymap !== !1 && (r = r.concat(Fq)), e.searchKeymap !== !1 && (r = r.concat(uG)), e.historyKeymap !== !1 && (r = r.concat(GK)), e.foldKeymap !== !1 && (r = r.concat(nK)), e.completionKeymap !== !1 && (r = r.concat(OC)), e.lintKeymap !== !1 && (r = r.concat(aY));
  var i = [];
  return e.lineNumbers !== !1 && i.push(TU()), e.highlightActiveLineGutter !== !1 && i.push(OU()), e.highlightSpecialChars !== !1 && i.push(qz()), e.history !== !1 && i.push(FK()), e.foldGutter !== !1 && i.push(sK()), e.drawSelection !== !1 && i.push(Lz()), e.dropCursor !== !1 && i.push(Hz()), e.allowMultipleSelections !== !1 && i.push(et.allowMultipleSelections.of(!0)), e.indentOnInput !== !1 && i.push(qU()), e.syntaxHighlighting !== !1 && i.push(E4(uK, {
    fallback: !0
  })), e.bracketMatching !== !1 && i.push(vK()), e.closeBrackets !== !1 && i.push(PG()), e.autocompletion !== !1 && i.push(QG()), e.rectangularSelection !== !1 && i.push(sU()), n !== !1 && i.push(cU()), e.highlightActiveLine !== !1 && i.push(Qz()), e.highlightSelectionMatches !== !1 && i.push(Kq()), e.tabSize && typeof e.tabSize == "number" && i.push(Jh.of(" ".repeat(e.tabSize))), i.concat([Zh.of(r.flat())]).filter(Boolean);
};
const gY = "#e5c07b", mw = "#e06c75", pY = "#56b6c2", mY = "#ffffff", Ru = "#abb2bf", og = "#7d8799", vY = "#61afef", bY = "#98c379", vw = "#d19a66", wY = "#c678dd", xY = "#21252b", bw = "#2c313a", ww = "#282c34", E0 = "#353a42", yY = "#3E4451", xw = "#528bff", CY = /* @__PURE__ */ fe.theme({
  "&": {
    color: Ru,
    backgroundColor: ww
  },
  ".cm-content": {
    caretColor: xw
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: xw },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: yY },
  ".cm-panels": { backgroundColor: xY, color: Ru },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: ww,
    color: og,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: bw
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: E0
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: E0,
    borderBottomColor: E0
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: bw,
      color: Ru
    }
  }
}, { dark: !0 }), $Y = /* @__PURE__ */ Ol.define([
  {
    tag: q.keyword,
    color: wY
  },
  {
    tag: [q.name, q.deleted, q.character, q.propertyName, q.macroName],
    color: mw
  },
  {
    tag: [/* @__PURE__ */ q.function(q.variableName), q.labelName],
    color: vY
  },
  {
    tag: [q.color, /* @__PURE__ */ q.constant(q.name), /* @__PURE__ */ q.standard(q.name)],
    color: vw
  },
  {
    tag: [/* @__PURE__ */ q.definition(q.name), q.separator],
    color: Ru
  },
  {
    tag: [q.typeName, q.className, q.number, q.changed, q.annotation, q.modifier, q.self, q.namespace],
    color: gY
  },
  {
    tag: [q.operator, q.operatorKeyword, q.url, q.escape, q.regexp, q.link, /* @__PURE__ */ q.special(q.string)],
    color: pY
  },
  {
    tag: [q.meta, q.comment],
    color: og
  },
  {
    tag: q.strong,
    fontWeight: "bold"
  },
  {
    tag: q.emphasis,
    fontStyle: "italic"
  },
  {
    tag: q.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: q.link,
    color: og,
    textDecoration: "underline"
  },
  {
    tag: q.heading,
    fontWeight: "bold",
    color: mw
  },
  {
    tag: [q.atom, q.bool, /* @__PURE__ */ q.special(q.variableName)],
    color: vw
  },
  {
    tag: [q.processingInstruction, q.string, q.inserted],
    color: bY
  },
  {
    tag: q.invalid,
    color: mY
  }
]), SY = [CY, /* @__PURE__ */ E4($Y)];
var AY = fe.theme({
  "&": {
    backgroundColor: "#fff"
  }
}, {
  dark: !1
}), kY = function(e) {
  e === void 0 && (e = {});
  var {
    indentWithTab: n = !0,
    editable: r = !0,
    readOnly: i = !1,
    theme: o = "light",
    placeholder: s = "",
    basicSetup: a = !0
  } = e, c = [];
  switch (n && c.unshift(Zh.of([Vq])), a && (typeof a == "boolean" ? c.unshift(pw()) : c.unshift(pw(a))), s && c.unshift(nU(s)), o) {
    case "light":
      c.push(AY);
      break;
    case "dark":
      c.push(SY);
      break;
    case "none":
      break;
    default:
      c.push(o);
      break;
  }
  return r === !1 && c.push(fe.editable.of(!1)), i && c.push(et.readOnly.of(!0)), [...c];
}, MY = (t) => ({
  line: t.state.doc.lineAt(t.state.selection.main.from),
  lineCount: t.state.doc.lines,
  lineBreak: t.state.lineBreak,
  length: t.state.doc.length,
  readOnly: t.state.readOnly,
  tabSize: t.state.tabSize,
  selection: t.state.selection,
  selectionAsSingle: t.state.selection.asSingle().main,
  ranges: t.state.selection.ranges,
  selectionCode: t.state.sliceDoc(t.state.selection.main.from, t.state.selection.main.to),
  selections: t.state.selection.ranges.map((e) => t.state.sliceDoc(e.from, e.to)),
  selectedText: t.state.selection.ranges.some((e) => !e.empty)
}), yw = Fr.define(), TY = [];
function BC(t) {
  var {
    value: e,
    selection: n,
    onChange: r,
    onStatistics: i,
    onCreateEditor: o,
    onUpdate: s,
    extensions: a = TY,
    autoFocus: c,
    theme: h = "light",
    height: f = null,
    minHeight: d = null,
    maxHeight: p = null,
    width: v = null,
    minWidth: w = null,
    maxWidth: b = null,
    placeholder: y = "",
    editable: $ = !0,
    readOnly: A = !1,
    indentWithTab: k = !0,
    basicSetup: T = !0,
    root: R,
    initialState: _
  } = t, [D, P] = De(), [H, z] = De(), [j, K] = De(), te = fe.theme({
    "&": {
      height: f,
      minHeight: d,
      maxHeight: p,
      width: v,
      minWidth: w,
      maxWidth: b
    },
    "& .cm-scroller": {
      height: "100% !important"
    }
  }), ee = fe.updateListener.of((ie) => {
    if (ie.docChanged && typeof r == "function" && // Fix echoing of the remote changes:
    // If transaction is market as remote we don't have to call `onChange` handler again
    !ie.transactions.some((ce) => ce.annotation(yw))) {
      var se = ie.state.doc, X = se.toString();
      r(X, ie);
    }
    i && i(MY(ie));
  }), re = kY({
    theme: h,
    editable: $,
    readOnly: A,
    placeholder: y,
    indentWithTab: k,
    basicSetup: T
  }), de = [ee, te, ...re];
  return s && typeof s == "function" && de.push(fe.updateListener.of(s)), de = de.concat(a), Ce(() => {
    if (D && !j) {
      var ie = {
        doc: e,
        selection: n,
        extensions: de
      }, se = _ ? et.fromJSON(_.json, ie, _.fields) : et.create(ie);
      if (K(se), !H) {
        var X = new fe({
          state: se,
          parent: D,
          root: R
        });
        z(X), o && o(X, se);
      }
    }
    return () => {
      H && (K(void 0), z(void 0));
    };
  }, [D, j]), Ce(() => P(t.container), [t.container]), Ce(() => () => {
    H && (H.destroy(), z(void 0));
  }, [H]), Ce(() => {
    c && H && H.focus();
  }, [c, H]), Ce(() => {
    H && H.dispatch({
      effects: Ne.reconfigure.of(de)
    });
  }, [h, a, f, d, p, v, w, b, y, $, A, k, T, r, s]), Ce(() => {
    if (e !== void 0) {
      var ie = H ? H.state.doc.toString() : "";
      H && e !== ie && H.dispatch({
        changes: {
          from: 0,
          to: ie.length,
          insert: e || ""
        },
        annotations: [yw.of(!0)]
      });
    }
  }, [e, H]), {
    state: j,
    setState: K,
    view: H,
    setView: z,
    container: D,
    setContainer: P
  };
}
var RY = ["className", "value", "selection", "extensions", "onChange", "onStatistics", "onCreateEditor", "onUpdate", "autoFocus", "theme", "height", "minHeight", "maxHeight", "width", "minWidth", "maxWidth", "basicSetup", "placeholder", "indentWithTab", "editable", "readOnly", "root", "initialState"], EY = /* @__PURE__ */ O((t, e) => {
  var {
    className: n,
    value: r = "",
    selection: i,
    extensions: o = [],
    onChange: s,
    onStatistics: a,
    onCreateEditor: c,
    onUpdate: h,
    autoFocus: f,
    theme: d = "light",
    height: p,
    minHeight: v,
    maxHeight: w,
    width: b,
    minWidth: y,
    maxWidth: $,
    basicSetup: A,
    placeholder: k,
    indentWithTab: T,
    editable: R,
    readOnly: _,
    root: D,
    initialState: P
  } = t, H = TK(t, RY), z = ue(null), {
    state: j,
    view: K,
    container: te
  } = BC({
    container: z.current,
    root: D,
    value: r,
    autoFocus: f,
    theme: d,
    height: p,
    minHeight: v,
    maxHeight: w,
    width: b,
    minWidth: y,
    maxWidth: $,
    basicSetup: A,
    placeholder: k,
    indentWithTab: T,
    editable: R,
    readOnly: _,
    selection: i,
    onChange: s,
    onStatistics: a,
    onCreateEditor: c,
    onUpdate: h,
    extensions: o,
    initialState: P
  });
  if (VT(e, () => ({
    editor: z.current,
    state: j,
    view: K
  }), [z, te, j, K]), typeof r != "string")
    throw new Error("value must be typeof string but got " + typeof r);
  var ee = typeof d == "string" ? "cm-theme-" + d : "cm-theme";
  return /* @__PURE__ */ m("div", G({
    ref: z,
    className: "" + ee + (n ? " " + n : "")
  }, H));
});
EY.displayName = "CodeMirror";
let O0 = /* @__PURE__ */ new Map(), sg = !1;
try {
  sg = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch {
}
let ph = !1;
try {
  ph = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch {
}
const NC = {
  degree: {
    narrow: {
      default: "°",
      "ja-JP": " 度",
      "zh-TW": "度",
      "sl-SI": " °"
    }
  }
};
class FC {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(e) {
    let n = "";
    if (!sg && this.options.signDisplay != null ? n = DY(this.numberFormatter, this.options.signDisplay, e) : n = this.numberFormatter.format(e), this.options.style === "unit" && !ph) {
      var r;
      let { unit: i, unitDisplay: o = "short", locale: s } = this.resolvedOptions();
      if (!i) return n;
      let a = (r = NC[i]) === null || r === void 0 ? void 0 : r[o];
      n += a[s] || a.default;
    }
    return n;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(e) {
    return this.numberFormatter.formatToParts(e);
  }
  /** Formats a number range as a string. */
  formatRange(e, n) {
    if (typeof this.numberFormatter.formatRange == "function")
      return this.numberFormatter.formatRange(e, n);
    if (n < e) throw new RangeError("End date must be >= start date");
    return `${this.format(e)} – ${this.format(n)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(e, n) {
    if (typeof this.numberFormatter.formatRangeToParts == "function")
      return this.numberFormatter.formatRangeToParts(e, n);
    if (n < e) throw new RangeError("End date must be >= start date");
    let r = this.numberFormatter.formatToParts(e), i = this.numberFormatter.formatToParts(n);
    return [
      ...r.map((o) => ({
        ...o,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...i.map((o) => ({
        ...o,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let e = this.numberFormatter.resolvedOptions();
    return !sg && this.options.signDisplay != null && (e = {
      ...e,
      signDisplay: this.options.signDisplay
    }), !ph && this.options.style === "unit" && (e = {
      ...e,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    }), e;
  }
  constructor(e, n = {}) {
    this.numberFormatter = OY(e, n), this.options = n;
  }
}
function OY(t, e = {}) {
  let { numberingSystem: n } = e;
  if (n && t.includes("-nu-") && (t.includes("-u-") || (t += "-u-"), t += `-nu-${n}`), e.style === "unit" && !ph) {
    var r;
    let { unit: s, unitDisplay: a = "short" } = e;
    if (!s) throw new Error('unit option must be provided with style: "unit"');
    if (!(!((r = NC[s]) === null || r === void 0) && r[a])) throw new Error(`Unsupported unit ${s} with unitDisplay = ${a}`);
    e = {
      ...e,
      style: "decimal"
    };
  }
  let i = t + (e ? Object.entries(e).sort((s, a) => s[0] < a[0] ? -1 : 1).join() : "");
  if (O0.has(i)) return O0.get(i);
  let o = new Intl.NumberFormat(t, e);
  return O0.set(i, o), o;
}
function DY(t, e, n) {
  if (e === "auto") return t.format(n);
  if (e === "never") return t.format(Math.abs(n));
  {
    let r = !1;
    if (e === "always" ? r = n > 0 || Object.is(n, 0) : e === "exceptZero" && (Object.is(n, -0) || Object.is(n, 0) ? n = Math.abs(n) : r = n > 0), r) {
      let i = t.format(-n), o = t.format(n), s = i.replace(o, "").replace(/\u200e|\u061C/, "");
      return [
        ...s
      ].length !== 1 && console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case"), i.replace(o, "!!!").replace(s, "+").replace("!!!", o);
    } else return t.format(n);
  }
}
const IY = new RegExp("^.*\\(.*\\).*$"), _Y = [
  "latn",
  "arab",
  "hanidec"
];
class VC {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(e) {
    return D0(this.locale, this.options, e).parse(e);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(e, n, r) {
    return D0(this.locale, this.options, e).isValidPartialNumber(e, n, r);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(e) {
    return D0(this.locale, this.options, e).options.numberingSystem;
  }
  constructor(e, n = {}) {
    this.locale = e, this.options = n;
  }
}
const Cw = /* @__PURE__ */ new Map();
function D0(t, e, n) {
  let r = $w(t, e);
  if (!t.includes("-nu-") && !r.isValidPartialNumber(n)) {
    for (let i of _Y) if (i !== r.options.numberingSystem) {
      let o = $w(t + (t.includes("-u-") ? "-nu-" : "-u-nu-") + i, e);
      if (o.isValidPartialNumber(n)) return o;
    }
  }
  return r;
}
function $w(t, e) {
  let n = t + (e ? Object.entries(e).sort((i, o) => i[0] < o[0] ? -1 : 1).join() : ""), r = Cw.get(n);
  return r || (r = new LY(t, e), Cw.set(n, r)), r;
}
class LY {
  parse(e) {
    let n = this.sanitize(e);
    if (this.symbols.group && (n = fu(n, this.symbols.group, "")), this.symbols.decimal && (n = n.replace(this.symbols.decimal, ".")), this.symbols.minusSign && (n = n.replace(this.symbols.minusSign, "-")), n = n.replace(this.symbols.numeral, this.symbols.index), this.options.style === "percent") {
      let s = n.indexOf("-");
      n = n.replace("-", "");
      let a = n.indexOf(".");
      a === -1 && (a = n.length), n = n.replace(".", ""), a - 2 === 0 ? n = `0.${n}` : a - 2 === -1 ? n = `0.0${n}` : a - 2 === -2 ? n = "0.00" : n = `${n.slice(0, a - 2)}.${n.slice(a - 2)}`, s > -1 && (n = `-${n}`);
    }
    let r = n ? +n : NaN;
    if (isNaN(r)) return NaN;
    if (this.options.style === "percent") {
      var i, o;
      let s = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((i = this.options.minimumFractionDigits) !== null && i !== void 0 ? i : 0) + 2, 20),
        maximumFractionDigits: Math.min(((o = this.options.maximumFractionDigits) !== null && o !== void 0 ? o : 0) + 2, 20)
      };
      return new VC(this.locale, s).parse(new FC(this.locale, s).format(r));
    }
    return this.options.currencySign === "accounting" && IY.test(e) && (r = -1 * r), r;
  }
  sanitize(e) {
    return e = e.replace(this.symbols.literals, ""), this.symbols.minusSign && (e = e.replace("-", this.symbols.minusSign)), this.options.numberingSystem === "arab" && (this.symbols.decimal && (e = e.replace(",", this.symbols.decimal), e = e.replace("،", this.symbols.decimal)), this.symbols.group && (e = fu(e, ".", this.symbols.group))), this.options.locale === "fr-FR" && (e = fu(e, ".", " ")), e;
  }
  isValidPartialNumber(e, n = -1 / 0, r = 1 / 0) {
    return e = this.sanitize(e), this.symbols.minusSign && e.startsWith(this.symbols.minusSign) && n < 0 ? e = e.slice(this.symbols.minusSign.length) : this.symbols.plusSign && e.startsWith(this.symbols.plusSign) && r > 0 && (e = e.slice(this.symbols.plusSign.length)), this.symbols.group && e.startsWith(this.symbols.group) || this.symbols.decimal && e.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0 ? !1 : (this.symbols.group && (e = fu(e, this.symbols.group, "")), e = e.replace(this.symbols.numeral, ""), this.symbols.decimal && (e = e.replace(this.symbols.decimal, "")), e.length === 0);
  }
  constructor(e, n = {}) {
    this.locale = e, this.formatter = new Intl.NumberFormat(e, n), this.options = this.formatter.resolvedOptions(), this.symbols = NY(e, this.formatter, this.options, n);
    var r, i;
    this.options.style === "percent" && (((r = this.options.minimumFractionDigits) !== null && r !== void 0 ? r : 0) > 18 || ((i = this.options.maximumFractionDigits) !== null && i !== void 0 ? i : 0) > 18) && console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
}
const Sw = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]), BY = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function NY(t, e, n, r) {
  var i, o, s, a;
  let c = new Intl.NumberFormat(t, {
    ...n,
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21
  }), h = c.formatToParts(-10000.111), f = c.formatToParts(10000.111), d = BY.map((z) => c.formatToParts(z));
  var p;
  let v = (p = (i = h.find((z) => z.type === "minusSign")) === null || i === void 0 ? void 0 : i.value) !== null && p !== void 0 ? p : "-", w = (o = f.find((z) => z.type === "plusSign")) === null || o === void 0 ? void 0 : o.value;
  !w && (r?.signDisplay === "exceptZero" || r?.signDisplay === "always") && (w = "+");
  let y = (s = new Intl.NumberFormat(t, {
    ...n,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3).find((z) => z.type === "decimal")) === null || s === void 0 ? void 0 : s.value, $ = (a = h.find((z) => z.type === "group")) === null || a === void 0 ? void 0 : a.value, A = h.filter((z) => !Sw.has(z.type)).map((z) => Aw(z.value)), k = d.flatMap((z) => z.filter((j) => !Sw.has(j.type)).map((j) => Aw(j.value))), T = [
    .../* @__PURE__ */ new Set([
      ...A,
      ...k
    ])
  ].sort((z, j) => j.length - z.length), R = T.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${T.join("|")}|[\\p{White_Space}]`, "gu"), _ = [
    ...new Intl.NumberFormat(n.locale, {
      useGrouping: !1
    }).format(9876543210)
  ].reverse(), D = new Map(_.map((z, j) => [
    z,
    j
  ])), P = new RegExp(`[${_.join("")}]`, "g");
  return {
    minusSign: v,
    plusSign: w,
    decimal: y,
    group: $,
    literals: R,
    numeral: P,
    index: (z) => String(D.get(z))
  };
}
function fu(t, e, n) {
  return t.replaceAll ? t.replaceAll(e, n) : t.split(e).join(n);
}
function Aw(t) {
  return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
var HC = Oh(), I0 = function() {
}, lf = C.forwardRef(function(t, e) {
  var n = C.useRef(null), r = C.useState({
    onScrollCapture: I0,
    onWheelCapture: I0,
    onTouchMoveCapture: I0
  }), i = r[0], o = r[1], s = t.forwardProps, a = t.children, c = t.className, h = t.removeScrollBar, f = t.enabled, d = t.shards, p = t.sideCar, v = t.noIsolation, w = t.inert, b = t.allowPinchZoom, y = t.as, $ = y === void 0 ? "div" : y, A = xl(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]), k = p, T = Eh([n, e]), R = lt(lt({}, A), i);
  return C.createElement(
    C.Fragment,
    null,
    f && C.createElement(k, { sideCar: HC, removeScrollBar: h, shards: d, noIsolation: v, inert: w, setCallbacks: o, allowPinchZoom: !!b, lockRef: n }),
    s ? C.cloneElement(C.Children.only(a), lt(lt({}, R), { ref: T })) : C.createElement($, lt({}, R, { className: c, ref: T }), a)
  );
});
lf.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
lf.classNames = {
  fullWidth: wo,
  zeroRight: bo
};
var ag = !1;
if (typeof window < "u")
  try {
    var du = Object.defineProperty({}, "passive", {
      get: function() {
        return ag = !0, !0;
      }
    });
    window.addEventListener("test", du, du), window.removeEventListener("test", du, du);
  } catch {
    ag = !1;
  }
var ps = ag ? { passive: !1 } : !1, FY = function(t) {
  return t.tagName === "TEXTAREA";
}, PC = function(t, e) {
  var n = window.getComputedStyle(t);
  return (
    // not-not-scrollable
    n[e] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !FY(t) && n[e] === "visible")
  );
}, VY = function(t) {
  return PC(t, "overflowY");
}, HY = function(t) {
  return PC(t, "overflowX");
}, kw = function(t, e) {
  var n = e;
  do {
    typeof ShadowRoot < "u" && n instanceof ShadowRoot && (n = n.host);
    var r = WC(t, n);
    if (r) {
      var i = zC(t, n), o = i[1], s = i[2];
      if (o > s)
        return !0;
    }
    n = n.parentNode;
  } while (n && n !== document.body);
  return !1;
}, PY = function(t) {
  var e = t.scrollTop, n = t.scrollHeight, r = t.clientHeight;
  return [
    e,
    n,
    r
  ];
}, WY = function(t) {
  var e = t.scrollLeft, n = t.scrollWidth, r = t.clientWidth;
  return [
    e,
    n,
    r
  ];
}, WC = function(t, e) {
  return t === "v" ? VY(e) : HY(e);
}, zC = function(t, e) {
  return t === "v" ? PY(e) : WY(e);
}, zY = function(t, e) {
  return t === "h" && e === "rtl" ? -1 : 1;
}, UY = function(t, e, n, r, i) {
  var o = zY(t, window.getComputedStyle(e).direction), s = o * r, a = n.target, c = e.contains(a), h = !1, f = s > 0, d = 0, p = 0;
  do {
    var v = zC(t, a), w = v[0], b = v[1], y = v[2], $ = b - y - o * w;
    (w || $) && WC(t, a) && (d += $, p += w), a = a.parentNode;
  } while (
    // portaled content
    !c && a !== document.body || // self content
    c && (e.contains(a) || e === a)
  );
  return (f && d === 0 || !f && p === 0) && (h = !0), h;
}, gu = function(t) {
  return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0];
}, Mw = function(t) {
  return [t.deltaX, t.deltaY];
}, Tw = function(t) {
  return t && "current" in t ? t.current : t;
}, KY = function(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}, qY = function(t) {
  return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`);
}, GY = 0, ms = [];
function YY(t) {
  var e = C.useRef([]), n = C.useRef([0, 0]), r = C.useRef(), i = C.useState(GY++)[0], o = C.useState(function() {
    return yl();
  })[0], s = C.useRef(t);
  C.useEffect(function() {
    s.current = t;
  }, [t]), C.useEffect(function() {
    if (t.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var b = Rh([t.lockRef.current], (t.shards || []).map(Tw), !0).filter(Boolean);
      return b.forEach(function(y) {
        return y.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), b.forEach(function(y) {
          return y.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [t.inert, t.lockRef.current, t.shards]);
  var a = C.useCallback(function(b, y) {
    if ("touches" in b && b.touches.length === 2)
      return !s.current.allowPinchZoom;
    var $ = gu(b), A = n.current, k = "deltaX" in b ? b.deltaX : A[0] - $[0], T = "deltaY" in b ? b.deltaY : A[1] - $[1], R, _ = b.target, D = Math.abs(k) > Math.abs(T) ? "h" : "v";
    if ("touches" in b && D === "h" && _.type === "range")
      return !1;
    var P = kw(D, _);
    if (!P)
      return !0;
    if (P ? R = D : (R = D === "v" ? "h" : "v", P = kw(D, _)), !P)
      return !1;
    if (!r.current && "changedTouches" in b && (k || T) && (r.current = R), !R)
      return !0;
    var H = r.current || R;
    return UY(H, y, b, H === "h" ? k : T);
  }, []), c = C.useCallback(function(b) {
    var y = b;
    if (!(!ms.length || ms[ms.length - 1] !== o)) {
      var $ = "deltaY" in y ? Mw(y) : gu(y), A = e.current.filter(function(R) {
        return R.name === y.type && R.target === y.target && KY(R.delta, $);
      })[0];
      if (A && A.should) {
        y.cancelable && y.preventDefault();
        return;
      }
      if (!A) {
        var k = (s.current.shards || []).map(Tw).filter(Boolean).filter(function(R) {
          return R.contains(y.target);
        }), T = k.length > 0 ? a(y, k[0]) : !s.current.noIsolation;
        T && y.cancelable && y.preventDefault();
      }
    }
  }, []), h = C.useCallback(function(b, y, $, A) {
    var k = { name: b, delta: y, target: $, should: A };
    e.current.push(k), setTimeout(function() {
      e.current = e.current.filter(function(T) {
        return T !== k;
      });
    }, 1);
  }, []), f = C.useCallback(function(b) {
    n.current = gu(b), r.current = void 0;
  }, []), d = C.useCallback(function(b) {
    h(b.type, Mw(b), b.target, a(b, t.lockRef.current));
  }, []), p = C.useCallback(function(b) {
    h(b.type, gu(b), b.target, a(b, t.lockRef.current));
  }, []);
  C.useEffect(function() {
    return ms.push(o), t.setCallbacks({
      onScrollCapture: d,
      onWheelCapture: d,
      onTouchMoveCapture: p
    }), document.addEventListener("wheel", c, ps), document.addEventListener("touchmove", c, ps), document.addEventListener("touchstart", f, ps), function() {
      ms = ms.filter(function(b) {
        return b !== o;
      }), document.removeEventListener("wheel", c, ps), document.removeEventListener("touchmove", c, ps), document.removeEventListener("touchstart", f, ps);
    };
  }, []);
  var v = t.removeScrollBar, w = t.inert;
  return C.createElement(
    C.Fragment,
    null,
    w ? C.createElement(o, { styles: qY(i) }) : null,
    v ? C.createElement(_h, { gapMode: "margin" }) : null
  );
}
const jY = Dh(HC, YY);
var UC = C.forwardRef(function(t, e) {
  return C.createElement(lf, lt({}, t, { ref: e, sideCar: jY }));
});
UC.classNames = lf.classNames;
const KC = "Popover", [qC, Vte] = Tt(KC, [
  Yi
]), em = Yi(), [XY, oa] = qC(KC), ZY = (t) => {
  const { __scopePopover: e, children: n, open: r, defaultOpen: i, onOpenChange: o, modal: s = !1 } = t, a = em(e), c = ue(null), [h, f] = De(!1), [d = !1, p] = zt({
    prop: r,
    defaultProp: i,
    onChange: o
  });
  return /* @__PURE__ */ B(ml, a, /* @__PURE__ */ B(XY, {
    scope: e,
    contentId: Ut(),
    triggerRef: c,
    open: d,
    onOpenChange: p,
    onOpenToggle: rt(
      () => p(
        (v) => !v
      ),
      [
        p
      ]
    ),
    hasCustomAnchor: h,
    onCustomAnchorAdd: rt(
      () => f(!0),
      []
    ),
    onCustomAnchorRemove: rt(
      () => f(!1),
      []
    ),
    modal: s
  }, n));
}, QY = "PopoverTrigger", JY = /* @__PURE__ */ O((t, e) => {
  const { __scopePopover: n, ...r } = t, i = oa(QY, n), o = em(n), s = ke(e, i.triggerRef), a = /* @__PURE__ */ B(we.button, G({
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": i.open,
    "aria-controls": i.contentId,
    "data-state": jC(i.open)
  }, r, {
    ref: s,
    onClick: oe(t.onClick, i.onOpenToggle)
  }));
  return i.hasCustomAnchor ? a : /* @__PURE__ */ B(vl, G({
    asChild: !0
  }, o), a);
}), GC = "PopoverPortal", [ej, tj] = qC(GC, {
  forceMount: void 0
}), nj = (t) => {
  const { __scopePopover: e, forceMount: n, children: r, container: i } = t, o = oa(GC, e);
  return /* @__PURE__ */ B(ej, {
    scope: e,
    forceMount: n
  }, /* @__PURE__ */ B(Vt, {
    present: n || o.open
  }, /* @__PURE__ */ B(Zs, {
    asChild: !0,
    container: i
  }, r)));
}, dl = "PopoverContent", rj = /* @__PURE__ */ O((t, e) => {
  const n = tj(dl, t.__scopePopover), { forceMount: r = n.forceMount, ...i } = t, o = oa(dl, t.__scopePopover);
  return /* @__PURE__ */ B(Vt, {
    present: r || o.open
  }, o.modal ? /* @__PURE__ */ B(ij, G({}, i, {
    ref: e
  })) : /* @__PURE__ */ B(oj, G({}, i, {
    ref: e
  })));
}), ij = /* @__PURE__ */ O((t, e) => {
  const n = oa(dl, t.__scopePopover), r = ue(null), i = ke(e, r), o = ue(!1);
  return Ce(() => {
    const s = r.current;
    if (s) return gp(s);
  }, []), /* @__PURE__ */ B(UC, {
    as: Dr,
    allowPinchZoom: !0
  }, /* @__PURE__ */ B(YC, G({}, t, {
    ref: i,
    trapFocus: n.open,
    disableOutsidePointerEvents: !0,
    onCloseAutoFocus: oe(t.onCloseAutoFocus, (s) => {
      var a;
      s.preventDefault(), o.current || (a = n.triggerRef.current) === null || a === void 0 || a.focus();
    }),
    onPointerDownOutside: oe(t.onPointerDownOutside, (s) => {
      const a = s.detail.originalEvent, c = a.button === 0 && a.ctrlKey === !0, h = a.button === 2 || c;
      o.current = h;
    }, {
      checkForDefaultPrevented: !1
    }),
    onFocusOutside: oe(
      t.onFocusOutside,
      (s) => s.preventDefault(),
      {
        checkForDefaultPrevented: !1
      }
    )
  })));
}), oj = /* @__PURE__ */ O((t, e) => {
  const n = oa(dl, t.__scopePopover), r = ue(!1), i = ue(!1);
  return /* @__PURE__ */ B(YC, G({}, t, {
    ref: e,
    trapFocus: !1,
    disableOutsidePointerEvents: !1,
    onCloseAutoFocus: (o) => {
      var s;
      if ((s = t.onCloseAutoFocus) === null || s === void 0 || s.call(t, o), !o.defaultPrevented) {
        var a;
        r.current || (a = n.triggerRef.current) === null || a === void 0 || a.focus(), o.preventDefault();
      }
      r.current = !1, i.current = !1;
    },
    onInteractOutside: (o) => {
      var s, a;
      (s = t.onInteractOutside) === null || s === void 0 || s.call(t, o), o.defaultPrevented || (r.current = !0, o.detail.originalEvent.type === "pointerdown" && (i.current = !0));
      const c = o.target;
      ((a = n.triggerRef.current) === null || a === void 0 ? void 0 : a.contains(c)) && o.preventDefault(), o.detail.originalEvent.type === "focusin" && i.current && o.preventDefault();
    }
  }));
}), YC = /* @__PURE__ */ O((t, e) => {
  const { __scopePopover: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: o, disableOutsidePointerEvents: s, onEscapeKeyDown: a, onPointerDownOutside: c, onFocusOutside: h, onInteractOutside: f, ...d } = t, p = oa(dl, n), v = em(n);
  return Qs(), /* @__PURE__ */ B(Js, {
    asChild: !0,
    loop: !0,
    trapped: r,
    onMountAutoFocus: i,
    onUnmountAutoFocus: o
  }, /* @__PURE__ */ B(No, {
    asChild: !0,
    disableOutsidePointerEvents: s,
    onInteractOutside: f,
    onEscapeKeyDown: a,
    onPointerDownOutside: c,
    onFocusOutside: h,
    onDismiss: () => p.onOpenChange(!1)
  }, /* @__PURE__ */ B(bl, G({
    "data-state": jC(p.open),
    role: "dialog",
    id: p.contentId
  }, v, d, {
    ref: e,
    style: {
      ...d.style,
      "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
      "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
      "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }))));
});
function jC(t) {
  return t ? "open" : "closed";
}
const sj = ZY, aj = JY, lj = nj, cj = rj, XC = "Progress", cf = 100, [uj, Hte] = Tt(XC), [hj, fj] = uj(XC), ZC = /* @__PURE__ */ O((t, e) => {
  const { __scopeProgress: n, value: r, max: i, getValueLabel: o = pj, ...s } = t, a = lg(i) ? i : cf, c = JC(r, a) ? r : null, h = mh(c) ? o(c, a) : void 0;
  return /* @__PURE__ */ B(hj, {
    scope: n,
    value: c,
    max: a
  }, /* @__PURE__ */ B(we.div, G({
    "aria-valuemax": a,
    "aria-valuemin": 0,
    "aria-valuenow": mh(c) ? c : void 0,
    "aria-valuetext": h,
    role: "progressbar",
    "data-state": QC(c, a),
    "data-value": c ?? void 0,
    "data-max": a
  }, s, {
    ref: e
  })));
});
ZC.propTypes = {
  max(t, e, n) {
    const r = t[e], i = String(r);
    return r && !lg(r) ? new Error(mj(i, n)) : null;
  },
  value(t, e, n) {
    const r = t[e], i = String(r), o = lg(t.max) ? t.max : cf;
    return r != null && !JC(r, o) ? new Error(vj(i, n)) : null;
  }
};
const dj = "ProgressIndicator", gj = /* @__PURE__ */ O((t, e) => {
  var n;
  const { __scopeProgress: r, ...i } = t, o = fj(dj, r);
  return /* @__PURE__ */ B(we.div, G({
    "data-state": QC(o.value, o.max),
    "data-value": (n = o.value) !== null && n !== void 0 ? n : void 0,
    "data-max": o.max
  }, i, {
    ref: e
  }));
});
function pj(t, e) {
  return `${Math.round(t / e * 100)}%`;
}
function QC(t, e) {
  return t == null ? "indeterminate" : t === e ? "complete" : "loading";
}
function mh(t) {
  return typeof t == "number";
}
function lg(t) {
  return mh(t) && !isNaN(t) && t > 0;
}
function JC(t, e) {
  return mh(t) && !isNaN(t) && t <= e && t >= 0;
}
function mj(t, e) {
  return `Invalid prop \`max\` of value \`${t}\` supplied to \`${e}\`. Only numbers greater than 0 are valid max values. Defaulting to \`${cf}\`.`;
}
function vj(t, e) {
  return `Invalid prop \`value\` of value \`${t}\` supplied to \`${e}\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${cf} if no \`max\` prop is set)
  - \`null\` if the progress is indeterminate.

Defaulting to \`null\`.`;
}
const bj = ZC, wj = gj, e$ = "Radio", [xj, t$] = Tt(e$), [yj, Cj] = xj(e$), $j = /* @__PURE__ */ O((t, e) => {
  const { __scopeRadio: n, name: r, checked: i = !1, required: o, disabled: s, value: a = "on", onCheck: c, ...h } = t, [f, d] = De(null), p = ke(
    e,
    (b) => d(b)
  ), v = ue(!1), w = f ? !!f.closest("form") : !0;
  return /* @__PURE__ */ B(yj, {
    scope: n,
    checked: i,
    disabled: s
  }, /* @__PURE__ */ B(we.button, G({
    type: "button",
    role: "radio",
    "aria-checked": i,
    "data-state": n$(i),
    "data-disabled": s ? "" : void 0,
    disabled: s,
    value: a
  }, h, {
    ref: p,
    onClick: oe(t.onClick, (b) => {
      i || c?.(), w && (v.current = b.isPropagationStopped(), v.current || b.stopPropagation());
    })
  })), w && /* @__PURE__ */ B(kj, {
    control: f,
    bubbles: !v.current,
    name: r,
    value: a,
    checked: i,
    required: o,
    disabled: s,
    style: {
      transform: "translateX(-100%)"
    }
  }));
}), Sj = "RadioIndicator", Aj = /* @__PURE__ */ O((t, e) => {
  const { __scopeRadio: n, forceMount: r, ...i } = t, o = Cj(Sj, n);
  return /* @__PURE__ */ B(Vt, {
    present: r || o.checked
  }, /* @__PURE__ */ B(we.span, G({
    "data-state": n$(o.checked),
    "data-disabled": o.disabled ? "" : void 0
  }, i, {
    ref: e
  })));
}), kj = (t) => {
  const { control: e, checked: n, bubbles: r = !0, ...i } = t, o = ue(null), s = Nh(n), a = Mh(e);
  return Ce(() => {
    const c = o.current, h = window.HTMLInputElement.prototype, d = Object.getOwnPropertyDescriptor(h, "checked").set;
    if (s !== n && d) {
      const p = new Event("click", {
        bubbles: r
      });
      d.call(c, n), c.dispatchEvent(p);
    }
  }, [
    s,
    n,
    r
  ]), /* @__PURE__ */ B("input", G({
    type: "radio",
    "aria-hidden": !0,
    defaultChecked: n
  }, i, {
    tabIndex: -1,
    ref: o,
    style: {
      ...t.style,
      ...a,
      position: "absolute",
      pointerEvents: "none",
      opacity: 0,
      margin: 0
    }
  }));
};
function n$(t) {
  return t ? "checked" : "unchecked";
}
const Mj = [
  "ArrowUp",
  "ArrowDown",
  "ArrowLeft",
  "ArrowRight"
], r$ = "RadioGroup", [Tj, Pte] = Tt(r$, [
  ta,
  t$
]), i$ = ta(), o$ = t$(), [Rj, Ej] = Tj(r$), Oj = /* @__PURE__ */ O((t, e) => {
  const { __scopeRadioGroup: n, name: r, defaultValue: i, value: o, required: s = !1, disabled: a = !1, orientation: c, dir: h, loop: f = !0, onValueChange: d, ...p } = t, v = i$(n), w = Fo(h), [b, y] = zt({
    prop: o,
    defaultProp: i,
    onChange: d
  });
  return /* @__PURE__ */ B(Rj, {
    scope: n,
    name: r,
    required: s,
    disabled: a,
    value: b,
    onValueChange: y
  }, /* @__PURE__ */ B(fp, G({
    asChild: !0
  }, v, {
    orientation: c,
    dir: w,
    loop: f
  }), /* @__PURE__ */ B(we.div, G({
    role: "radiogroup",
    "aria-required": s,
    "aria-orientation": c,
    "data-disabled": a ? "" : void 0,
    dir: w
  }, p, {
    ref: e
  }))));
}), Dj = "RadioGroupItem", Ij = /* @__PURE__ */ O((t, e) => {
  const { __scopeRadioGroup: n, disabled: r, ...i } = t, o = Ej(Dj, n), s = o.disabled || r, a = i$(n), c = o$(n), h = ue(null), f = ke(e, h), d = o.value === i.value, p = ue(!1);
  return Ce(() => {
    const v = (b) => {
      Mj.includes(b.key) && (p.current = !0);
    }, w = () => p.current = !1;
    return document.addEventListener("keydown", v), document.addEventListener("keyup", w), () => {
      document.removeEventListener("keydown", v), document.removeEventListener("keyup", w);
    };
  }, []), /* @__PURE__ */ B(dp, G({
    asChild: !0
  }, a, {
    focusable: !s,
    active: d
  }), /* @__PURE__ */ B($j, G({
    disabled: s,
    required: o.required,
    checked: d
  }, c, i, {
    name: o.name,
    ref: f,
    onCheck: () => o.onValueChange(i.value),
    onKeyDown: oe((v) => {
      v.key === "Enter" && v.preventDefault();
    }),
    onFocus: oe(i.onFocus, () => {
      var v;
      p.current && ((v = h.current) === null || v === void 0 || v.click());
    })
  })));
}), _j = /* @__PURE__ */ O((t, e) => {
  const { __scopeRadioGroup: n, ...r } = t, i = o$(n);
  return /* @__PURE__ */ B(Aj, G({}, i, r, {
    ref: e
  }));
}), Lj = Oj, Bj = Ij, Nj = _j, s$ = "Switch", [Fj, Wte] = Tt(s$), [Vj, Hj] = Fj(s$), Pj = /* @__PURE__ */ O((t, e) => {
  const { __scopeSwitch: n, name: r, checked: i, defaultChecked: o, required: s, disabled: a, value: c = "on", onCheckedChange: h, ...f } = t, [d, p] = De(null), v = ke(
    e,
    (A) => p(A)
  ), w = ue(!1), b = d ? !!d.closest("form") : !0, [y = !1, $] = zt({
    prop: i,
    defaultProp: o,
    onChange: h
  });
  return /* @__PURE__ */ B(Vj, {
    scope: n,
    checked: y,
    disabled: a
  }, /* @__PURE__ */ B(we.button, G({
    type: "button",
    role: "switch",
    "aria-checked": y,
    "aria-required": s,
    "data-state": a$(y),
    "data-disabled": a ? "" : void 0,
    disabled: a,
    value: c
  }, f, {
    ref: v,
    onClick: oe(t.onClick, (A) => {
      $(
        (k) => !k
      ), b && (w.current = A.isPropagationStopped(), w.current || A.stopPropagation());
    })
  })), b && /* @__PURE__ */ B(Uj, {
    control: d,
    bubbles: !w.current,
    name: r,
    value: c,
    checked: y,
    required: s,
    disabled: a,
    style: {
      transform: "translateX(-100%)"
    }
  }));
}), Wj = "SwitchThumb", zj = /* @__PURE__ */ O((t, e) => {
  const { __scopeSwitch: n, ...r } = t, i = Hj(Wj, n);
  return /* @__PURE__ */ B(we.span, G({
    "data-state": a$(i.checked),
    "data-disabled": i.disabled ? "" : void 0
  }, r, {
    ref: e
  }));
}), Uj = (t) => {
  const { control: e, checked: n, bubbles: r = !0, ...i } = t, o = ue(null), s = Nh(n), a = Mh(e);
  return Ce(() => {
    const c = o.current, h = window.HTMLInputElement.prototype, d = Object.getOwnPropertyDescriptor(h, "checked").set;
    if (s !== n && d) {
      const p = new Event("click", {
        bubbles: r
      });
      d.call(c, n), c.dispatchEvent(p);
    }
  }, [
    s,
    n,
    r
  ]), /* @__PURE__ */ B("input", G({
    type: "checkbox",
    "aria-hidden": !0,
    defaultChecked: n
  }, i, {
    tabIndex: -1,
    ref: o,
    style: {
      ...t.style,
      ...a,
      position: "absolute",
      pointerEvents: "none",
      opacity: 0,
      margin: 0
    }
  }));
};
function a$(t) {
  return t ? "checked" : "unchecked";
}
const Kj = Pj, qj = zj, l$ = "Tabs", [Gj, zte] = Tt(l$, [
  ta
]), c$ = ta(), [Yj, tm] = Gj(l$), jj = /* @__PURE__ */ O((t, e) => {
  const { __scopeTabs: n, value: r, onValueChange: i, defaultValue: o, orientation: s = "horizontal", dir: a, activationMode: c = "automatic", ...h } = t, f = Fo(a), [d, p] = zt({
    prop: r,
    onChange: i,
    defaultProp: o
  });
  return /* @__PURE__ */ B(Yj, {
    scope: n,
    baseId: Ut(),
    value: d,
    onValueChange: p,
    orientation: s,
    dir: f,
    activationMode: c
  }, /* @__PURE__ */ B(we.div, G({
    dir: f,
    "data-orientation": s
  }, h, {
    ref: e
  })));
}), Xj = "TabsList", Zj = /* @__PURE__ */ O((t, e) => {
  const { __scopeTabs: n, loop: r = !0, ...i } = t, o = tm(Xj, n), s = c$(n);
  return /* @__PURE__ */ B(fp, G({
    asChild: !0
  }, s, {
    orientation: o.orientation,
    dir: o.dir,
    loop: r
  }), /* @__PURE__ */ B(we.div, G({
    role: "tablist",
    "aria-orientation": o.orientation
  }, i, {
    ref: e
  })));
}), Qj = "TabsTrigger", Jj = /* @__PURE__ */ O((t, e) => {
  const { __scopeTabs: n, value: r, disabled: i = !1, ...o } = t, s = tm(Qj, n), a = c$(n), c = u$(s.baseId, r), h = h$(s.baseId, r), f = r === s.value;
  return /* @__PURE__ */ B(dp, G({
    asChild: !0
  }, a, {
    focusable: !i,
    active: f
  }), /* @__PURE__ */ B(we.button, G({
    type: "button",
    role: "tab",
    "aria-selected": f,
    "aria-controls": h,
    "data-state": f ? "active" : "inactive",
    "data-disabled": i ? "" : void 0,
    disabled: i,
    id: c
  }, o, {
    ref: e,
    onMouseDown: oe(t.onMouseDown, (d) => {
      !i && d.button === 0 && d.ctrlKey === !1 ? s.onValueChange(r) : d.preventDefault();
    }),
    onKeyDown: oe(t.onKeyDown, (d) => {
      [
        " ",
        "Enter"
      ].includes(d.key) && s.onValueChange(r);
    }),
    onFocus: oe(t.onFocus, () => {
      const d = s.activationMode !== "manual";
      !f && !i && d && s.onValueChange(r);
    })
  })));
}), eX = "TabsContent", tX = /* @__PURE__ */ O((t, e) => {
  const { __scopeTabs: n, value: r, forceMount: i, children: o, ...s } = t, a = tm(eX, n), c = u$(a.baseId, r), h = h$(a.baseId, r), f = r === a.value, d = ue(f);
  return Ce(() => {
    const p = requestAnimationFrame(
      () => d.current = !1
    );
    return () => cancelAnimationFrame(p);
  }, []), /* @__PURE__ */ B(
    Vt,
    {
      present: i || f
    },
    ({ present: p }) => /* @__PURE__ */ B(we.div, G({
      "data-state": f ? "active" : "inactive",
      "data-orientation": a.orientation,
      role: "tabpanel",
      "aria-labelledby": c,
      hidden: !p,
      id: h,
      tabIndex: 0
    }, s, {
      ref: e,
      style: {
        ...t.style,
        animationDuration: d.current ? "0s" : void 0
      }
    }), p && o)
  );
});
function u$(t, e) {
  return `${t}-trigger-${e}`;
}
function h$(t, e) {
  return `${t}-content-${e}`;
}
const nX = jj, rX = Zj, iX = Jj, oX = tX;
var Ra = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ute(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function Kte(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(t, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return t[r];
      }
    });
  }), n;
}
var vh = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
vh.exports;
(function(t, e) {
  (function() {
    var n, r = "4.17.21", i = 200, o = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", s = "Expected a function", a = "Invalid `variable` option passed into `_.template`", c = "__lodash_hash_undefined__", h = 500, f = "__lodash_placeholder__", d = 1, p = 2, v = 4, w = 1, b = 2, y = 1, $ = 2, A = 4, k = 8, T = 16, R = 32, _ = 64, D = 128, P = 256, H = 512, z = 30, j = "...", K = 800, te = 16, ee = 1, re = 2, de = 3, ie = 1 / 0, se = 9007199254740991, X = 17976931348623157e292, ce = NaN, be = 4294967295, Le = be - 1, Ae = be >>> 1, qe = [
      ["ary", D],
      ["bind", y],
      ["bindKey", $],
      ["curry", k],
      ["curryRight", T],
      ["flip", H],
      ["partial", R],
      ["partialRight", _],
      ["rearg", P]
    ], He = "[object Arguments]", Ze = "[object Array]", xe = "[object AsyncFunction]", Ve = "[object Boolean]", Oe = "[object Date]", Ue = "[object DOMException]", Ee = "[object Error]", je = "[object Function]", Rt = "[object GeneratorFunction]", at = "[object Map]", Qe = "[object Number]", an = "[object Null]", Ct = "[object Object]", Uo = "[object Promise]", Ko = "[object Proxy]", Pr = "[object RegExp]", It = "[object Set]", Wr = "[object String]", zr = "[object Symbol]", vf = "[object Undefined]", Ur = "[object WeakMap]", bf = "[object WeakSet]", Ji = "[object ArrayBuffer]", mr = "[object DataView]", qt = "[object Float32Array]", wf = "[object Float64Array]", xf = "[object Int8Array]", yf = "[object Int16Array]", Cf = "[object Int32Array]", $f = "[object Uint8Array]", Sf = "[object Uint8ClampedArray]", Af = "[object Uint16Array]", kf = "[object Uint32Array]", s8 = /\b__p \+= '';/g, a8 = /\b(__p \+=) '' \+/g, l8 = /(__e\(.*?\)|\b__t\)) \+\n'';/g, hm = /&(?:amp|lt|gt|quot|#39);/g, fm = /[&<>"']/g, c8 = RegExp(hm.source), u8 = RegExp(fm.source), h8 = /<%-([\s\S]+?)%>/g, f8 = /<%([\s\S]+?)%>/g, dm = /<%=([\s\S]+?)%>/g, d8 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, g8 = /^\w*$/, p8 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Mf = /[\\^$.*+?()[\]{}|]/g, m8 = RegExp(Mf.source), Tf = /^\s+/, v8 = /\s/, b8 = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, w8 = /\{\n\/\* \[wrapped with (.+)\] \*/, x8 = /,? & /, y8 = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, C8 = /[()=,{}\[\]\/\s]/, $8 = /\\(\\)?/g, S8 = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, gm = /\w*$/, A8 = /^[-+]0x[0-9a-f]+$/i, k8 = /^0b[01]+$/i, M8 = /^\[object .+?Constructor\]$/, T8 = /^0o[0-7]+$/i, R8 = /^(?:0|[1-9]\d*)$/, E8 = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Vl = /($^)/, O8 = /['\n\r\u2028\u2029\\]/g, Hl = "\\ud800-\\udfff", D8 = "\\u0300-\\u036f", I8 = "\\ufe20-\\ufe2f", _8 = "\\u20d0-\\u20ff", pm = D8 + I8 + _8, mm = "\\u2700-\\u27bf", vm = "a-z\\xdf-\\xf6\\xf8-\\xff", L8 = "\\xac\\xb1\\xd7\\xf7", B8 = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", N8 = "\\u2000-\\u206f", F8 = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", bm = "A-Z\\xc0-\\xd6\\xd8-\\xde", wm = "\\ufe0e\\ufe0f", xm = L8 + B8 + N8 + F8, Rf = "['’]", V8 = "[" + Hl + "]", ym = "[" + xm + "]", Pl = "[" + pm + "]", Cm = "\\d+", H8 = "[" + mm + "]", $m = "[" + vm + "]", Sm = "[^" + Hl + xm + Cm + mm + vm + bm + "]", Ef = "\\ud83c[\\udffb-\\udfff]", P8 = "(?:" + Pl + "|" + Ef + ")", Am = "[^" + Hl + "]", Of = "(?:\\ud83c[\\udde6-\\uddff]){2}", Df = "[\\ud800-\\udbff][\\udc00-\\udfff]", qo = "[" + bm + "]", km = "\\u200d", Mm = "(?:" + $m + "|" + Sm + ")", W8 = "(?:" + qo + "|" + Sm + ")", Tm = "(?:" + Rf + "(?:d|ll|m|re|s|t|ve))?", Rm = "(?:" + Rf + "(?:D|LL|M|RE|S|T|VE))?", Em = P8 + "?", Om = "[" + wm + "]?", z8 = "(?:" + km + "(?:" + [Am, Of, Df].join("|") + ")" + Om + Em + ")*", U8 = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", K8 = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", Dm = Om + Em + z8, q8 = "(?:" + [H8, Of, Df].join("|") + ")" + Dm, G8 = "(?:" + [Am + Pl + "?", Pl, Of, Df, V8].join("|") + ")", Y8 = RegExp(Rf, "g"), j8 = RegExp(Pl, "g"), If = RegExp(Ef + "(?=" + Ef + ")|" + G8 + Dm, "g"), X8 = RegExp([
      qo + "?" + $m + "+" + Tm + "(?=" + [ym, qo, "$"].join("|") + ")",
      W8 + "+" + Rm + "(?=" + [ym, qo + Mm, "$"].join("|") + ")",
      qo + "?" + Mm + "+" + Tm,
      qo + "+" + Rm,
      K8,
      U8,
      Cm,
      q8
    ].join("|"), "g"), Z8 = RegExp("[" + km + Hl + pm + wm + "]"), Q8 = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, J8 = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], e7 = -1, gt = {};
    gt[qt] = gt[wf] = gt[xf] = gt[yf] = gt[Cf] = gt[$f] = gt[Sf] = gt[Af] = gt[kf] = !0, gt[He] = gt[Ze] = gt[Ji] = gt[Ve] = gt[mr] = gt[Oe] = gt[Ee] = gt[je] = gt[at] = gt[Qe] = gt[Ct] = gt[Pr] = gt[It] = gt[Wr] = gt[Ur] = !1;
    var dt = {};
    dt[He] = dt[Ze] = dt[Ji] = dt[mr] = dt[Ve] = dt[Oe] = dt[qt] = dt[wf] = dt[xf] = dt[yf] = dt[Cf] = dt[at] = dt[Qe] = dt[Ct] = dt[Pr] = dt[It] = dt[Wr] = dt[zr] = dt[$f] = dt[Sf] = dt[Af] = dt[kf] = !0, dt[Ee] = dt[je] = dt[Ur] = !1;
    var t7 = {
      // Latin-1 Supplement block.
      À: "A",
      Á: "A",
      Â: "A",
      Ã: "A",
      Ä: "A",
      Å: "A",
      à: "a",
      á: "a",
      â: "a",
      ã: "a",
      ä: "a",
      å: "a",
      Ç: "C",
      ç: "c",
      Ð: "D",
      ð: "d",
      È: "E",
      É: "E",
      Ê: "E",
      Ë: "E",
      è: "e",
      é: "e",
      ê: "e",
      ë: "e",
      Ì: "I",
      Í: "I",
      Î: "I",
      Ï: "I",
      ì: "i",
      í: "i",
      î: "i",
      ï: "i",
      Ñ: "N",
      ñ: "n",
      Ò: "O",
      Ó: "O",
      Ô: "O",
      Õ: "O",
      Ö: "O",
      Ø: "O",
      ò: "o",
      ó: "o",
      ô: "o",
      õ: "o",
      ö: "o",
      ø: "o",
      Ù: "U",
      Ú: "U",
      Û: "U",
      Ü: "U",
      ù: "u",
      ú: "u",
      û: "u",
      ü: "u",
      Ý: "Y",
      ý: "y",
      ÿ: "y",
      Æ: "Ae",
      æ: "ae",
      Þ: "Th",
      þ: "th",
      ß: "ss",
      // Latin Extended-A block.
      Ā: "A",
      Ă: "A",
      Ą: "A",
      ā: "a",
      ă: "a",
      ą: "a",
      Ć: "C",
      Ĉ: "C",
      Ċ: "C",
      Č: "C",
      ć: "c",
      ĉ: "c",
      ċ: "c",
      č: "c",
      Ď: "D",
      Đ: "D",
      ď: "d",
      đ: "d",
      Ē: "E",
      Ĕ: "E",
      Ė: "E",
      Ę: "E",
      Ě: "E",
      ē: "e",
      ĕ: "e",
      ė: "e",
      ę: "e",
      ě: "e",
      Ĝ: "G",
      Ğ: "G",
      Ġ: "G",
      Ģ: "G",
      ĝ: "g",
      ğ: "g",
      ġ: "g",
      ģ: "g",
      Ĥ: "H",
      Ħ: "H",
      ĥ: "h",
      ħ: "h",
      Ĩ: "I",
      Ī: "I",
      Ĭ: "I",
      Į: "I",
      İ: "I",
      ĩ: "i",
      ī: "i",
      ĭ: "i",
      į: "i",
      ı: "i",
      Ĵ: "J",
      ĵ: "j",
      Ķ: "K",
      ķ: "k",
      ĸ: "k",
      Ĺ: "L",
      Ļ: "L",
      Ľ: "L",
      Ŀ: "L",
      Ł: "L",
      ĺ: "l",
      ļ: "l",
      ľ: "l",
      ŀ: "l",
      ł: "l",
      Ń: "N",
      Ņ: "N",
      Ň: "N",
      Ŋ: "N",
      ń: "n",
      ņ: "n",
      ň: "n",
      ŋ: "n",
      Ō: "O",
      Ŏ: "O",
      Ő: "O",
      ō: "o",
      ŏ: "o",
      ő: "o",
      Ŕ: "R",
      Ŗ: "R",
      Ř: "R",
      ŕ: "r",
      ŗ: "r",
      ř: "r",
      Ś: "S",
      Ŝ: "S",
      Ş: "S",
      Š: "S",
      ś: "s",
      ŝ: "s",
      ş: "s",
      š: "s",
      Ţ: "T",
      Ť: "T",
      Ŧ: "T",
      ţ: "t",
      ť: "t",
      ŧ: "t",
      Ũ: "U",
      Ū: "U",
      Ŭ: "U",
      Ů: "U",
      Ű: "U",
      Ų: "U",
      ũ: "u",
      ū: "u",
      ŭ: "u",
      ů: "u",
      ű: "u",
      ų: "u",
      Ŵ: "W",
      ŵ: "w",
      Ŷ: "Y",
      ŷ: "y",
      Ÿ: "Y",
      Ź: "Z",
      Ż: "Z",
      Ž: "Z",
      ź: "z",
      ż: "z",
      ž: "z",
      Ĳ: "IJ",
      ĳ: "ij",
      Œ: "Oe",
      œ: "oe",
      ŉ: "'n",
      ſ: "s"
    }, n7 = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, r7 = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, i7 = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, o7 = parseFloat, s7 = parseInt, Im = typeof Ra == "object" && Ra && Ra.Object === Object && Ra, a7 = typeof self == "object" && self && self.Object === Object && self, Gt = Im || a7 || Function("return this")(), _f = e && !e.nodeType && e, eo = _f && !0 && t && !t.nodeType && t, _m = eo && eo.exports === _f, Lf = _m && Im.process, Hn = function() {
      try {
        var N = eo && eo.require && eo.require("util").types;
        return N || Lf && Lf.binding && Lf.binding("util");
      } catch {
      }
    }(), Lm = Hn && Hn.isArrayBuffer, Bm = Hn && Hn.isDate, Nm = Hn && Hn.isMap, Fm = Hn && Hn.isRegExp, Vm = Hn && Hn.isSet, Hm = Hn && Hn.isTypedArray;
    function Mn(N, Y, U) {
      switch (U.length) {
        case 0:
          return N.call(Y);
        case 1:
          return N.call(Y, U[0]);
        case 2:
          return N.call(Y, U[0], U[1]);
        case 3:
          return N.call(Y, U[0], U[1], U[2]);
      }
      return N.apply(Y, U);
    }
    function l7(N, Y, U, ve) {
      for (var Be = -1, it = N == null ? 0 : N.length; ++Be < it; ) {
        var _t = N[Be];
        Y(ve, _t, U(_t), N);
      }
      return ve;
    }
    function Pn(N, Y) {
      for (var U = -1, ve = N == null ? 0 : N.length; ++U < ve && Y(N[U], U, N) !== !1; )
        ;
      return N;
    }
    function c7(N, Y) {
      for (var U = N == null ? 0 : N.length; U-- && Y(N[U], U, N) !== !1; )
        ;
      return N;
    }
    function Pm(N, Y) {
      for (var U = -1, ve = N == null ? 0 : N.length; ++U < ve; )
        if (!Y(N[U], U, N))
          return !1;
      return !0;
    }
    function yi(N, Y) {
      for (var U = -1, ve = N == null ? 0 : N.length, Be = 0, it = []; ++U < ve; ) {
        var _t = N[U];
        Y(_t, U, N) && (it[Be++] = _t);
      }
      return it;
    }
    function Wl(N, Y) {
      var U = N == null ? 0 : N.length;
      return !!U && Go(N, Y, 0) > -1;
    }
    function Bf(N, Y, U) {
      for (var ve = -1, Be = N == null ? 0 : N.length; ++ve < Be; )
        if (U(Y, N[ve]))
          return !0;
      return !1;
    }
    function vt(N, Y) {
      for (var U = -1, ve = N == null ? 0 : N.length, Be = Array(ve); ++U < ve; )
        Be[U] = Y(N[U], U, N);
      return Be;
    }
    function Ci(N, Y) {
      for (var U = -1, ve = Y.length, Be = N.length; ++U < ve; )
        N[Be + U] = Y[U];
      return N;
    }
    function Nf(N, Y, U, ve) {
      var Be = -1, it = N == null ? 0 : N.length;
      for (ve && it && (U = N[++Be]); ++Be < it; )
        U = Y(U, N[Be], Be, N);
      return U;
    }
    function u7(N, Y, U, ve) {
      var Be = N == null ? 0 : N.length;
      for (ve && Be && (U = N[--Be]); Be--; )
        U = Y(U, N[Be], Be, N);
      return U;
    }
    function Ff(N, Y) {
      for (var U = -1, ve = N == null ? 0 : N.length; ++U < ve; )
        if (Y(N[U], U, N))
          return !0;
      return !1;
    }
    var h7 = Vf("length");
    function f7(N) {
      return N.split("");
    }
    function d7(N) {
      return N.match(y8) || [];
    }
    function Wm(N, Y, U) {
      var ve;
      return U(N, function(Be, it, _t) {
        if (Y(Be, it, _t))
          return ve = it, !1;
      }), ve;
    }
    function zl(N, Y, U, ve) {
      for (var Be = N.length, it = U + (ve ? 1 : -1); ve ? it-- : ++it < Be; )
        if (Y(N[it], it, N))
          return it;
      return -1;
    }
    function Go(N, Y, U) {
      return Y === Y ? A7(N, Y, U) : zl(N, zm, U);
    }
    function g7(N, Y, U, ve) {
      for (var Be = U - 1, it = N.length; ++Be < it; )
        if (ve(N[Be], Y))
          return Be;
      return -1;
    }
    function zm(N) {
      return N !== N;
    }
    function Um(N, Y) {
      var U = N == null ? 0 : N.length;
      return U ? Pf(N, Y) / U : ce;
    }
    function Vf(N) {
      return function(Y) {
        return Y == null ? n : Y[N];
      };
    }
    function Hf(N) {
      return function(Y) {
        return N == null ? n : N[Y];
      };
    }
    function Km(N, Y, U, ve, Be) {
      return Be(N, function(it, _t, ct) {
        U = ve ? (ve = !1, it) : Y(U, it, _t, ct);
      }), U;
    }
    function p7(N, Y) {
      var U = N.length;
      for (N.sort(Y); U--; )
        N[U] = N[U].value;
      return N;
    }
    function Pf(N, Y) {
      for (var U, ve = -1, Be = N.length; ++ve < Be; ) {
        var it = Y(N[ve]);
        it !== n && (U = U === n ? it : U + it);
      }
      return U;
    }
    function Wf(N, Y) {
      for (var U = -1, ve = Array(N); ++U < N; )
        ve[U] = Y(U);
      return ve;
    }
    function m7(N, Y) {
      return vt(Y, function(U) {
        return [U, N[U]];
      });
    }
    function qm(N) {
      return N && N.slice(0, Xm(N) + 1).replace(Tf, "");
    }
    function Tn(N) {
      return function(Y) {
        return N(Y);
      };
    }
    function zf(N, Y) {
      return vt(Y, function(U) {
        return N[U];
      });
    }
    function aa(N, Y) {
      return N.has(Y);
    }
    function Gm(N, Y) {
      for (var U = -1, ve = N.length; ++U < ve && Go(Y, N[U], 0) > -1; )
        ;
      return U;
    }
    function Ym(N, Y) {
      for (var U = N.length; U-- && Go(Y, N[U], 0) > -1; )
        ;
      return U;
    }
    function v7(N, Y) {
      for (var U = N.length, ve = 0; U--; )
        N[U] === Y && ++ve;
      return ve;
    }
    var b7 = Hf(t7), w7 = Hf(n7);
    function x7(N) {
      return "\\" + i7[N];
    }
    function y7(N, Y) {
      return N == null ? n : N[Y];
    }
    function Yo(N) {
      return Z8.test(N);
    }
    function C7(N) {
      return Q8.test(N);
    }
    function $7(N) {
      for (var Y, U = []; !(Y = N.next()).done; )
        U.push(Y.value);
      return U;
    }
    function Uf(N) {
      var Y = -1, U = Array(N.size);
      return N.forEach(function(ve, Be) {
        U[++Y] = [Be, ve];
      }), U;
    }
    function jm(N, Y) {
      return function(U) {
        return N(Y(U));
      };
    }
    function $i(N, Y) {
      for (var U = -1, ve = N.length, Be = 0, it = []; ++U < ve; ) {
        var _t = N[U];
        (_t === Y || _t === f) && (N[U] = f, it[Be++] = U);
      }
      return it;
    }
    function Ul(N) {
      var Y = -1, U = Array(N.size);
      return N.forEach(function(ve) {
        U[++Y] = ve;
      }), U;
    }
    function S7(N) {
      var Y = -1, U = Array(N.size);
      return N.forEach(function(ve) {
        U[++Y] = [ve, ve];
      }), U;
    }
    function A7(N, Y, U) {
      for (var ve = U - 1, Be = N.length; ++ve < Be; )
        if (N[ve] === Y)
          return ve;
      return -1;
    }
    function k7(N, Y, U) {
      for (var ve = U + 1; ve--; )
        if (N[ve] === Y)
          return ve;
      return ve;
    }
    function jo(N) {
      return Yo(N) ? T7(N) : h7(N);
    }
    function er(N) {
      return Yo(N) ? R7(N) : f7(N);
    }
    function Xm(N) {
      for (var Y = N.length; Y-- && v8.test(N.charAt(Y)); )
        ;
      return Y;
    }
    var M7 = Hf(r7);
    function T7(N) {
      for (var Y = If.lastIndex = 0; If.test(N); )
        ++Y;
      return Y;
    }
    function R7(N) {
      return N.match(If) || [];
    }
    function E7(N) {
      return N.match(X8) || [];
    }
    var O7 = function N(Y) {
      Y = Y == null ? Gt : Xo.defaults(Gt.Object(), Y, Xo.pick(Gt, J8));
      var U = Y.Array, ve = Y.Date, Be = Y.Error, it = Y.Function, _t = Y.Math, ct = Y.Object, Kf = Y.RegExp, D7 = Y.String, Wn = Y.TypeError, Kl = U.prototype, I7 = it.prototype, Zo = ct.prototype, ql = Y["__core-js_shared__"], Gl = I7.toString, st = Zo.hasOwnProperty, _7 = 0, Zm = function() {
        var l = /[^.]+$/.exec(ql && ql.keys && ql.keys.IE_PROTO || "");
        return l ? "Symbol(src)_1." + l : "";
      }(), Yl = Zo.toString, L7 = Gl.call(ct), B7 = Gt._, N7 = Kf(
        "^" + Gl.call(st).replace(Mf, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), jl = _m ? Y.Buffer : n, Si = Y.Symbol, Xl = Y.Uint8Array, Qm = jl ? jl.allocUnsafe : n, Zl = jm(ct.getPrototypeOf, ct), Jm = ct.create, e2 = Zo.propertyIsEnumerable, Ql = Kl.splice, t2 = Si ? Si.isConcatSpreadable : n, la = Si ? Si.iterator : n, to = Si ? Si.toStringTag : n, Jl = function() {
        try {
          var l = so(ct, "defineProperty");
          return l({}, "", {}), l;
        } catch {
        }
      }(), F7 = Y.clearTimeout !== Gt.clearTimeout && Y.clearTimeout, V7 = ve && ve.now !== Gt.Date.now && ve.now, H7 = Y.setTimeout !== Gt.setTimeout && Y.setTimeout, ec = _t.ceil, tc = _t.floor, qf = ct.getOwnPropertySymbols, P7 = jl ? jl.isBuffer : n, n2 = Y.isFinite, W7 = Kl.join, z7 = jm(ct.keys, ct), Lt = _t.max, Qt = _t.min, U7 = ve.now, K7 = Y.parseInt, r2 = _t.random, q7 = Kl.reverse, Gf = so(Y, "DataView"), ca = so(Y, "Map"), Yf = so(Y, "Promise"), Qo = so(Y, "Set"), ua = so(Y, "WeakMap"), ha = so(ct, "create"), nc = ua && new ua(), Jo = {}, G7 = ao(Gf), Y7 = ao(ca), j7 = ao(Yf), X7 = ao(Qo), Z7 = ao(ua), rc = Si ? Si.prototype : n, fa = rc ? rc.valueOf : n, i2 = rc ? rc.toString : n;
      function M(l) {
        if (yt(l) && !Fe(l) && !(l instanceof Xe)) {
          if (l instanceof zn)
            return l;
          if (st.call(l, "__wrapped__"))
            return ov(l);
        }
        return new zn(l);
      }
      var es = /* @__PURE__ */ function() {
        function l() {
        }
        return function(u) {
          if (!wt(u))
            return {};
          if (Jm)
            return Jm(u);
          l.prototype = u;
          var g = new l();
          return l.prototype = n, g;
        };
      }();
      function ic() {
      }
      function zn(l, u) {
        this.__wrapped__ = l, this.__actions__ = [], this.__chain__ = !!u, this.__index__ = 0, this.__values__ = n;
      }
      M.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: h8,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: f8,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: dm,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: M
        }
      }, M.prototype = ic.prototype, M.prototype.constructor = M, zn.prototype = es(ic.prototype), zn.prototype.constructor = zn;
      function Xe(l) {
        this.__wrapped__ = l, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = be, this.__views__ = [];
      }
      function Q7() {
        var l = new Xe(this.__wrapped__);
        return l.__actions__ = pn(this.__actions__), l.__dir__ = this.__dir__, l.__filtered__ = this.__filtered__, l.__iteratees__ = pn(this.__iteratees__), l.__takeCount__ = this.__takeCount__, l.__views__ = pn(this.__views__), l;
      }
      function J7() {
        if (this.__filtered__) {
          var l = new Xe(this);
          l.__dir__ = -1, l.__filtered__ = !0;
        } else
          l = this.clone(), l.__dir__ *= -1;
        return l;
      }
      function eS() {
        var l = this.__wrapped__.value(), u = this.__dir__, g = Fe(l), x = u < 0, S = g ? l.length : 0, E = f9(0, S, this.__views__), I = E.start, L = E.end, F = L - I, Z = x ? L : I - 1, Q = this.__iteratees__, ne = Q.length, he = 0, ye = Qt(F, this.__takeCount__);
        if (!g || !x && S == F && ye == F)
          return T2(l, this.__actions__);
        var Te = [];
        e:
          for (; F-- && he < ye; ) {
            Z += u;
            for (var We = -1, Re = l[Z]; ++We < ne; ) {
              var Ye = Q[We], Je = Ye.iteratee, On = Ye.type, un = Je(Re);
              if (On == re)
                Re = un;
              else if (!un) {
                if (On == ee)
                  continue e;
                break e;
              }
            }
            Te[he++] = Re;
          }
        return Te;
      }
      Xe.prototype = es(ic.prototype), Xe.prototype.constructor = Xe;
      function no(l) {
        var u = -1, g = l == null ? 0 : l.length;
        for (this.clear(); ++u < g; ) {
          var x = l[u];
          this.set(x[0], x[1]);
        }
      }
      function tS() {
        this.__data__ = ha ? ha(null) : {}, this.size = 0;
      }
      function nS(l) {
        var u = this.has(l) && delete this.__data__[l];
        return this.size -= u ? 1 : 0, u;
      }
      function rS(l) {
        var u = this.__data__;
        if (ha) {
          var g = u[l];
          return g === c ? n : g;
        }
        return st.call(u, l) ? u[l] : n;
      }
      function iS(l) {
        var u = this.__data__;
        return ha ? u[l] !== n : st.call(u, l);
      }
      function oS(l, u) {
        var g = this.__data__;
        return this.size += this.has(l) ? 0 : 1, g[l] = ha && u === n ? c : u, this;
      }
      no.prototype.clear = tS, no.prototype.delete = nS, no.prototype.get = rS, no.prototype.has = iS, no.prototype.set = oS;
      function Kr(l) {
        var u = -1, g = l == null ? 0 : l.length;
        for (this.clear(); ++u < g; ) {
          var x = l[u];
          this.set(x[0], x[1]);
        }
      }
      function sS() {
        this.__data__ = [], this.size = 0;
      }
      function aS(l) {
        var u = this.__data__, g = oc(u, l);
        if (g < 0)
          return !1;
        var x = u.length - 1;
        return g == x ? u.pop() : Ql.call(u, g, 1), --this.size, !0;
      }
      function lS(l) {
        var u = this.__data__, g = oc(u, l);
        return g < 0 ? n : u[g][1];
      }
      function cS(l) {
        return oc(this.__data__, l) > -1;
      }
      function uS(l, u) {
        var g = this.__data__, x = oc(g, l);
        return x < 0 ? (++this.size, g.push([l, u])) : g[x][1] = u, this;
      }
      Kr.prototype.clear = sS, Kr.prototype.delete = aS, Kr.prototype.get = lS, Kr.prototype.has = cS, Kr.prototype.set = uS;
      function qr(l) {
        var u = -1, g = l == null ? 0 : l.length;
        for (this.clear(); ++u < g; ) {
          var x = l[u];
          this.set(x[0], x[1]);
        }
      }
      function hS() {
        this.size = 0, this.__data__ = {
          hash: new no(),
          map: new (ca || Kr)(),
          string: new no()
        };
      }
      function fS(l) {
        var u = vc(this, l).delete(l);
        return this.size -= u ? 1 : 0, u;
      }
      function dS(l) {
        return vc(this, l).get(l);
      }
      function gS(l) {
        return vc(this, l).has(l);
      }
      function pS(l, u) {
        var g = vc(this, l), x = g.size;
        return g.set(l, u), this.size += g.size == x ? 0 : 1, this;
      }
      qr.prototype.clear = hS, qr.prototype.delete = fS, qr.prototype.get = dS, qr.prototype.has = gS, qr.prototype.set = pS;
      function ro(l) {
        var u = -1, g = l == null ? 0 : l.length;
        for (this.__data__ = new qr(); ++u < g; )
          this.add(l[u]);
      }
      function mS(l) {
        return this.__data__.set(l, c), this;
      }
      function vS(l) {
        return this.__data__.has(l);
      }
      ro.prototype.add = ro.prototype.push = mS, ro.prototype.has = vS;
      function tr(l) {
        var u = this.__data__ = new Kr(l);
        this.size = u.size;
      }
      function bS() {
        this.__data__ = new Kr(), this.size = 0;
      }
      function wS(l) {
        var u = this.__data__, g = u.delete(l);
        return this.size = u.size, g;
      }
      function xS(l) {
        return this.__data__.get(l);
      }
      function yS(l) {
        return this.__data__.has(l);
      }
      function CS(l, u) {
        var g = this.__data__;
        if (g instanceof Kr) {
          var x = g.__data__;
          if (!ca || x.length < i - 1)
            return x.push([l, u]), this.size = ++g.size, this;
          g = this.__data__ = new qr(x);
        }
        return g.set(l, u), this.size = g.size, this;
      }
      tr.prototype.clear = bS, tr.prototype.delete = wS, tr.prototype.get = xS, tr.prototype.has = yS, tr.prototype.set = CS;
      function o2(l, u) {
        var g = Fe(l), x = !g && lo(l), S = !g && !x && Ri(l), E = !g && !x && !S && is(l), I = g || x || S || E, L = I ? Wf(l.length, D7) : [], F = L.length;
        for (var Z in l)
          (u || st.call(l, Z)) && !(I && // Safari 9 has enumerable `arguments.length` in strict mode.
          (Z == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          S && (Z == "offset" || Z == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          E && (Z == "buffer" || Z == "byteLength" || Z == "byteOffset") || // Skip index properties.
          Xr(Z, F))) && L.push(Z);
        return L;
      }
      function s2(l) {
        var u = l.length;
        return u ? l[od(0, u - 1)] : n;
      }
      function $S(l, u) {
        return bc(pn(l), io(u, 0, l.length));
      }
      function SS(l) {
        return bc(pn(l));
      }
      function jf(l, u, g) {
        (g !== n && !nr(l[u], g) || g === n && !(u in l)) && Gr(l, u, g);
      }
      function da(l, u, g) {
        var x = l[u];
        (!(st.call(l, u) && nr(x, g)) || g === n && !(u in l)) && Gr(l, u, g);
      }
      function oc(l, u) {
        for (var g = l.length; g--; )
          if (nr(l[g][0], u))
            return g;
        return -1;
      }
      function AS(l, u, g, x) {
        return Ai(l, function(S, E, I) {
          u(x, S, g(S), I);
        }), x;
      }
      function a2(l, u) {
        return l && br(u, Ht(u), l);
      }
      function kS(l, u) {
        return l && br(u, vn(u), l);
      }
      function Gr(l, u, g) {
        u == "__proto__" && Jl ? Jl(l, u, {
          configurable: !0,
          enumerable: !0,
          value: g,
          writable: !0
        }) : l[u] = g;
      }
      function Xf(l, u) {
        for (var g = -1, x = u.length, S = U(x), E = l == null; ++g < x; )
          S[g] = E ? n : Ed(l, u[g]);
        return S;
      }
      function io(l, u, g) {
        return l === l && (g !== n && (l = l <= g ? l : g), u !== n && (l = l >= u ? l : u)), l;
      }
      function Un(l, u, g, x, S, E) {
        var I, L = u & d, F = u & p, Z = u & v;
        if (g && (I = S ? g(l, x, S, E) : g(l)), I !== n)
          return I;
        if (!wt(l))
          return l;
        var Q = Fe(l);
        if (Q) {
          if (I = g9(l), !L)
            return pn(l, I);
        } else {
          var ne = Jt(l), he = ne == je || ne == Rt;
          if (Ri(l))
            return O2(l, L);
          if (ne == Ct || ne == He || he && !S) {
            if (I = F || he ? {} : X2(l), !L)
              return F ? r9(l, kS(I, l)) : n9(l, a2(I, l));
          } else {
            if (!dt[ne])
              return S ? l : {};
            I = p9(l, ne, L);
          }
        }
        E || (E = new tr());
        var ye = E.get(l);
        if (ye)
          return ye;
        E.set(l, I), Av(l) ? l.forEach(function(Re) {
          I.add(Un(Re, u, g, Re, l, E));
        }) : $v(l) && l.forEach(function(Re, Ye) {
          I.set(Ye, Un(Re, u, g, Ye, l, E));
        });
        var Te = Z ? F ? md : pd : F ? vn : Ht, We = Q ? n : Te(l);
        return Pn(We || l, function(Re, Ye) {
          We && (Ye = Re, Re = l[Ye]), da(I, Ye, Un(Re, u, g, Ye, l, E));
        }), I;
      }
      function MS(l) {
        var u = Ht(l);
        return function(g) {
          return l2(g, l, u);
        };
      }
      function l2(l, u, g) {
        var x = g.length;
        if (l == null)
          return !x;
        for (l = ct(l); x--; ) {
          var S = g[x], E = u[S], I = l[S];
          if (I === n && !(S in l) || !E(I))
            return !1;
        }
        return !0;
      }
      function c2(l, u, g) {
        if (typeof l != "function")
          throw new Wn(s);
        return xa(function() {
          l.apply(n, g);
        }, u);
      }
      function ga(l, u, g, x) {
        var S = -1, E = Wl, I = !0, L = l.length, F = [], Z = u.length;
        if (!L)
          return F;
        g && (u = vt(u, Tn(g))), x ? (E = Bf, I = !1) : u.length >= i && (E = aa, I = !1, u = new ro(u));
        e:
          for (; ++S < L; ) {
            var Q = l[S], ne = g == null ? Q : g(Q);
            if (Q = x || Q !== 0 ? Q : 0, I && ne === ne) {
              for (var he = Z; he--; )
                if (u[he] === ne)
                  continue e;
              F.push(Q);
            } else E(u, ne, x) || F.push(Q);
          }
        return F;
      }
      var Ai = B2(vr), u2 = B2(Qf, !0);
      function TS(l, u) {
        var g = !0;
        return Ai(l, function(x, S, E) {
          return g = !!u(x, S, E), g;
        }), g;
      }
      function sc(l, u, g) {
        for (var x = -1, S = l.length; ++x < S; ) {
          var E = l[x], I = u(E);
          if (I != null && (L === n ? I === I && !En(I) : g(I, L)))
            var L = I, F = E;
        }
        return F;
      }
      function RS(l, u, g, x) {
        var S = l.length;
        for (g = Pe(g), g < 0 && (g = -g > S ? 0 : S + g), x = x === n || x > S ? S : Pe(x), x < 0 && (x += S), x = g > x ? 0 : Mv(x); g < x; )
          l[g++] = u;
        return l;
      }
      function h2(l, u) {
        var g = [];
        return Ai(l, function(x, S, E) {
          u(x, S, E) && g.push(x);
        }), g;
      }
      function Yt(l, u, g, x, S) {
        var E = -1, I = l.length;
        for (g || (g = v9), S || (S = []); ++E < I; ) {
          var L = l[E];
          u > 0 && g(L) ? u > 1 ? Yt(L, u - 1, g, x, S) : Ci(S, L) : x || (S[S.length] = L);
        }
        return S;
      }
      var Zf = N2(), f2 = N2(!0);
      function vr(l, u) {
        return l && Zf(l, u, Ht);
      }
      function Qf(l, u) {
        return l && f2(l, u, Ht);
      }
      function ac(l, u) {
        return yi(u, function(g) {
          return Zr(l[g]);
        });
      }
      function oo(l, u) {
        u = Mi(u, l);
        for (var g = 0, x = u.length; l != null && g < x; )
          l = l[wr(u[g++])];
        return g && g == x ? l : n;
      }
      function d2(l, u, g) {
        var x = u(l);
        return Fe(l) ? x : Ci(x, g(l));
      }
      function ln(l) {
        return l == null ? l === n ? vf : an : to && to in ct(l) ? h9(l) : S9(l);
      }
      function Jf(l, u) {
        return l > u;
      }
      function ES(l, u) {
        return l != null && st.call(l, u);
      }
      function OS(l, u) {
        return l != null && u in ct(l);
      }
      function DS(l, u, g) {
        return l >= Qt(u, g) && l < Lt(u, g);
      }
      function ed(l, u, g) {
        for (var x = g ? Bf : Wl, S = l[0].length, E = l.length, I = E, L = U(E), F = 1 / 0, Z = []; I--; ) {
          var Q = l[I];
          I && u && (Q = vt(Q, Tn(u))), F = Qt(Q.length, F), L[I] = !g && (u || S >= 120 && Q.length >= 120) ? new ro(I && Q) : n;
        }
        Q = l[0];
        var ne = -1, he = L[0];
        e:
          for (; ++ne < S && Z.length < F; ) {
            var ye = Q[ne], Te = u ? u(ye) : ye;
            if (ye = g || ye !== 0 ? ye : 0, !(he ? aa(he, Te) : x(Z, Te, g))) {
              for (I = E; --I; ) {
                var We = L[I];
                if (!(We ? aa(We, Te) : x(l[I], Te, g)))
                  continue e;
              }
              he && he.push(Te), Z.push(ye);
            }
          }
        return Z;
      }
      function IS(l, u, g, x) {
        return vr(l, function(S, E, I) {
          u(x, g(S), E, I);
        }), x;
      }
      function pa(l, u, g) {
        u = Mi(u, l), l = ev(l, u);
        var x = l == null ? l : l[wr(qn(u))];
        return x == null ? n : Mn(x, l, g);
      }
      function g2(l) {
        return yt(l) && ln(l) == He;
      }
      function _S(l) {
        return yt(l) && ln(l) == Ji;
      }
      function LS(l) {
        return yt(l) && ln(l) == Oe;
      }
      function ma(l, u, g, x, S) {
        return l === u ? !0 : l == null || u == null || !yt(l) && !yt(u) ? l !== l && u !== u : BS(l, u, g, x, ma, S);
      }
      function BS(l, u, g, x, S, E) {
        var I = Fe(l), L = Fe(u), F = I ? Ze : Jt(l), Z = L ? Ze : Jt(u);
        F = F == He ? Ct : F, Z = Z == He ? Ct : Z;
        var Q = F == Ct, ne = Z == Ct, he = F == Z;
        if (he && Ri(l)) {
          if (!Ri(u))
            return !1;
          I = !0, Q = !1;
        }
        if (he && !Q)
          return E || (E = new tr()), I || is(l) ? G2(l, u, g, x, S, E) : c9(l, u, F, g, x, S, E);
        if (!(g & w)) {
          var ye = Q && st.call(l, "__wrapped__"), Te = ne && st.call(u, "__wrapped__");
          if (ye || Te) {
            var We = ye ? l.value() : l, Re = Te ? u.value() : u;
            return E || (E = new tr()), S(We, Re, g, x, E);
          }
        }
        return he ? (E || (E = new tr()), u9(l, u, g, x, S, E)) : !1;
      }
      function NS(l) {
        return yt(l) && Jt(l) == at;
      }
      function td(l, u, g, x) {
        var S = g.length, E = S, I = !x;
        if (l == null)
          return !E;
        for (l = ct(l); S--; ) {
          var L = g[S];
          if (I && L[2] ? L[1] !== l[L[0]] : !(L[0] in l))
            return !1;
        }
        for (; ++S < E; ) {
          L = g[S];
          var F = L[0], Z = l[F], Q = L[1];
          if (I && L[2]) {
            if (Z === n && !(F in l))
              return !1;
          } else {
            var ne = new tr();
            if (x)
              var he = x(Z, Q, F, l, u, ne);
            if (!(he === n ? ma(Q, Z, w | b, x, ne) : he))
              return !1;
          }
        }
        return !0;
      }
      function p2(l) {
        if (!wt(l) || w9(l))
          return !1;
        var u = Zr(l) ? N7 : M8;
        return u.test(ao(l));
      }
      function FS(l) {
        return yt(l) && ln(l) == Pr;
      }
      function VS(l) {
        return yt(l) && Jt(l) == It;
      }
      function HS(l) {
        return yt(l) && Sc(l.length) && !!gt[ln(l)];
      }
      function m2(l) {
        return typeof l == "function" ? l : l == null ? bn : typeof l == "object" ? Fe(l) ? w2(l[0], l[1]) : b2(l) : Fv(l);
      }
      function nd(l) {
        if (!wa(l))
          return z7(l);
        var u = [];
        for (var g in ct(l))
          st.call(l, g) && g != "constructor" && u.push(g);
        return u;
      }
      function PS(l) {
        if (!wt(l))
          return $9(l);
        var u = wa(l), g = [];
        for (var x in l)
          x == "constructor" && (u || !st.call(l, x)) || g.push(x);
        return g;
      }
      function rd(l, u) {
        return l < u;
      }
      function v2(l, u) {
        var g = -1, x = mn(l) ? U(l.length) : [];
        return Ai(l, function(S, E, I) {
          x[++g] = u(S, E, I);
        }), x;
      }
      function b2(l) {
        var u = bd(l);
        return u.length == 1 && u[0][2] ? Q2(u[0][0], u[0][1]) : function(g) {
          return g === l || td(g, l, u);
        };
      }
      function w2(l, u) {
        return xd(l) && Z2(u) ? Q2(wr(l), u) : function(g) {
          var x = Ed(g, l);
          return x === n && x === u ? Od(g, l) : ma(u, x, w | b);
        };
      }
      function lc(l, u, g, x, S) {
        l !== u && Zf(u, function(E, I) {
          if (S || (S = new tr()), wt(E))
            WS(l, u, I, g, lc, x, S);
          else {
            var L = x ? x(Cd(l, I), E, I + "", l, u, S) : n;
            L === n && (L = E), jf(l, I, L);
          }
        }, vn);
      }
      function WS(l, u, g, x, S, E, I) {
        var L = Cd(l, g), F = Cd(u, g), Z = I.get(F);
        if (Z) {
          jf(l, g, Z);
          return;
        }
        var Q = E ? E(L, F, g + "", l, u, I) : n, ne = Q === n;
        if (ne) {
          var he = Fe(F), ye = !he && Ri(F), Te = !he && !ye && is(F);
          Q = F, he || ye || Te ? Fe(L) ? Q = L : $t(L) ? Q = pn(L) : ye ? (ne = !1, Q = O2(F, !0)) : Te ? (ne = !1, Q = D2(F, !0)) : Q = [] : ya(F) || lo(F) ? (Q = L, lo(L) ? Q = Tv(L) : (!wt(L) || Zr(L)) && (Q = X2(F))) : ne = !1;
        }
        ne && (I.set(F, Q), S(Q, F, x, E, I), I.delete(F)), jf(l, g, Q);
      }
      function x2(l, u) {
        var g = l.length;
        if (g)
          return u += u < 0 ? g : 0, Xr(u, g) ? l[u] : n;
      }
      function y2(l, u, g) {
        u.length ? u = vt(u, function(E) {
          return Fe(E) ? function(I) {
            return oo(I, E.length === 1 ? E[0] : E);
          } : E;
        }) : u = [bn];
        var x = -1;
        u = vt(u, Tn(Me()));
        var S = v2(l, function(E, I, L) {
          var F = vt(u, function(Z) {
            return Z(E);
          });
          return { criteria: F, index: ++x, value: E };
        });
        return p7(S, function(E, I) {
          return t9(E, I, g);
        });
      }
      function zS(l, u) {
        return C2(l, u, function(g, x) {
          return Od(l, x);
        });
      }
      function C2(l, u, g) {
        for (var x = -1, S = u.length, E = {}; ++x < S; ) {
          var I = u[x], L = oo(l, I);
          g(L, I) && va(E, Mi(I, l), L);
        }
        return E;
      }
      function US(l) {
        return function(u) {
          return oo(u, l);
        };
      }
      function id(l, u, g, x) {
        var S = x ? g7 : Go, E = -1, I = u.length, L = l;
        for (l === u && (u = pn(u)), g && (L = vt(l, Tn(g))); ++E < I; )
          for (var F = 0, Z = u[E], Q = g ? g(Z) : Z; (F = S(L, Q, F, x)) > -1; )
            L !== l && Ql.call(L, F, 1), Ql.call(l, F, 1);
        return l;
      }
      function $2(l, u) {
        for (var g = l ? u.length : 0, x = g - 1; g--; ) {
          var S = u[g];
          if (g == x || S !== E) {
            var E = S;
            Xr(S) ? Ql.call(l, S, 1) : ld(l, S);
          }
        }
        return l;
      }
      function od(l, u) {
        return l + tc(r2() * (u - l + 1));
      }
      function KS(l, u, g, x) {
        for (var S = -1, E = Lt(ec((u - l) / (g || 1)), 0), I = U(E); E--; )
          I[x ? E : ++S] = l, l += g;
        return I;
      }
      function sd(l, u) {
        var g = "";
        if (!l || u < 1 || u > se)
          return g;
        do
          u % 2 && (g += l), u = tc(u / 2), u && (l += l);
        while (u);
        return g;
      }
      function Ke(l, u) {
        return $d(J2(l, u, bn), l + "");
      }
      function qS(l) {
        return s2(os(l));
      }
      function GS(l, u) {
        var g = os(l);
        return bc(g, io(u, 0, g.length));
      }
      function va(l, u, g, x) {
        if (!wt(l))
          return l;
        u = Mi(u, l);
        for (var S = -1, E = u.length, I = E - 1, L = l; L != null && ++S < E; ) {
          var F = wr(u[S]), Z = g;
          if (F === "__proto__" || F === "constructor" || F === "prototype")
            return l;
          if (S != I) {
            var Q = L[F];
            Z = x ? x(Q, F, L) : n, Z === n && (Z = wt(Q) ? Q : Xr(u[S + 1]) ? [] : {});
          }
          da(L, F, Z), L = L[F];
        }
        return l;
      }
      var S2 = nc ? function(l, u) {
        return nc.set(l, u), l;
      } : bn, YS = Jl ? function(l, u) {
        return Jl(l, "toString", {
          configurable: !0,
          enumerable: !1,
          value: Id(u),
          writable: !0
        });
      } : bn;
      function jS(l) {
        return bc(os(l));
      }
      function Kn(l, u, g) {
        var x = -1, S = l.length;
        u < 0 && (u = -u > S ? 0 : S + u), g = g > S ? S : g, g < 0 && (g += S), S = u > g ? 0 : g - u >>> 0, u >>>= 0;
        for (var E = U(S); ++x < S; )
          E[x] = l[x + u];
        return E;
      }
      function XS(l, u) {
        var g;
        return Ai(l, function(x, S, E) {
          return g = u(x, S, E), !g;
        }), !!g;
      }
      function cc(l, u, g) {
        var x = 0, S = l == null ? x : l.length;
        if (typeof u == "number" && u === u && S <= Ae) {
          for (; x < S; ) {
            var E = x + S >>> 1, I = l[E];
            I !== null && !En(I) && (g ? I <= u : I < u) ? x = E + 1 : S = E;
          }
          return S;
        }
        return ad(l, u, bn, g);
      }
      function ad(l, u, g, x) {
        var S = 0, E = l == null ? 0 : l.length;
        if (E === 0)
          return 0;
        u = g(u);
        for (var I = u !== u, L = u === null, F = En(u), Z = u === n; S < E; ) {
          var Q = tc((S + E) / 2), ne = g(l[Q]), he = ne !== n, ye = ne === null, Te = ne === ne, We = En(ne);
          if (I)
            var Re = x || Te;
          else Z ? Re = Te && (x || he) : L ? Re = Te && he && (x || !ye) : F ? Re = Te && he && !ye && (x || !We) : ye || We ? Re = !1 : Re = x ? ne <= u : ne < u;
          Re ? S = Q + 1 : E = Q;
        }
        return Qt(E, Le);
      }
      function A2(l, u) {
        for (var g = -1, x = l.length, S = 0, E = []; ++g < x; ) {
          var I = l[g], L = u ? u(I) : I;
          if (!g || !nr(L, F)) {
            var F = L;
            E[S++] = I === 0 ? 0 : I;
          }
        }
        return E;
      }
      function k2(l) {
        return typeof l == "number" ? l : En(l) ? ce : +l;
      }
      function Rn(l) {
        if (typeof l == "string")
          return l;
        if (Fe(l))
          return vt(l, Rn) + "";
        if (En(l))
          return i2 ? i2.call(l) : "";
        var u = l + "";
        return u == "0" && 1 / l == -1 / 0 ? "-0" : u;
      }
      function ki(l, u, g) {
        var x = -1, S = Wl, E = l.length, I = !0, L = [], F = L;
        if (g)
          I = !1, S = Bf;
        else if (E >= i) {
          var Z = u ? null : a9(l);
          if (Z)
            return Ul(Z);
          I = !1, S = aa, F = new ro();
        } else
          F = u ? [] : L;
        e:
          for (; ++x < E; ) {
            var Q = l[x], ne = u ? u(Q) : Q;
            if (Q = g || Q !== 0 ? Q : 0, I && ne === ne) {
              for (var he = F.length; he--; )
                if (F[he] === ne)
                  continue e;
              u && F.push(ne), L.push(Q);
            } else S(F, ne, g) || (F !== L && F.push(ne), L.push(Q));
          }
        return L;
      }
      function ld(l, u) {
        return u = Mi(u, l), l = ev(l, u), l == null || delete l[wr(qn(u))];
      }
      function M2(l, u, g, x) {
        return va(l, u, g(oo(l, u)), x);
      }
      function uc(l, u, g, x) {
        for (var S = l.length, E = x ? S : -1; (x ? E-- : ++E < S) && u(l[E], E, l); )
          ;
        return g ? Kn(l, x ? 0 : E, x ? E + 1 : S) : Kn(l, x ? E + 1 : 0, x ? S : E);
      }
      function T2(l, u) {
        var g = l;
        return g instanceof Xe && (g = g.value()), Nf(u, function(x, S) {
          return S.func.apply(S.thisArg, Ci([x], S.args));
        }, g);
      }
      function cd(l, u, g) {
        var x = l.length;
        if (x < 2)
          return x ? ki(l[0]) : [];
        for (var S = -1, E = U(x); ++S < x; )
          for (var I = l[S], L = -1; ++L < x; )
            L != S && (E[S] = ga(E[S] || I, l[L], u, g));
        return ki(Yt(E, 1), u, g);
      }
      function R2(l, u, g) {
        for (var x = -1, S = l.length, E = u.length, I = {}; ++x < S; ) {
          var L = x < E ? u[x] : n;
          g(I, l[x], L);
        }
        return I;
      }
      function ud(l) {
        return $t(l) ? l : [];
      }
      function hd(l) {
        return typeof l == "function" ? l : bn;
      }
      function Mi(l, u) {
        return Fe(l) ? l : xd(l, u) ? [l] : iv(ot(l));
      }
      var ZS = Ke;
      function Ti(l, u, g) {
        var x = l.length;
        return g = g === n ? x : g, !u && g >= x ? l : Kn(l, u, g);
      }
      var E2 = F7 || function(l) {
        return Gt.clearTimeout(l);
      };
      function O2(l, u) {
        if (u)
          return l.slice();
        var g = l.length, x = Qm ? Qm(g) : new l.constructor(g);
        return l.copy(x), x;
      }
      function fd(l) {
        var u = new l.constructor(l.byteLength);
        return new Xl(u).set(new Xl(l)), u;
      }
      function QS(l, u) {
        var g = u ? fd(l.buffer) : l.buffer;
        return new l.constructor(g, l.byteOffset, l.byteLength);
      }
      function JS(l) {
        var u = new l.constructor(l.source, gm.exec(l));
        return u.lastIndex = l.lastIndex, u;
      }
      function e9(l) {
        return fa ? ct(fa.call(l)) : {};
      }
      function D2(l, u) {
        var g = u ? fd(l.buffer) : l.buffer;
        return new l.constructor(g, l.byteOffset, l.length);
      }
      function I2(l, u) {
        if (l !== u) {
          var g = l !== n, x = l === null, S = l === l, E = En(l), I = u !== n, L = u === null, F = u === u, Z = En(u);
          if (!L && !Z && !E && l > u || E && I && F && !L && !Z || x && I && F || !g && F || !S)
            return 1;
          if (!x && !E && !Z && l < u || Z && g && S && !x && !E || L && g && S || !I && S || !F)
            return -1;
        }
        return 0;
      }
      function t9(l, u, g) {
        for (var x = -1, S = l.criteria, E = u.criteria, I = S.length, L = g.length; ++x < I; ) {
          var F = I2(S[x], E[x]);
          if (F) {
            if (x >= L)
              return F;
            var Z = g[x];
            return F * (Z == "desc" ? -1 : 1);
          }
        }
        return l.index - u.index;
      }
      function _2(l, u, g, x) {
        for (var S = -1, E = l.length, I = g.length, L = -1, F = u.length, Z = Lt(E - I, 0), Q = U(F + Z), ne = !x; ++L < F; )
          Q[L] = u[L];
        for (; ++S < I; )
          (ne || S < E) && (Q[g[S]] = l[S]);
        for (; Z--; )
          Q[L++] = l[S++];
        return Q;
      }
      function L2(l, u, g, x) {
        for (var S = -1, E = l.length, I = -1, L = g.length, F = -1, Z = u.length, Q = Lt(E - L, 0), ne = U(Q + Z), he = !x; ++S < Q; )
          ne[S] = l[S];
        for (var ye = S; ++F < Z; )
          ne[ye + F] = u[F];
        for (; ++I < L; )
          (he || S < E) && (ne[ye + g[I]] = l[S++]);
        return ne;
      }
      function pn(l, u) {
        var g = -1, x = l.length;
        for (u || (u = U(x)); ++g < x; )
          u[g] = l[g];
        return u;
      }
      function br(l, u, g, x) {
        var S = !g;
        g || (g = {});
        for (var E = -1, I = u.length; ++E < I; ) {
          var L = u[E], F = x ? x(g[L], l[L], L, g, l) : n;
          F === n && (F = l[L]), S ? Gr(g, L, F) : da(g, L, F);
        }
        return g;
      }
      function n9(l, u) {
        return br(l, wd(l), u);
      }
      function r9(l, u) {
        return br(l, Y2(l), u);
      }
      function hc(l, u) {
        return function(g, x) {
          var S = Fe(g) ? l7 : AS, E = u ? u() : {};
          return S(g, l, Me(x, 2), E);
        };
      }
      function ts(l) {
        return Ke(function(u, g) {
          var x = -1, S = g.length, E = S > 1 ? g[S - 1] : n, I = S > 2 ? g[2] : n;
          for (E = l.length > 3 && typeof E == "function" ? (S--, E) : n, I && cn(g[0], g[1], I) && (E = S < 3 ? n : E, S = 1), u = ct(u); ++x < S; ) {
            var L = g[x];
            L && l(u, L, x, E);
          }
          return u;
        });
      }
      function B2(l, u) {
        return function(g, x) {
          if (g == null)
            return g;
          if (!mn(g))
            return l(g, x);
          for (var S = g.length, E = u ? S : -1, I = ct(g); (u ? E-- : ++E < S) && x(I[E], E, I) !== !1; )
            ;
          return g;
        };
      }
      function N2(l) {
        return function(u, g, x) {
          for (var S = -1, E = ct(u), I = x(u), L = I.length; L--; ) {
            var F = I[l ? L : ++S];
            if (g(E[F], F, E) === !1)
              break;
          }
          return u;
        };
      }
      function i9(l, u, g) {
        var x = u & y, S = ba(l);
        function E() {
          var I = this && this !== Gt && this instanceof E ? S : l;
          return I.apply(x ? g : this, arguments);
        }
        return E;
      }
      function F2(l) {
        return function(u) {
          u = ot(u);
          var g = Yo(u) ? er(u) : n, x = g ? g[0] : u.charAt(0), S = g ? Ti(g, 1).join("") : u.slice(1);
          return x[l]() + S;
        };
      }
      function ns(l) {
        return function(u) {
          return Nf(Bv(Lv(u).replace(Y8, "")), l, "");
        };
      }
      function ba(l) {
        return function() {
          var u = arguments;
          switch (u.length) {
            case 0:
              return new l();
            case 1:
              return new l(u[0]);
            case 2:
              return new l(u[0], u[1]);
            case 3:
              return new l(u[0], u[1], u[2]);
            case 4:
              return new l(u[0], u[1], u[2], u[3]);
            case 5:
              return new l(u[0], u[1], u[2], u[3], u[4]);
            case 6:
              return new l(u[0], u[1], u[2], u[3], u[4], u[5]);
            case 7:
              return new l(u[0], u[1], u[2], u[3], u[4], u[5], u[6]);
          }
          var g = es(l.prototype), x = l.apply(g, u);
          return wt(x) ? x : g;
        };
      }
      function o9(l, u, g) {
        var x = ba(l);
        function S() {
          for (var E = arguments.length, I = U(E), L = E, F = rs(S); L--; )
            I[L] = arguments[L];
          var Z = E < 3 && I[0] !== F && I[E - 1] !== F ? [] : $i(I, F);
          if (E -= Z.length, E < g)
            return z2(
              l,
              u,
              fc,
              S.placeholder,
              n,
              I,
              Z,
              n,
              n,
              g - E
            );
          var Q = this && this !== Gt && this instanceof S ? x : l;
          return Mn(Q, this, I);
        }
        return S;
      }
      function V2(l) {
        return function(u, g, x) {
          var S = ct(u);
          if (!mn(u)) {
            var E = Me(g, 3);
            u = Ht(u), g = function(L) {
              return E(S[L], L, S);
            };
          }
          var I = l(u, g, x);
          return I > -1 ? S[E ? u[I] : I] : n;
        };
      }
      function H2(l) {
        return jr(function(u) {
          var g = u.length, x = g, S = zn.prototype.thru;
          for (l && u.reverse(); x--; ) {
            var E = u[x];
            if (typeof E != "function")
              throw new Wn(s);
            if (S && !I && mc(E) == "wrapper")
              var I = new zn([], !0);
          }
          for (x = I ? x : g; ++x < g; ) {
            E = u[x];
            var L = mc(E), F = L == "wrapper" ? vd(E) : n;
            F && yd(F[0]) && F[1] == (D | k | R | P) && !F[4].length && F[9] == 1 ? I = I[mc(F[0])].apply(I, F[3]) : I = E.length == 1 && yd(E) ? I[L]() : I.thru(E);
          }
          return function() {
            var Z = arguments, Q = Z[0];
            if (I && Z.length == 1 && Fe(Q))
              return I.plant(Q).value();
            for (var ne = 0, he = g ? u[ne].apply(this, Z) : Q; ++ne < g; )
              he = u[ne].call(this, he);
            return he;
          };
        });
      }
      function fc(l, u, g, x, S, E, I, L, F, Z) {
        var Q = u & D, ne = u & y, he = u & $, ye = u & (k | T), Te = u & H, We = he ? n : ba(l);
        function Re() {
          for (var Ye = arguments.length, Je = U(Ye), On = Ye; On--; )
            Je[On] = arguments[On];
          if (ye)
            var un = rs(Re), Dn = v7(Je, un);
          if (x && (Je = _2(Je, x, S, ye)), E && (Je = L2(Je, E, I, ye)), Ye -= Dn, ye && Ye < Z) {
            var St = $i(Je, un);
            return z2(
              l,
              u,
              fc,
              Re.placeholder,
              g,
              Je,
              St,
              L,
              F,
              Z - Ye
            );
          }
          var rr = ne ? g : this, Jr = he ? rr[l] : l;
          return Ye = Je.length, L ? Je = A9(Je, L) : Te && Ye > 1 && Je.reverse(), Q && F < Ye && (Je.length = F), this && this !== Gt && this instanceof Re && (Jr = We || ba(Jr)), Jr.apply(rr, Je);
        }
        return Re;
      }
      function P2(l, u) {
        return function(g, x) {
          return IS(g, l, u(x), {});
        };
      }
      function dc(l, u) {
        return function(g, x) {
          var S;
          if (g === n && x === n)
            return u;
          if (g !== n && (S = g), x !== n) {
            if (S === n)
              return x;
            typeof g == "string" || typeof x == "string" ? (g = Rn(g), x = Rn(x)) : (g = k2(g), x = k2(x)), S = l(g, x);
          }
          return S;
        };
      }
      function dd(l) {
        return jr(function(u) {
          return u = vt(u, Tn(Me())), Ke(function(g) {
            var x = this;
            return l(u, function(S) {
              return Mn(S, x, g);
            });
          });
        });
      }
      function gc(l, u) {
        u = u === n ? " " : Rn(u);
        var g = u.length;
        if (g < 2)
          return g ? sd(u, l) : u;
        var x = sd(u, ec(l / jo(u)));
        return Yo(u) ? Ti(er(x), 0, l).join("") : x.slice(0, l);
      }
      function s9(l, u, g, x) {
        var S = u & y, E = ba(l);
        function I() {
          for (var L = -1, F = arguments.length, Z = -1, Q = x.length, ne = U(Q + F), he = this && this !== Gt && this instanceof I ? E : l; ++Z < Q; )
            ne[Z] = x[Z];
          for (; F--; )
            ne[Z++] = arguments[++L];
          return Mn(he, S ? g : this, ne);
        }
        return I;
      }
      function W2(l) {
        return function(u, g, x) {
          return x && typeof x != "number" && cn(u, g, x) && (g = x = n), u = Qr(u), g === n ? (g = u, u = 0) : g = Qr(g), x = x === n ? u < g ? 1 : -1 : Qr(x), KS(u, g, x, l);
        };
      }
      function pc(l) {
        return function(u, g) {
          return typeof u == "string" && typeof g == "string" || (u = Gn(u), g = Gn(g)), l(u, g);
        };
      }
      function z2(l, u, g, x, S, E, I, L, F, Z) {
        var Q = u & k, ne = Q ? I : n, he = Q ? n : I, ye = Q ? E : n, Te = Q ? n : E;
        u |= Q ? R : _, u &= ~(Q ? _ : R), u & A || (u &= -4);
        var We = [
          l,
          u,
          S,
          ye,
          ne,
          Te,
          he,
          L,
          F,
          Z
        ], Re = g.apply(n, We);
        return yd(l) && tv(Re, We), Re.placeholder = x, nv(Re, l, u);
      }
      function gd(l) {
        var u = _t[l];
        return function(g, x) {
          if (g = Gn(g), x = x == null ? 0 : Qt(Pe(x), 292), x && n2(g)) {
            var S = (ot(g) + "e").split("e"), E = u(S[0] + "e" + (+S[1] + x));
            return S = (ot(E) + "e").split("e"), +(S[0] + "e" + (+S[1] - x));
          }
          return u(g);
        };
      }
      var a9 = Qo && 1 / Ul(new Qo([, -0]))[1] == ie ? function(l) {
        return new Qo(l);
      } : Bd;
      function U2(l) {
        return function(u) {
          var g = Jt(u);
          return g == at ? Uf(u) : g == It ? S7(u) : m7(u, l(u));
        };
      }
      function Yr(l, u, g, x, S, E, I, L) {
        var F = u & $;
        if (!F && typeof l != "function")
          throw new Wn(s);
        var Z = x ? x.length : 0;
        if (Z || (u &= -97, x = S = n), I = I === n ? I : Lt(Pe(I), 0), L = L === n ? L : Pe(L), Z -= S ? S.length : 0, u & _) {
          var Q = x, ne = S;
          x = S = n;
        }
        var he = F ? n : vd(l), ye = [
          l,
          u,
          g,
          x,
          S,
          Q,
          ne,
          E,
          I,
          L
        ];
        if (he && C9(ye, he), l = ye[0], u = ye[1], g = ye[2], x = ye[3], S = ye[4], L = ye[9] = ye[9] === n ? F ? 0 : l.length : Lt(ye[9] - Z, 0), !L && u & (k | T) && (u &= -25), !u || u == y)
          var Te = i9(l, u, g);
        else u == k || u == T ? Te = o9(l, u, L) : (u == R || u == (y | R)) && !S.length ? Te = s9(l, u, g, x) : Te = fc.apply(n, ye);
        var We = he ? S2 : tv;
        return nv(We(Te, ye), l, u);
      }
      function K2(l, u, g, x) {
        return l === n || nr(l, Zo[g]) && !st.call(x, g) ? u : l;
      }
      function q2(l, u, g, x, S, E) {
        return wt(l) && wt(u) && (E.set(u, l), lc(l, u, n, q2, E), E.delete(u)), l;
      }
      function l9(l) {
        return ya(l) ? n : l;
      }
      function G2(l, u, g, x, S, E) {
        var I = g & w, L = l.length, F = u.length;
        if (L != F && !(I && F > L))
          return !1;
        var Z = E.get(l), Q = E.get(u);
        if (Z && Q)
          return Z == u && Q == l;
        var ne = -1, he = !0, ye = g & b ? new ro() : n;
        for (E.set(l, u), E.set(u, l); ++ne < L; ) {
          var Te = l[ne], We = u[ne];
          if (x)
            var Re = I ? x(We, Te, ne, u, l, E) : x(Te, We, ne, l, u, E);
          if (Re !== n) {
            if (Re)
              continue;
            he = !1;
            break;
          }
          if (ye) {
            if (!Ff(u, function(Ye, Je) {
              if (!aa(ye, Je) && (Te === Ye || S(Te, Ye, g, x, E)))
                return ye.push(Je);
            })) {
              he = !1;
              break;
            }
          } else if (!(Te === We || S(Te, We, g, x, E))) {
            he = !1;
            break;
          }
        }
        return E.delete(l), E.delete(u), he;
      }
      function c9(l, u, g, x, S, E, I) {
        switch (g) {
          case mr:
            if (l.byteLength != u.byteLength || l.byteOffset != u.byteOffset)
              return !1;
            l = l.buffer, u = u.buffer;
          case Ji:
            return !(l.byteLength != u.byteLength || !E(new Xl(l), new Xl(u)));
          case Ve:
          case Oe:
          case Qe:
            return nr(+l, +u);
          case Ee:
            return l.name == u.name && l.message == u.message;
          case Pr:
          case Wr:
            return l == u + "";
          case at:
            var L = Uf;
          case It:
            var F = x & w;
            if (L || (L = Ul), l.size != u.size && !F)
              return !1;
            var Z = I.get(l);
            if (Z)
              return Z == u;
            x |= b, I.set(l, u);
            var Q = G2(L(l), L(u), x, S, E, I);
            return I.delete(l), Q;
          case zr:
            if (fa)
              return fa.call(l) == fa.call(u);
        }
        return !1;
      }
      function u9(l, u, g, x, S, E) {
        var I = g & w, L = pd(l), F = L.length, Z = pd(u), Q = Z.length;
        if (F != Q && !I)
          return !1;
        for (var ne = F; ne--; ) {
          var he = L[ne];
          if (!(I ? he in u : st.call(u, he)))
            return !1;
        }
        var ye = E.get(l), Te = E.get(u);
        if (ye && Te)
          return ye == u && Te == l;
        var We = !0;
        E.set(l, u), E.set(u, l);
        for (var Re = I; ++ne < F; ) {
          he = L[ne];
          var Ye = l[he], Je = u[he];
          if (x)
            var On = I ? x(Je, Ye, he, u, l, E) : x(Ye, Je, he, l, u, E);
          if (!(On === n ? Ye === Je || S(Ye, Je, g, x, E) : On)) {
            We = !1;
            break;
          }
          Re || (Re = he == "constructor");
        }
        if (We && !Re) {
          var un = l.constructor, Dn = u.constructor;
          un != Dn && "constructor" in l && "constructor" in u && !(typeof un == "function" && un instanceof un && typeof Dn == "function" && Dn instanceof Dn) && (We = !1);
        }
        return E.delete(l), E.delete(u), We;
      }
      function jr(l) {
        return $d(J2(l, n, lv), l + "");
      }
      function pd(l) {
        return d2(l, Ht, wd);
      }
      function md(l) {
        return d2(l, vn, Y2);
      }
      var vd = nc ? function(l) {
        return nc.get(l);
      } : Bd;
      function mc(l) {
        for (var u = l.name + "", g = Jo[u], x = st.call(Jo, u) ? g.length : 0; x--; ) {
          var S = g[x], E = S.func;
          if (E == null || E == l)
            return S.name;
        }
        return u;
      }
      function rs(l) {
        var u = st.call(M, "placeholder") ? M : l;
        return u.placeholder;
      }
      function Me() {
        var l = M.iteratee || _d;
        return l = l === _d ? m2 : l, arguments.length ? l(arguments[0], arguments[1]) : l;
      }
      function vc(l, u) {
        var g = l.__data__;
        return b9(u) ? g[typeof u == "string" ? "string" : "hash"] : g.map;
      }
      function bd(l) {
        for (var u = Ht(l), g = u.length; g--; ) {
          var x = u[g], S = l[x];
          u[g] = [x, S, Z2(S)];
        }
        return u;
      }
      function so(l, u) {
        var g = y7(l, u);
        return p2(g) ? g : n;
      }
      function h9(l) {
        var u = st.call(l, to), g = l[to];
        try {
          l[to] = n;
          var x = !0;
        } catch {
        }
        var S = Yl.call(l);
        return x && (u ? l[to] = g : delete l[to]), S;
      }
      var wd = qf ? function(l) {
        return l == null ? [] : (l = ct(l), yi(qf(l), function(u) {
          return e2.call(l, u);
        }));
      } : Nd, Y2 = qf ? function(l) {
        for (var u = []; l; )
          Ci(u, wd(l)), l = Zl(l);
        return u;
      } : Nd, Jt = ln;
      (Gf && Jt(new Gf(new ArrayBuffer(1))) != mr || ca && Jt(new ca()) != at || Yf && Jt(Yf.resolve()) != Uo || Qo && Jt(new Qo()) != It || ua && Jt(new ua()) != Ur) && (Jt = function(l) {
        var u = ln(l), g = u == Ct ? l.constructor : n, x = g ? ao(g) : "";
        if (x)
          switch (x) {
            case G7:
              return mr;
            case Y7:
              return at;
            case j7:
              return Uo;
            case X7:
              return It;
            case Z7:
              return Ur;
          }
        return u;
      });
      function f9(l, u, g) {
        for (var x = -1, S = g.length; ++x < S; ) {
          var E = g[x], I = E.size;
          switch (E.type) {
            case "drop":
              l += I;
              break;
            case "dropRight":
              u -= I;
              break;
            case "take":
              u = Qt(u, l + I);
              break;
            case "takeRight":
              l = Lt(l, u - I);
              break;
          }
        }
        return { start: l, end: u };
      }
      function d9(l) {
        var u = l.match(w8);
        return u ? u[1].split(x8) : [];
      }
      function j2(l, u, g) {
        u = Mi(u, l);
        for (var x = -1, S = u.length, E = !1; ++x < S; ) {
          var I = wr(u[x]);
          if (!(E = l != null && g(l, I)))
            break;
          l = l[I];
        }
        return E || ++x != S ? E : (S = l == null ? 0 : l.length, !!S && Sc(S) && Xr(I, S) && (Fe(l) || lo(l)));
      }
      function g9(l) {
        var u = l.length, g = new l.constructor(u);
        return u && typeof l[0] == "string" && st.call(l, "index") && (g.index = l.index, g.input = l.input), g;
      }
      function X2(l) {
        return typeof l.constructor == "function" && !wa(l) ? es(Zl(l)) : {};
      }
      function p9(l, u, g) {
        var x = l.constructor;
        switch (u) {
          case Ji:
            return fd(l);
          case Ve:
          case Oe:
            return new x(+l);
          case mr:
            return QS(l, g);
          case qt:
          case wf:
          case xf:
          case yf:
          case Cf:
          case $f:
          case Sf:
          case Af:
          case kf:
            return D2(l, g);
          case at:
            return new x();
          case Qe:
          case Wr:
            return new x(l);
          case Pr:
            return JS(l);
          case It:
            return new x();
          case zr:
            return e9(l);
        }
      }
      function m9(l, u) {
        var g = u.length;
        if (!g)
          return l;
        var x = g - 1;
        return u[x] = (g > 1 ? "& " : "") + u[x], u = u.join(g > 2 ? ", " : " "), l.replace(b8, `{
/* [wrapped with ` + u + `] */
`);
      }
      function v9(l) {
        return Fe(l) || lo(l) || !!(t2 && l && l[t2]);
      }
      function Xr(l, u) {
        var g = typeof l;
        return u = u ?? se, !!u && (g == "number" || g != "symbol" && R8.test(l)) && l > -1 && l % 1 == 0 && l < u;
      }
      function cn(l, u, g) {
        if (!wt(g))
          return !1;
        var x = typeof u;
        return (x == "number" ? mn(g) && Xr(u, g.length) : x == "string" && u in g) ? nr(g[u], l) : !1;
      }
      function xd(l, u) {
        if (Fe(l))
          return !1;
        var g = typeof l;
        return g == "number" || g == "symbol" || g == "boolean" || l == null || En(l) ? !0 : g8.test(l) || !d8.test(l) || u != null && l in ct(u);
      }
      function b9(l) {
        var u = typeof l;
        return u == "string" || u == "number" || u == "symbol" || u == "boolean" ? l !== "__proto__" : l === null;
      }
      function yd(l) {
        var u = mc(l), g = M[u];
        if (typeof g != "function" || !(u in Xe.prototype))
          return !1;
        if (l === g)
          return !0;
        var x = vd(g);
        return !!x && l === x[0];
      }
      function w9(l) {
        return !!Zm && Zm in l;
      }
      var x9 = ql ? Zr : Fd;
      function wa(l) {
        var u = l && l.constructor, g = typeof u == "function" && u.prototype || Zo;
        return l === g;
      }
      function Z2(l) {
        return l === l && !wt(l);
      }
      function Q2(l, u) {
        return function(g) {
          return g == null ? !1 : g[l] === u && (u !== n || l in ct(g));
        };
      }
      function y9(l) {
        var u = Cc(l, function(x) {
          return g.size === h && g.clear(), x;
        }), g = u.cache;
        return u;
      }
      function C9(l, u) {
        var g = l[1], x = u[1], S = g | x, E = S < (y | $ | D), I = x == D && g == k || x == D && g == P && l[7].length <= u[8] || x == (D | P) && u[7].length <= u[8] && g == k;
        if (!(E || I))
          return l;
        x & y && (l[2] = u[2], S |= g & y ? 0 : A);
        var L = u[3];
        if (L) {
          var F = l[3];
          l[3] = F ? _2(F, L, u[4]) : L, l[4] = F ? $i(l[3], f) : u[4];
        }
        return L = u[5], L && (F = l[5], l[5] = F ? L2(F, L, u[6]) : L, l[6] = F ? $i(l[5], f) : u[6]), L = u[7], L && (l[7] = L), x & D && (l[8] = l[8] == null ? u[8] : Qt(l[8], u[8])), l[9] == null && (l[9] = u[9]), l[0] = u[0], l[1] = S, l;
      }
      function $9(l) {
        var u = [];
        if (l != null)
          for (var g in ct(l))
            u.push(g);
        return u;
      }
      function S9(l) {
        return Yl.call(l);
      }
      function J2(l, u, g) {
        return u = Lt(u === n ? l.length - 1 : u, 0), function() {
          for (var x = arguments, S = -1, E = Lt(x.length - u, 0), I = U(E); ++S < E; )
            I[S] = x[u + S];
          S = -1;
          for (var L = U(u + 1); ++S < u; )
            L[S] = x[S];
          return L[u] = g(I), Mn(l, this, L);
        };
      }
      function ev(l, u) {
        return u.length < 2 ? l : oo(l, Kn(u, 0, -1));
      }
      function A9(l, u) {
        for (var g = l.length, x = Qt(u.length, g), S = pn(l); x--; ) {
          var E = u[x];
          l[x] = Xr(E, g) ? S[E] : n;
        }
        return l;
      }
      function Cd(l, u) {
        if (!(u === "constructor" && typeof l[u] == "function") && u != "__proto__")
          return l[u];
      }
      var tv = rv(S2), xa = H7 || function(l, u) {
        return Gt.setTimeout(l, u);
      }, $d = rv(YS);
      function nv(l, u, g) {
        var x = u + "";
        return $d(l, m9(x, k9(d9(x), g)));
      }
      function rv(l) {
        var u = 0, g = 0;
        return function() {
          var x = U7(), S = te - (x - g);
          if (g = x, S > 0) {
            if (++u >= K)
              return arguments[0];
          } else
            u = 0;
          return l.apply(n, arguments);
        };
      }
      function bc(l, u) {
        var g = -1, x = l.length, S = x - 1;
        for (u = u === n ? x : u; ++g < u; ) {
          var E = od(g, S), I = l[E];
          l[E] = l[g], l[g] = I;
        }
        return l.length = u, l;
      }
      var iv = y9(function(l) {
        var u = [];
        return l.charCodeAt(0) === 46 && u.push(""), l.replace(p8, function(g, x, S, E) {
          u.push(S ? E.replace($8, "$1") : x || g);
        }), u;
      });
      function wr(l) {
        if (typeof l == "string" || En(l))
          return l;
        var u = l + "";
        return u == "0" && 1 / l == -1 / 0 ? "-0" : u;
      }
      function ao(l) {
        if (l != null) {
          try {
            return Gl.call(l);
          } catch {
          }
          try {
            return l + "";
          } catch {
          }
        }
        return "";
      }
      function k9(l, u) {
        return Pn(qe, function(g) {
          var x = "_." + g[0];
          u & g[1] && !Wl(l, x) && l.push(x);
        }), l.sort();
      }
      function ov(l) {
        if (l instanceof Xe)
          return l.clone();
        var u = new zn(l.__wrapped__, l.__chain__);
        return u.__actions__ = pn(l.__actions__), u.__index__ = l.__index__, u.__values__ = l.__values__, u;
      }
      function M9(l, u, g) {
        (g ? cn(l, u, g) : u === n) ? u = 1 : u = Lt(Pe(u), 0);
        var x = l == null ? 0 : l.length;
        if (!x || u < 1)
          return [];
        for (var S = 0, E = 0, I = U(ec(x / u)); S < x; )
          I[E++] = Kn(l, S, S += u);
        return I;
      }
      function T9(l) {
        for (var u = -1, g = l == null ? 0 : l.length, x = 0, S = []; ++u < g; ) {
          var E = l[u];
          E && (S[x++] = E);
        }
        return S;
      }
      function R9() {
        var l = arguments.length;
        if (!l)
          return [];
        for (var u = U(l - 1), g = arguments[0], x = l; x--; )
          u[x - 1] = arguments[x];
        return Ci(Fe(g) ? pn(g) : [g], Yt(u, 1));
      }
      var E9 = Ke(function(l, u) {
        return $t(l) ? ga(l, Yt(u, 1, $t, !0)) : [];
      }), O9 = Ke(function(l, u) {
        var g = qn(u);
        return $t(g) && (g = n), $t(l) ? ga(l, Yt(u, 1, $t, !0), Me(g, 2)) : [];
      }), D9 = Ke(function(l, u) {
        var g = qn(u);
        return $t(g) && (g = n), $t(l) ? ga(l, Yt(u, 1, $t, !0), n, g) : [];
      });
      function I9(l, u, g) {
        var x = l == null ? 0 : l.length;
        return x ? (u = g || u === n ? 1 : Pe(u), Kn(l, u < 0 ? 0 : u, x)) : [];
      }
      function _9(l, u, g) {
        var x = l == null ? 0 : l.length;
        return x ? (u = g || u === n ? 1 : Pe(u), u = x - u, Kn(l, 0, u < 0 ? 0 : u)) : [];
      }
      function L9(l, u) {
        return l && l.length ? uc(l, Me(u, 3), !0, !0) : [];
      }
      function B9(l, u) {
        return l && l.length ? uc(l, Me(u, 3), !0) : [];
      }
      function N9(l, u, g, x) {
        var S = l == null ? 0 : l.length;
        return S ? (g && typeof g != "number" && cn(l, u, g) && (g = 0, x = S), RS(l, u, g, x)) : [];
      }
      function sv(l, u, g) {
        var x = l == null ? 0 : l.length;
        if (!x)
          return -1;
        var S = g == null ? 0 : Pe(g);
        return S < 0 && (S = Lt(x + S, 0)), zl(l, Me(u, 3), S);
      }
      function av(l, u, g) {
        var x = l == null ? 0 : l.length;
        if (!x)
          return -1;
        var S = x - 1;
        return g !== n && (S = Pe(g), S = g < 0 ? Lt(x + S, 0) : Qt(S, x - 1)), zl(l, Me(u, 3), S, !0);
      }
      function lv(l) {
        var u = l == null ? 0 : l.length;
        return u ? Yt(l, 1) : [];
      }
      function F9(l) {
        var u = l == null ? 0 : l.length;
        return u ? Yt(l, ie) : [];
      }
      function V9(l, u) {
        var g = l == null ? 0 : l.length;
        return g ? (u = u === n ? 1 : Pe(u), Yt(l, u)) : [];
      }
      function H9(l) {
        for (var u = -1, g = l == null ? 0 : l.length, x = {}; ++u < g; ) {
          var S = l[u];
          x[S[0]] = S[1];
        }
        return x;
      }
      function cv(l) {
        return l && l.length ? l[0] : n;
      }
      function P9(l, u, g) {
        var x = l == null ? 0 : l.length;
        if (!x)
          return -1;
        var S = g == null ? 0 : Pe(g);
        return S < 0 && (S = Lt(x + S, 0)), Go(l, u, S);
      }
      function W9(l) {
        var u = l == null ? 0 : l.length;
        return u ? Kn(l, 0, -1) : [];
      }
      var z9 = Ke(function(l) {
        var u = vt(l, ud);
        return u.length && u[0] === l[0] ? ed(u) : [];
      }), U9 = Ke(function(l) {
        var u = qn(l), g = vt(l, ud);
        return u === qn(g) ? u = n : g.pop(), g.length && g[0] === l[0] ? ed(g, Me(u, 2)) : [];
      }), K9 = Ke(function(l) {
        var u = qn(l), g = vt(l, ud);
        return u = typeof u == "function" ? u : n, u && g.pop(), g.length && g[0] === l[0] ? ed(g, n, u) : [];
      });
      function q9(l, u) {
        return l == null ? "" : W7.call(l, u);
      }
      function qn(l) {
        var u = l == null ? 0 : l.length;
        return u ? l[u - 1] : n;
      }
      function G9(l, u, g) {
        var x = l == null ? 0 : l.length;
        if (!x)
          return -1;
        var S = x;
        return g !== n && (S = Pe(g), S = S < 0 ? Lt(x + S, 0) : Qt(S, x - 1)), u === u ? k7(l, u, S) : zl(l, zm, S, !0);
      }
      function Y9(l, u) {
        return l && l.length ? x2(l, Pe(u)) : n;
      }
      var j9 = Ke(uv);
      function uv(l, u) {
        return l && l.length && u && u.length ? id(l, u) : l;
      }
      function X9(l, u, g) {
        return l && l.length && u && u.length ? id(l, u, Me(g, 2)) : l;
      }
      function Z9(l, u, g) {
        return l && l.length && u && u.length ? id(l, u, n, g) : l;
      }
      var Q9 = jr(function(l, u) {
        var g = l == null ? 0 : l.length, x = Xf(l, u);
        return $2(l, vt(u, function(S) {
          return Xr(S, g) ? +S : S;
        }).sort(I2)), x;
      });
      function J9(l, u) {
        var g = [];
        if (!(l && l.length))
          return g;
        var x = -1, S = [], E = l.length;
        for (u = Me(u, 3); ++x < E; ) {
          var I = l[x];
          u(I, x, l) && (g.push(I), S.push(x));
        }
        return $2(l, S), g;
      }
      function Sd(l) {
        return l == null ? l : q7.call(l);
      }
      function eA(l, u, g) {
        var x = l == null ? 0 : l.length;
        return x ? (g && typeof g != "number" && cn(l, u, g) ? (u = 0, g = x) : (u = u == null ? 0 : Pe(u), g = g === n ? x : Pe(g)), Kn(l, u, g)) : [];
      }
      function tA(l, u) {
        return cc(l, u);
      }
      function nA(l, u, g) {
        return ad(l, u, Me(g, 2));
      }
      function rA(l, u) {
        var g = l == null ? 0 : l.length;
        if (g) {
          var x = cc(l, u);
          if (x < g && nr(l[x], u))
            return x;
        }
        return -1;
      }
      function iA(l, u) {
        return cc(l, u, !0);
      }
      function oA(l, u, g) {
        return ad(l, u, Me(g, 2), !0);
      }
      function sA(l, u) {
        var g = l == null ? 0 : l.length;
        if (g) {
          var x = cc(l, u, !0) - 1;
          if (nr(l[x], u))
            return x;
        }
        return -1;
      }
      function aA(l) {
        return l && l.length ? A2(l) : [];
      }
      function lA(l, u) {
        return l && l.length ? A2(l, Me(u, 2)) : [];
      }
      function cA(l) {
        var u = l == null ? 0 : l.length;
        return u ? Kn(l, 1, u) : [];
      }
      function uA(l, u, g) {
        return l && l.length ? (u = g || u === n ? 1 : Pe(u), Kn(l, 0, u < 0 ? 0 : u)) : [];
      }
      function hA(l, u, g) {
        var x = l == null ? 0 : l.length;
        return x ? (u = g || u === n ? 1 : Pe(u), u = x - u, Kn(l, u < 0 ? 0 : u, x)) : [];
      }
      function fA(l, u) {
        return l && l.length ? uc(l, Me(u, 3), !1, !0) : [];
      }
      function dA(l, u) {
        return l && l.length ? uc(l, Me(u, 3)) : [];
      }
      var gA = Ke(function(l) {
        return ki(Yt(l, 1, $t, !0));
      }), pA = Ke(function(l) {
        var u = qn(l);
        return $t(u) && (u = n), ki(Yt(l, 1, $t, !0), Me(u, 2));
      }), mA = Ke(function(l) {
        var u = qn(l);
        return u = typeof u == "function" ? u : n, ki(Yt(l, 1, $t, !0), n, u);
      });
      function vA(l) {
        return l && l.length ? ki(l) : [];
      }
      function bA(l, u) {
        return l && l.length ? ki(l, Me(u, 2)) : [];
      }
      function wA(l, u) {
        return u = typeof u == "function" ? u : n, l && l.length ? ki(l, n, u) : [];
      }
      function Ad(l) {
        if (!(l && l.length))
          return [];
        var u = 0;
        return l = yi(l, function(g) {
          if ($t(g))
            return u = Lt(g.length, u), !0;
        }), Wf(u, function(g) {
          return vt(l, Vf(g));
        });
      }
      function hv(l, u) {
        if (!(l && l.length))
          return [];
        var g = Ad(l);
        return u == null ? g : vt(g, function(x) {
          return Mn(u, n, x);
        });
      }
      var xA = Ke(function(l, u) {
        return $t(l) ? ga(l, u) : [];
      }), yA = Ke(function(l) {
        return cd(yi(l, $t));
      }), CA = Ke(function(l) {
        var u = qn(l);
        return $t(u) && (u = n), cd(yi(l, $t), Me(u, 2));
      }), $A = Ke(function(l) {
        var u = qn(l);
        return u = typeof u == "function" ? u : n, cd(yi(l, $t), n, u);
      }), SA = Ke(Ad);
      function AA(l, u) {
        return R2(l || [], u || [], da);
      }
      function kA(l, u) {
        return R2(l || [], u || [], va);
      }
      var MA = Ke(function(l) {
        var u = l.length, g = u > 1 ? l[u - 1] : n;
        return g = typeof g == "function" ? (l.pop(), g) : n, hv(l, g);
      });
      function fv(l) {
        var u = M(l);
        return u.__chain__ = !0, u;
      }
      function TA(l, u) {
        return u(l), l;
      }
      function wc(l, u) {
        return u(l);
      }
      var RA = jr(function(l) {
        var u = l.length, g = u ? l[0] : 0, x = this.__wrapped__, S = function(E) {
          return Xf(E, l);
        };
        return u > 1 || this.__actions__.length || !(x instanceof Xe) || !Xr(g) ? this.thru(S) : (x = x.slice(g, +g + (u ? 1 : 0)), x.__actions__.push({
          func: wc,
          args: [S],
          thisArg: n
        }), new zn(x, this.__chain__).thru(function(E) {
          return u && !E.length && E.push(n), E;
        }));
      });
      function EA() {
        return fv(this);
      }
      function OA() {
        return new zn(this.value(), this.__chain__);
      }
      function DA() {
        this.__values__ === n && (this.__values__ = kv(this.value()));
        var l = this.__index__ >= this.__values__.length, u = l ? n : this.__values__[this.__index__++];
        return { done: l, value: u };
      }
      function IA() {
        return this;
      }
      function _A(l) {
        for (var u, g = this; g instanceof ic; ) {
          var x = ov(g);
          x.__index__ = 0, x.__values__ = n, u ? S.__wrapped__ = x : u = x;
          var S = x;
          g = g.__wrapped__;
        }
        return S.__wrapped__ = l, u;
      }
      function LA() {
        var l = this.__wrapped__;
        if (l instanceof Xe) {
          var u = l;
          return this.__actions__.length && (u = new Xe(this)), u = u.reverse(), u.__actions__.push({
            func: wc,
            args: [Sd],
            thisArg: n
          }), new zn(u, this.__chain__);
        }
        return this.thru(Sd);
      }
      function BA() {
        return T2(this.__wrapped__, this.__actions__);
      }
      var NA = hc(function(l, u, g) {
        st.call(l, g) ? ++l[g] : Gr(l, g, 1);
      });
      function FA(l, u, g) {
        var x = Fe(l) ? Pm : TS;
        return g && cn(l, u, g) && (u = n), x(l, Me(u, 3));
      }
      function VA(l, u) {
        var g = Fe(l) ? yi : h2;
        return g(l, Me(u, 3));
      }
      var HA = V2(sv), PA = V2(av);
      function WA(l, u) {
        return Yt(xc(l, u), 1);
      }
      function zA(l, u) {
        return Yt(xc(l, u), ie);
      }
      function UA(l, u, g) {
        return g = g === n ? 1 : Pe(g), Yt(xc(l, u), g);
      }
      function dv(l, u) {
        var g = Fe(l) ? Pn : Ai;
        return g(l, Me(u, 3));
      }
      function gv(l, u) {
        var g = Fe(l) ? c7 : u2;
        return g(l, Me(u, 3));
      }
      var KA = hc(function(l, u, g) {
        st.call(l, g) ? l[g].push(u) : Gr(l, g, [u]);
      });
      function qA(l, u, g, x) {
        l = mn(l) ? l : os(l), g = g && !x ? Pe(g) : 0;
        var S = l.length;
        return g < 0 && (g = Lt(S + g, 0)), Ac(l) ? g <= S && l.indexOf(u, g) > -1 : !!S && Go(l, u, g) > -1;
      }
      var GA = Ke(function(l, u, g) {
        var x = -1, S = typeof u == "function", E = mn(l) ? U(l.length) : [];
        return Ai(l, function(I) {
          E[++x] = S ? Mn(u, I, g) : pa(I, u, g);
        }), E;
      }), YA = hc(function(l, u, g) {
        Gr(l, g, u);
      });
      function xc(l, u) {
        var g = Fe(l) ? vt : v2;
        return g(l, Me(u, 3));
      }
      function jA(l, u, g, x) {
        return l == null ? [] : (Fe(u) || (u = u == null ? [] : [u]), g = x ? n : g, Fe(g) || (g = g == null ? [] : [g]), y2(l, u, g));
      }
      var XA = hc(function(l, u, g) {
        l[g ? 0 : 1].push(u);
      }, function() {
        return [[], []];
      });
      function ZA(l, u, g) {
        var x = Fe(l) ? Nf : Km, S = arguments.length < 3;
        return x(l, Me(u, 4), g, S, Ai);
      }
      function QA(l, u, g) {
        var x = Fe(l) ? u7 : Km, S = arguments.length < 3;
        return x(l, Me(u, 4), g, S, u2);
      }
      function JA(l, u) {
        var g = Fe(l) ? yi : h2;
        return g(l, $c(Me(u, 3)));
      }
      function ek(l) {
        var u = Fe(l) ? s2 : qS;
        return u(l);
      }
      function tk(l, u, g) {
        (g ? cn(l, u, g) : u === n) ? u = 1 : u = Pe(u);
        var x = Fe(l) ? $S : GS;
        return x(l, u);
      }
      function nk(l) {
        var u = Fe(l) ? SS : jS;
        return u(l);
      }
      function rk(l) {
        if (l == null)
          return 0;
        if (mn(l))
          return Ac(l) ? jo(l) : l.length;
        var u = Jt(l);
        return u == at || u == It ? l.size : nd(l).length;
      }
      function ik(l, u, g) {
        var x = Fe(l) ? Ff : XS;
        return g && cn(l, u, g) && (u = n), x(l, Me(u, 3));
      }
      var ok = Ke(function(l, u) {
        if (l == null)
          return [];
        var g = u.length;
        return g > 1 && cn(l, u[0], u[1]) ? u = [] : g > 2 && cn(u[0], u[1], u[2]) && (u = [u[0]]), y2(l, Yt(u, 1), []);
      }), yc = V7 || function() {
        return Gt.Date.now();
      };
      function sk(l, u) {
        if (typeof u != "function")
          throw new Wn(s);
        return l = Pe(l), function() {
          if (--l < 1)
            return u.apply(this, arguments);
        };
      }
      function pv(l, u, g) {
        return u = g ? n : u, u = l && u == null ? l.length : u, Yr(l, D, n, n, n, n, u);
      }
      function mv(l, u) {
        var g;
        if (typeof u != "function")
          throw new Wn(s);
        return l = Pe(l), function() {
          return --l > 0 && (g = u.apply(this, arguments)), l <= 1 && (u = n), g;
        };
      }
      var kd = Ke(function(l, u, g) {
        var x = y;
        if (g.length) {
          var S = $i(g, rs(kd));
          x |= R;
        }
        return Yr(l, x, u, g, S);
      }), vv = Ke(function(l, u, g) {
        var x = y | $;
        if (g.length) {
          var S = $i(g, rs(vv));
          x |= R;
        }
        return Yr(u, x, l, g, S);
      });
      function bv(l, u, g) {
        u = g ? n : u;
        var x = Yr(l, k, n, n, n, n, n, u);
        return x.placeholder = bv.placeholder, x;
      }
      function wv(l, u, g) {
        u = g ? n : u;
        var x = Yr(l, T, n, n, n, n, n, u);
        return x.placeholder = wv.placeholder, x;
      }
      function xv(l, u, g) {
        var x, S, E, I, L, F, Z = 0, Q = !1, ne = !1, he = !0;
        if (typeof l != "function")
          throw new Wn(s);
        u = Gn(u) || 0, wt(g) && (Q = !!g.leading, ne = "maxWait" in g, E = ne ? Lt(Gn(g.maxWait) || 0, u) : E, he = "trailing" in g ? !!g.trailing : he);
        function ye(St) {
          var rr = x, Jr = S;
          return x = S = n, Z = St, I = l.apply(Jr, rr), I;
        }
        function Te(St) {
          return Z = St, L = xa(Ye, u), Q ? ye(St) : I;
        }
        function We(St) {
          var rr = St - F, Jr = St - Z, Vv = u - rr;
          return ne ? Qt(Vv, E - Jr) : Vv;
        }
        function Re(St) {
          var rr = St - F, Jr = St - Z;
          return F === n || rr >= u || rr < 0 || ne && Jr >= E;
        }
        function Ye() {
          var St = yc();
          if (Re(St))
            return Je(St);
          L = xa(Ye, We(St));
        }
        function Je(St) {
          return L = n, he && x ? ye(St) : (x = S = n, I);
        }
        function On() {
          L !== n && E2(L), Z = 0, x = F = S = L = n;
        }
        function un() {
          return L === n ? I : Je(yc());
        }
        function Dn() {
          var St = yc(), rr = Re(St);
          if (x = arguments, S = this, F = St, rr) {
            if (L === n)
              return Te(F);
            if (ne)
              return E2(L), L = xa(Ye, u), ye(F);
          }
          return L === n && (L = xa(Ye, u)), I;
        }
        return Dn.cancel = On, Dn.flush = un, Dn;
      }
      var ak = Ke(function(l, u) {
        return c2(l, 1, u);
      }), lk = Ke(function(l, u, g) {
        return c2(l, Gn(u) || 0, g);
      });
      function ck(l) {
        return Yr(l, H);
      }
      function Cc(l, u) {
        if (typeof l != "function" || u != null && typeof u != "function")
          throw new Wn(s);
        var g = function() {
          var x = arguments, S = u ? u.apply(this, x) : x[0], E = g.cache;
          if (E.has(S))
            return E.get(S);
          var I = l.apply(this, x);
          return g.cache = E.set(S, I) || E, I;
        };
        return g.cache = new (Cc.Cache || qr)(), g;
      }
      Cc.Cache = qr;
      function $c(l) {
        if (typeof l != "function")
          throw new Wn(s);
        return function() {
          var u = arguments;
          switch (u.length) {
            case 0:
              return !l.call(this);
            case 1:
              return !l.call(this, u[0]);
            case 2:
              return !l.call(this, u[0], u[1]);
            case 3:
              return !l.call(this, u[0], u[1], u[2]);
          }
          return !l.apply(this, u);
        };
      }
      function uk(l) {
        return mv(2, l);
      }
      var hk = ZS(function(l, u) {
        u = u.length == 1 && Fe(u[0]) ? vt(u[0], Tn(Me())) : vt(Yt(u, 1), Tn(Me()));
        var g = u.length;
        return Ke(function(x) {
          for (var S = -1, E = Qt(x.length, g); ++S < E; )
            x[S] = u[S].call(this, x[S]);
          return Mn(l, this, x);
        });
      }), Md = Ke(function(l, u) {
        var g = $i(u, rs(Md));
        return Yr(l, R, n, u, g);
      }), yv = Ke(function(l, u) {
        var g = $i(u, rs(yv));
        return Yr(l, _, n, u, g);
      }), fk = jr(function(l, u) {
        return Yr(l, P, n, n, n, u);
      });
      function dk(l, u) {
        if (typeof l != "function")
          throw new Wn(s);
        return u = u === n ? u : Pe(u), Ke(l, u);
      }
      function gk(l, u) {
        if (typeof l != "function")
          throw new Wn(s);
        return u = u == null ? 0 : Lt(Pe(u), 0), Ke(function(g) {
          var x = g[u], S = Ti(g, 0, u);
          return x && Ci(S, x), Mn(l, this, S);
        });
      }
      function pk(l, u, g) {
        var x = !0, S = !0;
        if (typeof l != "function")
          throw new Wn(s);
        return wt(g) && (x = "leading" in g ? !!g.leading : x, S = "trailing" in g ? !!g.trailing : S), xv(l, u, {
          leading: x,
          maxWait: u,
          trailing: S
        });
      }
      function mk(l) {
        return pv(l, 1);
      }
      function vk(l, u) {
        return Md(hd(u), l);
      }
      function bk() {
        if (!arguments.length)
          return [];
        var l = arguments[0];
        return Fe(l) ? l : [l];
      }
      function wk(l) {
        return Un(l, v);
      }
      function xk(l, u) {
        return u = typeof u == "function" ? u : n, Un(l, v, u);
      }
      function yk(l) {
        return Un(l, d | v);
      }
      function Ck(l, u) {
        return u = typeof u == "function" ? u : n, Un(l, d | v, u);
      }
      function $k(l, u) {
        return u == null || l2(l, u, Ht(u));
      }
      function nr(l, u) {
        return l === u || l !== l && u !== u;
      }
      var Sk = pc(Jf), Ak = pc(function(l, u) {
        return l >= u;
      }), lo = g2(/* @__PURE__ */ function() {
        return arguments;
      }()) ? g2 : function(l) {
        return yt(l) && st.call(l, "callee") && !e2.call(l, "callee");
      }, Fe = U.isArray, kk = Lm ? Tn(Lm) : _S;
      function mn(l) {
        return l != null && Sc(l.length) && !Zr(l);
      }
      function $t(l) {
        return yt(l) && mn(l);
      }
      function Mk(l) {
        return l === !0 || l === !1 || yt(l) && ln(l) == Ve;
      }
      var Ri = P7 || Fd, Tk = Bm ? Tn(Bm) : LS;
      function Rk(l) {
        return yt(l) && l.nodeType === 1 && !ya(l);
      }
      function Ek(l) {
        if (l == null)
          return !0;
        if (mn(l) && (Fe(l) || typeof l == "string" || typeof l.splice == "function" || Ri(l) || is(l) || lo(l)))
          return !l.length;
        var u = Jt(l);
        if (u == at || u == It)
          return !l.size;
        if (wa(l))
          return !nd(l).length;
        for (var g in l)
          if (st.call(l, g))
            return !1;
        return !0;
      }
      function Ok(l, u) {
        return ma(l, u);
      }
      function Dk(l, u, g) {
        g = typeof g == "function" ? g : n;
        var x = g ? g(l, u) : n;
        return x === n ? ma(l, u, n, g) : !!x;
      }
      function Td(l) {
        if (!yt(l))
          return !1;
        var u = ln(l);
        return u == Ee || u == Ue || typeof l.message == "string" && typeof l.name == "string" && !ya(l);
      }
      function Ik(l) {
        return typeof l == "number" && n2(l);
      }
      function Zr(l) {
        if (!wt(l))
          return !1;
        var u = ln(l);
        return u == je || u == Rt || u == xe || u == Ko;
      }
      function Cv(l) {
        return typeof l == "number" && l == Pe(l);
      }
      function Sc(l) {
        return typeof l == "number" && l > -1 && l % 1 == 0 && l <= se;
      }
      function wt(l) {
        var u = typeof l;
        return l != null && (u == "object" || u == "function");
      }
      function yt(l) {
        return l != null && typeof l == "object";
      }
      var $v = Nm ? Tn(Nm) : NS;
      function _k(l, u) {
        return l === u || td(l, u, bd(u));
      }
      function Lk(l, u, g) {
        return g = typeof g == "function" ? g : n, td(l, u, bd(u), g);
      }
      function Bk(l) {
        return Sv(l) && l != +l;
      }
      function Nk(l) {
        if (x9(l))
          throw new Be(o);
        return p2(l);
      }
      function Fk(l) {
        return l === null;
      }
      function Vk(l) {
        return l == null;
      }
      function Sv(l) {
        return typeof l == "number" || yt(l) && ln(l) == Qe;
      }
      function ya(l) {
        if (!yt(l) || ln(l) != Ct)
          return !1;
        var u = Zl(l);
        if (u === null)
          return !0;
        var g = st.call(u, "constructor") && u.constructor;
        return typeof g == "function" && g instanceof g && Gl.call(g) == L7;
      }
      var Rd = Fm ? Tn(Fm) : FS;
      function Hk(l) {
        return Cv(l) && l >= -9007199254740991 && l <= se;
      }
      var Av = Vm ? Tn(Vm) : VS;
      function Ac(l) {
        return typeof l == "string" || !Fe(l) && yt(l) && ln(l) == Wr;
      }
      function En(l) {
        return typeof l == "symbol" || yt(l) && ln(l) == zr;
      }
      var is = Hm ? Tn(Hm) : HS;
      function Pk(l) {
        return l === n;
      }
      function Wk(l) {
        return yt(l) && Jt(l) == Ur;
      }
      function zk(l) {
        return yt(l) && ln(l) == bf;
      }
      var Uk = pc(rd), Kk = pc(function(l, u) {
        return l <= u;
      });
      function kv(l) {
        if (!l)
          return [];
        if (mn(l))
          return Ac(l) ? er(l) : pn(l);
        if (la && l[la])
          return $7(l[la]());
        var u = Jt(l), g = u == at ? Uf : u == It ? Ul : os;
        return g(l);
      }
      function Qr(l) {
        if (!l)
          return l === 0 ? l : 0;
        if (l = Gn(l), l === ie || l === -1 / 0) {
          var u = l < 0 ? -1 : 1;
          return u * X;
        }
        return l === l ? l : 0;
      }
      function Pe(l) {
        var u = Qr(l), g = u % 1;
        return u === u ? g ? u - g : u : 0;
      }
      function Mv(l) {
        return l ? io(Pe(l), 0, be) : 0;
      }
      function Gn(l) {
        if (typeof l == "number")
          return l;
        if (En(l))
          return ce;
        if (wt(l)) {
          var u = typeof l.valueOf == "function" ? l.valueOf() : l;
          l = wt(u) ? u + "" : u;
        }
        if (typeof l != "string")
          return l === 0 ? l : +l;
        l = qm(l);
        var g = k8.test(l);
        return g || T8.test(l) ? s7(l.slice(2), g ? 2 : 8) : A8.test(l) ? ce : +l;
      }
      function Tv(l) {
        return br(l, vn(l));
      }
      function qk(l) {
        return l ? io(Pe(l), -9007199254740991, se) : l === 0 ? l : 0;
      }
      function ot(l) {
        return l == null ? "" : Rn(l);
      }
      var Gk = ts(function(l, u) {
        if (wa(u) || mn(u)) {
          br(u, Ht(u), l);
          return;
        }
        for (var g in u)
          st.call(u, g) && da(l, g, u[g]);
      }), Rv = ts(function(l, u) {
        br(u, vn(u), l);
      }), kc = ts(function(l, u, g, x) {
        br(u, vn(u), l, x);
      }), Yk = ts(function(l, u, g, x) {
        br(u, Ht(u), l, x);
      }), jk = jr(Xf);
      function Xk(l, u) {
        var g = es(l);
        return u == null ? g : a2(g, u);
      }
      var Zk = Ke(function(l, u) {
        l = ct(l);
        var g = -1, x = u.length, S = x > 2 ? u[2] : n;
        for (S && cn(u[0], u[1], S) && (x = 1); ++g < x; )
          for (var E = u[g], I = vn(E), L = -1, F = I.length; ++L < F; ) {
            var Z = I[L], Q = l[Z];
            (Q === n || nr(Q, Zo[Z]) && !st.call(l, Z)) && (l[Z] = E[Z]);
          }
        return l;
      }), Qk = Ke(function(l) {
        return l.push(n, q2), Mn(Ev, n, l);
      });
      function Jk(l, u) {
        return Wm(l, Me(u, 3), vr);
      }
      function eM(l, u) {
        return Wm(l, Me(u, 3), Qf);
      }
      function tM(l, u) {
        return l == null ? l : Zf(l, Me(u, 3), vn);
      }
      function nM(l, u) {
        return l == null ? l : f2(l, Me(u, 3), vn);
      }
      function rM(l, u) {
        return l && vr(l, Me(u, 3));
      }
      function iM(l, u) {
        return l && Qf(l, Me(u, 3));
      }
      function oM(l) {
        return l == null ? [] : ac(l, Ht(l));
      }
      function sM(l) {
        return l == null ? [] : ac(l, vn(l));
      }
      function Ed(l, u, g) {
        var x = l == null ? n : oo(l, u);
        return x === n ? g : x;
      }
      function aM(l, u) {
        return l != null && j2(l, u, ES);
      }
      function Od(l, u) {
        return l != null && j2(l, u, OS);
      }
      var lM = P2(function(l, u, g) {
        u != null && typeof u.toString != "function" && (u = Yl.call(u)), l[u] = g;
      }, Id(bn)), cM = P2(function(l, u, g) {
        u != null && typeof u.toString != "function" && (u = Yl.call(u)), st.call(l, u) ? l[u].push(g) : l[u] = [g];
      }, Me), uM = Ke(pa);
      function Ht(l) {
        return mn(l) ? o2(l) : nd(l);
      }
      function vn(l) {
        return mn(l) ? o2(l, !0) : PS(l);
      }
      function hM(l, u) {
        var g = {};
        return u = Me(u, 3), vr(l, function(x, S, E) {
          Gr(g, u(x, S, E), x);
        }), g;
      }
      function fM(l, u) {
        var g = {};
        return u = Me(u, 3), vr(l, function(x, S, E) {
          Gr(g, S, u(x, S, E));
        }), g;
      }
      var dM = ts(function(l, u, g) {
        lc(l, u, g);
      }), Ev = ts(function(l, u, g, x) {
        lc(l, u, g, x);
      }), gM = jr(function(l, u) {
        var g = {};
        if (l == null)
          return g;
        var x = !1;
        u = vt(u, function(E) {
          return E = Mi(E, l), x || (x = E.length > 1), E;
        }), br(l, md(l), g), x && (g = Un(g, d | p | v, l9));
        for (var S = u.length; S--; )
          ld(g, u[S]);
        return g;
      });
      function pM(l, u) {
        return Ov(l, $c(Me(u)));
      }
      var mM = jr(function(l, u) {
        return l == null ? {} : zS(l, u);
      });
      function Ov(l, u) {
        if (l == null)
          return {};
        var g = vt(md(l), function(x) {
          return [x];
        });
        return u = Me(u), C2(l, g, function(x, S) {
          return u(x, S[0]);
        });
      }
      function vM(l, u, g) {
        u = Mi(u, l);
        var x = -1, S = u.length;
        for (S || (S = 1, l = n); ++x < S; ) {
          var E = l == null ? n : l[wr(u[x])];
          E === n && (x = S, E = g), l = Zr(E) ? E.call(l) : E;
        }
        return l;
      }
      function bM(l, u, g) {
        return l == null ? l : va(l, u, g);
      }
      function wM(l, u, g, x) {
        return x = typeof x == "function" ? x : n, l == null ? l : va(l, u, g, x);
      }
      var Dv = U2(Ht), Iv = U2(vn);
      function xM(l, u, g) {
        var x = Fe(l), S = x || Ri(l) || is(l);
        if (u = Me(u, 4), g == null) {
          var E = l && l.constructor;
          S ? g = x ? new E() : [] : wt(l) ? g = Zr(E) ? es(Zl(l)) : {} : g = {};
        }
        return (S ? Pn : vr)(l, function(I, L, F) {
          return u(g, I, L, F);
        }), g;
      }
      function yM(l, u) {
        return l == null ? !0 : ld(l, u);
      }
      function CM(l, u, g) {
        return l == null ? l : M2(l, u, hd(g));
      }
      function $M(l, u, g, x) {
        return x = typeof x == "function" ? x : n, l == null ? l : M2(l, u, hd(g), x);
      }
      function os(l) {
        return l == null ? [] : zf(l, Ht(l));
      }
      function SM(l) {
        return l == null ? [] : zf(l, vn(l));
      }
      function AM(l, u, g) {
        return g === n && (g = u, u = n), g !== n && (g = Gn(g), g = g === g ? g : 0), u !== n && (u = Gn(u), u = u === u ? u : 0), io(Gn(l), u, g);
      }
      function kM(l, u, g) {
        return u = Qr(u), g === n ? (g = u, u = 0) : g = Qr(g), l = Gn(l), DS(l, u, g);
      }
      function MM(l, u, g) {
        if (g && typeof g != "boolean" && cn(l, u, g) && (u = g = n), g === n && (typeof u == "boolean" ? (g = u, u = n) : typeof l == "boolean" && (g = l, l = n)), l === n && u === n ? (l = 0, u = 1) : (l = Qr(l), u === n ? (u = l, l = 0) : u = Qr(u)), l > u) {
          var x = l;
          l = u, u = x;
        }
        if (g || l % 1 || u % 1) {
          var S = r2();
          return Qt(l + S * (u - l + o7("1e-" + ((S + "").length - 1))), u);
        }
        return od(l, u);
      }
      var TM = ns(function(l, u, g) {
        return u = u.toLowerCase(), l + (g ? _v(u) : u);
      });
      function _v(l) {
        return Dd(ot(l).toLowerCase());
      }
      function Lv(l) {
        return l = ot(l), l && l.replace(E8, b7).replace(j8, "");
      }
      function RM(l, u, g) {
        l = ot(l), u = Rn(u);
        var x = l.length;
        g = g === n ? x : io(Pe(g), 0, x);
        var S = g;
        return g -= u.length, g >= 0 && l.slice(g, S) == u;
      }
      function EM(l) {
        return l = ot(l), l && u8.test(l) ? l.replace(fm, w7) : l;
      }
      function OM(l) {
        return l = ot(l), l && m8.test(l) ? l.replace(Mf, "\\$&") : l;
      }
      var DM = ns(function(l, u, g) {
        return l + (g ? "-" : "") + u.toLowerCase();
      }), IM = ns(function(l, u, g) {
        return l + (g ? " " : "") + u.toLowerCase();
      }), _M = F2("toLowerCase");
      function LM(l, u, g) {
        l = ot(l), u = Pe(u);
        var x = u ? jo(l) : 0;
        if (!u || x >= u)
          return l;
        var S = (u - x) / 2;
        return gc(tc(S), g) + l + gc(ec(S), g);
      }
      function BM(l, u, g) {
        l = ot(l), u = Pe(u);
        var x = u ? jo(l) : 0;
        return u && x < u ? l + gc(u - x, g) : l;
      }
      function NM(l, u, g) {
        l = ot(l), u = Pe(u);
        var x = u ? jo(l) : 0;
        return u && x < u ? gc(u - x, g) + l : l;
      }
      function FM(l, u, g) {
        return g || u == null ? u = 0 : u && (u = +u), K7(ot(l).replace(Tf, ""), u || 0);
      }
      function VM(l, u, g) {
        return (g ? cn(l, u, g) : u === n) ? u = 1 : u = Pe(u), sd(ot(l), u);
      }
      function HM() {
        var l = arguments, u = ot(l[0]);
        return l.length < 3 ? u : u.replace(l[1], l[2]);
      }
      var PM = ns(function(l, u, g) {
        return l + (g ? "_" : "") + u.toLowerCase();
      });
      function WM(l, u, g) {
        return g && typeof g != "number" && cn(l, u, g) && (u = g = n), g = g === n ? be : g >>> 0, g ? (l = ot(l), l && (typeof u == "string" || u != null && !Rd(u)) && (u = Rn(u), !u && Yo(l)) ? Ti(er(l), 0, g) : l.split(u, g)) : [];
      }
      var zM = ns(function(l, u, g) {
        return l + (g ? " " : "") + Dd(u);
      });
      function UM(l, u, g) {
        return l = ot(l), g = g == null ? 0 : io(Pe(g), 0, l.length), u = Rn(u), l.slice(g, g + u.length) == u;
      }
      function KM(l, u, g) {
        var x = M.templateSettings;
        g && cn(l, u, g) && (u = n), l = ot(l), u = kc({}, u, x, K2);
        var S = kc({}, u.imports, x.imports, K2), E = Ht(S), I = zf(S, E), L, F, Z = 0, Q = u.interpolate || Vl, ne = "__p += '", he = Kf(
          (u.escape || Vl).source + "|" + Q.source + "|" + (Q === dm ? S8 : Vl).source + "|" + (u.evaluate || Vl).source + "|$",
          "g"
        ), ye = "//# sourceURL=" + (st.call(u, "sourceURL") ? (u.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++e7 + "]") + `
`;
        l.replace(he, function(Re, Ye, Je, On, un, Dn) {
          return Je || (Je = On), ne += l.slice(Z, Dn).replace(O8, x7), Ye && (L = !0, ne += `' +
__e(` + Ye + `) +
'`), un && (F = !0, ne += `';
` + un + `;
__p += '`), Je && (ne += `' +
((__t = (` + Je + `)) == null ? '' : __t) +
'`), Z = Dn + Re.length, Re;
        }), ne += `';
`;
        var Te = st.call(u, "variable") && u.variable;
        if (!Te)
          ne = `with (obj) {
` + ne + `
}
`;
        else if (C8.test(Te))
          throw new Be(a);
        ne = (F ? ne.replace(s8, "") : ne).replace(a8, "$1").replace(l8, "$1;"), ne = "function(" + (Te || "obj") + `) {
` + (Te ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (L ? ", __e = _.escape" : "") + (F ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + ne + `return __p
}`;
        var We = Nv(function() {
          return it(E, ye + "return " + ne).apply(n, I);
        });
        if (We.source = ne, Td(We))
          throw We;
        return We;
      }
      function qM(l) {
        return ot(l).toLowerCase();
      }
      function GM(l) {
        return ot(l).toUpperCase();
      }
      function YM(l, u, g) {
        if (l = ot(l), l && (g || u === n))
          return qm(l);
        if (!l || !(u = Rn(u)))
          return l;
        var x = er(l), S = er(u), E = Gm(x, S), I = Ym(x, S) + 1;
        return Ti(x, E, I).join("");
      }
      function jM(l, u, g) {
        if (l = ot(l), l && (g || u === n))
          return l.slice(0, Xm(l) + 1);
        if (!l || !(u = Rn(u)))
          return l;
        var x = er(l), S = Ym(x, er(u)) + 1;
        return Ti(x, 0, S).join("");
      }
      function XM(l, u, g) {
        if (l = ot(l), l && (g || u === n))
          return l.replace(Tf, "");
        if (!l || !(u = Rn(u)))
          return l;
        var x = er(l), S = Gm(x, er(u));
        return Ti(x, S).join("");
      }
      function ZM(l, u) {
        var g = z, x = j;
        if (wt(u)) {
          var S = "separator" in u ? u.separator : S;
          g = "length" in u ? Pe(u.length) : g, x = "omission" in u ? Rn(u.omission) : x;
        }
        l = ot(l);
        var E = l.length;
        if (Yo(l)) {
          var I = er(l);
          E = I.length;
        }
        if (g >= E)
          return l;
        var L = g - jo(x);
        if (L < 1)
          return x;
        var F = I ? Ti(I, 0, L).join("") : l.slice(0, L);
        if (S === n)
          return F + x;
        if (I && (L += F.length - L), Rd(S)) {
          if (l.slice(L).search(S)) {
            var Z, Q = F;
            for (S.global || (S = Kf(S.source, ot(gm.exec(S)) + "g")), S.lastIndex = 0; Z = S.exec(Q); )
              var ne = Z.index;
            F = F.slice(0, ne === n ? L : ne);
          }
        } else if (l.indexOf(Rn(S), L) != L) {
          var he = F.lastIndexOf(S);
          he > -1 && (F = F.slice(0, he));
        }
        return F + x;
      }
      function QM(l) {
        return l = ot(l), l && c8.test(l) ? l.replace(hm, M7) : l;
      }
      var JM = ns(function(l, u, g) {
        return l + (g ? " " : "") + u.toUpperCase();
      }), Dd = F2("toUpperCase");
      function Bv(l, u, g) {
        return l = ot(l), u = g ? n : u, u === n ? C7(l) ? E7(l) : d7(l) : l.match(u) || [];
      }
      var Nv = Ke(function(l, u) {
        try {
          return Mn(l, n, u);
        } catch (g) {
          return Td(g) ? g : new Be(g);
        }
      }), eT = jr(function(l, u) {
        return Pn(u, function(g) {
          g = wr(g), Gr(l, g, kd(l[g], l));
        }), l;
      });
      function tT(l) {
        var u = l == null ? 0 : l.length, g = Me();
        return l = u ? vt(l, function(x) {
          if (typeof x[1] != "function")
            throw new Wn(s);
          return [g(x[0]), x[1]];
        }) : [], Ke(function(x) {
          for (var S = -1; ++S < u; ) {
            var E = l[S];
            if (Mn(E[0], this, x))
              return Mn(E[1], this, x);
          }
        });
      }
      function nT(l) {
        return MS(Un(l, d));
      }
      function Id(l) {
        return function() {
          return l;
        };
      }
      function rT(l, u) {
        return l == null || l !== l ? u : l;
      }
      var iT = H2(), oT = H2(!0);
      function bn(l) {
        return l;
      }
      function _d(l) {
        return m2(typeof l == "function" ? l : Un(l, d));
      }
      function sT(l) {
        return b2(Un(l, d));
      }
      function aT(l, u) {
        return w2(l, Un(u, d));
      }
      var lT = Ke(function(l, u) {
        return function(g) {
          return pa(g, l, u);
        };
      }), cT = Ke(function(l, u) {
        return function(g) {
          return pa(l, g, u);
        };
      });
      function Ld(l, u, g) {
        var x = Ht(u), S = ac(u, x);
        g == null && !(wt(u) && (S.length || !x.length)) && (g = u, u = l, l = this, S = ac(u, Ht(u)));
        var E = !(wt(g) && "chain" in g) || !!g.chain, I = Zr(l);
        return Pn(S, function(L) {
          var F = u[L];
          l[L] = F, I && (l.prototype[L] = function() {
            var Z = this.__chain__;
            if (E || Z) {
              var Q = l(this.__wrapped__), ne = Q.__actions__ = pn(this.__actions__);
              return ne.push({ func: F, args: arguments, thisArg: l }), Q.__chain__ = Z, Q;
            }
            return F.apply(l, Ci([this.value()], arguments));
          });
        }), l;
      }
      function uT() {
        return Gt._ === this && (Gt._ = B7), this;
      }
      function Bd() {
      }
      function hT(l) {
        return l = Pe(l), Ke(function(u) {
          return x2(u, l);
        });
      }
      var fT = dd(vt), dT = dd(Pm), gT = dd(Ff);
      function Fv(l) {
        return xd(l) ? Vf(wr(l)) : US(l);
      }
      function pT(l) {
        return function(u) {
          return l == null ? n : oo(l, u);
        };
      }
      var mT = W2(), vT = W2(!0);
      function Nd() {
        return [];
      }
      function Fd() {
        return !1;
      }
      function bT() {
        return {};
      }
      function wT() {
        return "";
      }
      function xT() {
        return !0;
      }
      function yT(l, u) {
        if (l = Pe(l), l < 1 || l > se)
          return [];
        var g = be, x = Qt(l, be);
        u = Me(u), l -= be;
        for (var S = Wf(x, u); ++g < l; )
          u(g);
        return S;
      }
      function CT(l) {
        return Fe(l) ? vt(l, wr) : En(l) ? [l] : pn(iv(ot(l)));
      }
      function $T(l) {
        var u = ++_7;
        return ot(l) + u;
      }
      var ST = dc(function(l, u) {
        return l + u;
      }, 0), AT = gd("ceil"), kT = dc(function(l, u) {
        return l / u;
      }, 1), MT = gd("floor");
      function TT(l) {
        return l && l.length ? sc(l, bn, Jf) : n;
      }
      function RT(l, u) {
        return l && l.length ? sc(l, Me(u, 2), Jf) : n;
      }
      function ET(l) {
        return Um(l, bn);
      }
      function OT(l, u) {
        return Um(l, Me(u, 2));
      }
      function DT(l) {
        return l && l.length ? sc(l, bn, rd) : n;
      }
      function IT(l, u) {
        return l && l.length ? sc(l, Me(u, 2), rd) : n;
      }
      var _T = dc(function(l, u) {
        return l * u;
      }, 1), LT = gd("round"), BT = dc(function(l, u) {
        return l - u;
      }, 0);
      function NT(l) {
        return l && l.length ? Pf(l, bn) : 0;
      }
      function FT(l, u) {
        return l && l.length ? Pf(l, Me(u, 2)) : 0;
      }
      return M.after = sk, M.ary = pv, M.assign = Gk, M.assignIn = Rv, M.assignInWith = kc, M.assignWith = Yk, M.at = jk, M.before = mv, M.bind = kd, M.bindAll = eT, M.bindKey = vv, M.castArray = bk, M.chain = fv, M.chunk = M9, M.compact = T9, M.concat = R9, M.cond = tT, M.conforms = nT, M.constant = Id, M.countBy = NA, M.create = Xk, M.curry = bv, M.curryRight = wv, M.debounce = xv, M.defaults = Zk, M.defaultsDeep = Qk, M.defer = ak, M.delay = lk, M.difference = E9, M.differenceBy = O9, M.differenceWith = D9, M.drop = I9, M.dropRight = _9, M.dropRightWhile = L9, M.dropWhile = B9, M.fill = N9, M.filter = VA, M.flatMap = WA, M.flatMapDeep = zA, M.flatMapDepth = UA, M.flatten = lv, M.flattenDeep = F9, M.flattenDepth = V9, M.flip = ck, M.flow = iT, M.flowRight = oT, M.fromPairs = H9, M.functions = oM, M.functionsIn = sM, M.groupBy = KA, M.initial = W9, M.intersection = z9, M.intersectionBy = U9, M.intersectionWith = K9, M.invert = lM, M.invertBy = cM, M.invokeMap = GA, M.iteratee = _d, M.keyBy = YA, M.keys = Ht, M.keysIn = vn, M.map = xc, M.mapKeys = hM, M.mapValues = fM, M.matches = sT, M.matchesProperty = aT, M.memoize = Cc, M.merge = dM, M.mergeWith = Ev, M.method = lT, M.methodOf = cT, M.mixin = Ld, M.negate = $c, M.nthArg = hT, M.omit = gM, M.omitBy = pM, M.once = uk, M.orderBy = jA, M.over = fT, M.overArgs = hk, M.overEvery = dT, M.overSome = gT, M.partial = Md, M.partialRight = yv, M.partition = XA, M.pick = mM, M.pickBy = Ov, M.property = Fv, M.propertyOf = pT, M.pull = j9, M.pullAll = uv, M.pullAllBy = X9, M.pullAllWith = Z9, M.pullAt = Q9, M.range = mT, M.rangeRight = vT, M.rearg = fk, M.reject = JA, M.remove = J9, M.rest = dk, M.reverse = Sd, M.sampleSize = tk, M.set = bM, M.setWith = wM, M.shuffle = nk, M.slice = eA, M.sortBy = ok, M.sortedUniq = aA, M.sortedUniqBy = lA, M.split = WM, M.spread = gk, M.tail = cA, M.take = uA, M.takeRight = hA, M.takeRightWhile = fA, M.takeWhile = dA, M.tap = TA, M.throttle = pk, M.thru = wc, M.toArray = kv, M.toPairs = Dv, M.toPairsIn = Iv, M.toPath = CT, M.toPlainObject = Tv, M.transform = xM, M.unary = mk, M.union = gA, M.unionBy = pA, M.unionWith = mA, M.uniq = vA, M.uniqBy = bA, M.uniqWith = wA, M.unset = yM, M.unzip = Ad, M.unzipWith = hv, M.update = CM, M.updateWith = $M, M.values = os, M.valuesIn = SM, M.without = xA, M.words = Bv, M.wrap = vk, M.xor = yA, M.xorBy = CA, M.xorWith = $A, M.zip = SA, M.zipObject = AA, M.zipObjectDeep = kA, M.zipWith = MA, M.entries = Dv, M.entriesIn = Iv, M.extend = Rv, M.extendWith = kc, Ld(M, M), M.add = ST, M.attempt = Nv, M.camelCase = TM, M.capitalize = _v, M.ceil = AT, M.clamp = AM, M.clone = wk, M.cloneDeep = yk, M.cloneDeepWith = Ck, M.cloneWith = xk, M.conformsTo = $k, M.deburr = Lv, M.defaultTo = rT, M.divide = kT, M.endsWith = RM, M.eq = nr, M.escape = EM, M.escapeRegExp = OM, M.every = FA, M.find = HA, M.findIndex = sv, M.findKey = Jk, M.findLast = PA, M.findLastIndex = av, M.findLastKey = eM, M.floor = MT, M.forEach = dv, M.forEachRight = gv, M.forIn = tM, M.forInRight = nM, M.forOwn = rM, M.forOwnRight = iM, M.get = Ed, M.gt = Sk, M.gte = Ak, M.has = aM, M.hasIn = Od, M.head = cv, M.identity = bn, M.includes = qA, M.indexOf = P9, M.inRange = kM, M.invoke = uM, M.isArguments = lo, M.isArray = Fe, M.isArrayBuffer = kk, M.isArrayLike = mn, M.isArrayLikeObject = $t, M.isBoolean = Mk, M.isBuffer = Ri, M.isDate = Tk, M.isElement = Rk, M.isEmpty = Ek, M.isEqual = Ok, M.isEqualWith = Dk, M.isError = Td, M.isFinite = Ik, M.isFunction = Zr, M.isInteger = Cv, M.isLength = Sc, M.isMap = $v, M.isMatch = _k, M.isMatchWith = Lk, M.isNaN = Bk, M.isNative = Nk, M.isNil = Vk, M.isNull = Fk, M.isNumber = Sv, M.isObject = wt, M.isObjectLike = yt, M.isPlainObject = ya, M.isRegExp = Rd, M.isSafeInteger = Hk, M.isSet = Av, M.isString = Ac, M.isSymbol = En, M.isTypedArray = is, M.isUndefined = Pk, M.isWeakMap = Wk, M.isWeakSet = zk, M.join = q9, M.kebabCase = DM, M.last = qn, M.lastIndexOf = G9, M.lowerCase = IM, M.lowerFirst = _M, M.lt = Uk, M.lte = Kk, M.max = TT, M.maxBy = RT, M.mean = ET, M.meanBy = OT, M.min = DT, M.minBy = IT, M.stubArray = Nd, M.stubFalse = Fd, M.stubObject = bT, M.stubString = wT, M.stubTrue = xT, M.multiply = _T, M.nth = Y9, M.noConflict = uT, M.noop = Bd, M.now = yc, M.pad = LM, M.padEnd = BM, M.padStart = NM, M.parseInt = FM, M.random = MM, M.reduce = ZA, M.reduceRight = QA, M.repeat = VM, M.replace = HM, M.result = vM, M.round = LT, M.runInContext = N, M.sample = ek, M.size = rk, M.snakeCase = PM, M.some = ik, M.sortedIndex = tA, M.sortedIndexBy = nA, M.sortedIndexOf = rA, M.sortedLastIndex = iA, M.sortedLastIndexBy = oA, M.sortedLastIndexOf = sA, M.startCase = zM, M.startsWith = UM, M.subtract = BT, M.sum = NT, M.sumBy = FT, M.template = KM, M.times = yT, M.toFinite = Qr, M.toInteger = Pe, M.toLength = Mv, M.toLower = qM, M.toNumber = Gn, M.toSafeInteger = qk, M.toString = ot, M.toUpper = GM, M.trim = YM, M.trimEnd = jM, M.trimStart = XM, M.truncate = ZM, M.unescape = QM, M.uniqueId = $T, M.upperCase = JM, M.upperFirst = Dd, M.each = dv, M.eachRight = gv, M.first = cv, Ld(M, function() {
        var l = {};
        return vr(M, function(u, g) {
          st.call(M.prototype, g) || (l[g] = u);
        }), l;
      }(), { chain: !1 }), M.VERSION = r, Pn(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(l) {
        M[l].placeholder = M;
      }), Pn(["drop", "take"], function(l, u) {
        Xe.prototype[l] = function(g) {
          g = g === n ? 1 : Lt(Pe(g), 0);
          var x = this.__filtered__ && !u ? new Xe(this) : this.clone();
          return x.__filtered__ ? x.__takeCount__ = Qt(g, x.__takeCount__) : x.__views__.push({
            size: Qt(g, be),
            type: l + (x.__dir__ < 0 ? "Right" : "")
          }), x;
        }, Xe.prototype[l + "Right"] = function(g) {
          return this.reverse()[l](g).reverse();
        };
      }), Pn(["filter", "map", "takeWhile"], function(l, u) {
        var g = u + 1, x = g == ee || g == de;
        Xe.prototype[l] = function(S) {
          var E = this.clone();
          return E.__iteratees__.push({
            iteratee: Me(S, 3),
            type: g
          }), E.__filtered__ = E.__filtered__ || x, E;
        };
      }), Pn(["head", "last"], function(l, u) {
        var g = "take" + (u ? "Right" : "");
        Xe.prototype[l] = function() {
          return this[g](1).value()[0];
        };
      }), Pn(["initial", "tail"], function(l, u) {
        var g = "drop" + (u ? "" : "Right");
        Xe.prototype[l] = function() {
          return this.__filtered__ ? new Xe(this) : this[g](1);
        };
      }), Xe.prototype.compact = function() {
        return this.filter(bn);
      }, Xe.prototype.find = function(l) {
        return this.filter(l).head();
      }, Xe.prototype.findLast = function(l) {
        return this.reverse().find(l);
      }, Xe.prototype.invokeMap = Ke(function(l, u) {
        return typeof l == "function" ? new Xe(this) : this.map(function(g) {
          return pa(g, l, u);
        });
      }), Xe.prototype.reject = function(l) {
        return this.filter($c(Me(l)));
      }, Xe.prototype.slice = function(l, u) {
        l = Pe(l);
        var g = this;
        return g.__filtered__ && (l > 0 || u < 0) ? new Xe(g) : (l < 0 ? g = g.takeRight(-l) : l && (g = g.drop(l)), u !== n && (u = Pe(u), g = u < 0 ? g.dropRight(-u) : g.take(u - l)), g);
      }, Xe.prototype.takeRightWhile = function(l) {
        return this.reverse().takeWhile(l).reverse();
      }, Xe.prototype.toArray = function() {
        return this.take(be);
      }, vr(Xe.prototype, function(l, u) {
        var g = /^(?:filter|find|map|reject)|While$/.test(u), x = /^(?:head|last)$/.test(u), S = M[x ? "take" + (u == "last" ? "Right" : "") : u], E = x || /^find/.test(u);
        S && (M.prototype[u] = function() {
          var I = this.__wrapped__, L = x ? [1] : arguments, F = I instanceof Xe, Z = L[0], Q = F || Fe(I), ne = function(Ye) {
            var Je = S.apply(M, Ci([Ye], L));
            return x && he ? Je[0] : Je;
          };
          Q && g && typeof Z == "function" && Z.length != 1 && (F = Q = !1);
          var he = this.__chain__, ye = !!this.__actions__.length, Te = E && !he, We = F && !ye;
          if (!E && Q) {
            I = We ? I : new Xe(this);
            var Re = l.apply(I, L);
            return Re.__actions__.push({ func: wc, args: [ne], thisArg: n }), new zn(Re, he);
          }
          return Te && We ? l.apply(this, L) : (Re = this.thru(ne), Te ? x ? Re.value()[0] : Re.value() : Re);
        });
      }), Pn(["pop", "push", "shift", "sort", "splice", "unshift"], function(l) {
        var u = Kl[l], g = /^(?:push|sort|unshift)$/.test(l) ? "tap" : "thru", x = /^(?:pop|shift)$/.test(l);
        M.prototype[l] = function() {
          var S = arguments;
          if (x && !this.__chain__) {
            var E = this.value();
            return u.apply(Fe(E) ? E : [], S);
          }
          return this[g](function(I) {
            return u.apply(Fe(I) ? I : [], S);
          });
        };
      }), vr(Xe.prototype, function(l, u) {
        var g = M[u];
        if (g) {
          var x = g.name + "";
          st.call(Jo, x) || (Jo[x] = []), Jo[x].push({ name: u, func: g });
        }
      }), Jo[fc(n, $).name] = [{
        name: "wrapper",
        func: n
      }], Xe.prototype.clone = Q7, Xe.prototype.reverse = J7, Xe.prototype.value = eS, M.prototype.at = RA, M.prototype.chain = EA, M.prototype.commit = OA, M.prototype.next = DA, M.prototype.plant = _A, M.prototype.reverse = LA, M.prototype.toJSON = M.prototype.valueOf = M.prototype.value = BA, M.prototype.first = M.prototype.head, la && (M.prototype[la] = IA), M;
    }, Xo = O7();
    eo ? ((eo.exports = Xo)._ = Xo, _f._ = Xo) : Gt._ = Xo;
  }).call(Ra);
})(vh, vh.exports);
var qte = vh.exports;
const _l = (t, e) => {
  const n = C.createContext(e), r = (o) => {
    const { children: s, ...a } = o, c = C.useMemo(() => a, Object.values(a));
    return /* @__PURE__ */ m(n.Provider, { value: c, children: s });
  };
  function i(o) {
    const s = C.useContext(n);
    if (s)
      return s;
    if (e !== void 0)
      return e;
    throw new Error(`\`${o}\` must be used within \`${t}\``);
  }
  return r.displayName = `${t}Provider`, [r, i];
};
function sX(t, e) {
  return typeof t == "string" ? !1 : e in t;
}
function Eu(t, e, n) {
  return t && e && sX(t, e) ? t[e] : n;
}
const Rw = {
  padding: ["padding-block-start", "padding-inline-end", "padding-block-end", "padding-inline-start"],
  paddingTop: "padding-block-start",
  paddingRight: "padding-inline-end",
  paddingBottom: "padding-block-end",
  paddingLeft: "padding-inline-start",
  margin: ["margin-block-start", "margin-inline-end", "margin-block-end", "margin-inline-start"],
  marginLeft: "margin-inline-start",
  marginRight: "margin-inline-end",
  marginTop: "margin-block-start",
  marginBottom: "margin-block-end",
  borderRadius: "border-radius",
  borderStyle: "border-style",
  borderWidth: "border-width",
  borderColor: "border-color",
  fontSize: "font-size",
  fontWeight: "font-weight",
  lineHeight: "line-height",
  zIndex: "z-index",
  boxShadow: "box-shadow",
  pointerEvents: "pointer-events",
  textAlign: "text-align",
  textTransform: "text-transform",
  textDecoration: "text-decoration",
  flexGrow: "flex-grow",
  flexShrink: "flex-shrink",
  flexBasis: "flex-basis",
  minWidth: "min-width",
  maxWidth: "max-width",
  minHeight: "min-height",
  maxHeight: "max-height",
  flexDirection: "flex-direction",
  flexWrap: "flex-wrap",
  justifyContent: "justify-content",
  alignItems: "align-items"
}, aX = (t) => {
  const [e, n, r, i] = t, o = n ?? e;
  return [e, o, r ?? e, i ?? o];
};
function lX(t, e) {
  switch (t) {
    case "gap":
    case "padding":
    case "margin":
    case "paddingTop":
    case "paddingLeft":
    case "paddingRight":
    case "paddingBottom":
    case "marginTop":
    case "marginLeft":
    case "marginRight":
    case "marginBottom":
    case "left":
    case "right":
    case "top":
    case "bottom":
    case "width":
    case "maxWidth":
    case "minWidth":
    case "height":
    case "maxHeight":
    case "minHeight":
    case "borderRadius":
    case "borderWidth":
      return e.spaces;
    case "color":
    case "background":
    case "borderColor":
      return e.colors;
    case "fontSize":
      return e.fontSizes;
    case "fontWeight":
      return e.fontWeights;
    case "lineHeight":
      return e.lineHeights;
    case "zIndex":
      return e.zIndices;
    case "boxShadow":
      return e.shadows;
    default:
      return null;
  }
}
const uf = (t, e) => {
  const n = Object.entries(t).reduce(
    (r, i) => {
      const [o, s] = i, a = lX(o, e), c = Object.prototype.hasOwnProperty.call(Rw, o) ? Rw[o] : o;
      return c && (s || s === 0) && (typeof s == "object" && !Array.isArray(s) ? Object.entries(s).forEach(([h, f]) => {
        r[h] = {
          ...r[h],
          ...Ew(c, f, a)
        };
      }) : r.initial = {
        ...r.initial,
        ...Ew(c, s, a)
      }), r;
    },
    {
      initial: {},
      small: {},
      medium: {},
      large: {}
    }
  );
  return Object.entries(n).reduce((r, [i, o]) => {
    if (o && Object.keys(o).length > 0) {
      const s = Object.entries(o).reduce((a, [c, h]) => (a.push(`${c}: ${h};`), a), []).join(`
`);
      i === "initial" ? r.push(s) : r.push(`${e.breakpoints[i]}{ ${s} }`);
    }
    return r;
  }, []).join(`
`);
}, Ew = (t, e, n) => {
  if (Array.isArray(t) && Array.isArray(e)) {
    const r = aX(e);
    return t.reduce((i, o, s) => (i[o] = Eu(n, r[s], r[s]), i), {});
  } else return Array.isArray(t) && !Array.isArray(e) ? t.reduce((r, i) => (r[i] = Eu(n, e, e), r), {}) : !Array.isArray(t) && !Array.isArray(e) ? {
    [t]: Eu(n, e, e)
  } : (console.warn(
    "You've passed an array of values to a property that does not support it. Please check the property and value you're passing."
  ), {});
}, gn = C.forwardRef, $e = gn((t, e) => {
  const {
    background: n,
    basis: r,
    borderColor: i,
    color: o,
    flex: s,
    fontSize: a,
    grow: c,
    hasRadius: h,
    padding: f,
    paddingBottom: d,
    paddingLeft: p,
    paddingRight: v,
    paddingTop: w,
    margin: b,
    marginLeft: y,
    marginBottom: $,
    marginRight: A,
    marginTop: k,
    shadow: T,
    shrink: R,
    lineHeight: _,
    fontWeight: D,
    width: P,
    minWidth: H,
    maxWidth: z,
    height: j,
    minHeight: K,
    maxHeight: te,
    top: ee,
    left: re,
    bottom: de,
    right: ie,
    borderRadius: se,
    borderStyle: X,
    borderWidth: ce,
    tag: be,
    pointerEvents: Le,
    display: Ae,
    position: qe,
    zIndex: He,
    overflow: Ze,
    cursor: xe,
    transition: Ve,
    transform: Oe,
    animation: Ue,
    textAlign: Ee,
    textTransform: je,
    ...Rt
  } = t;
  return /* @__PURE__ */ m(cX, { as: be || "div", ref: e, ...{
    $background: n,
    $basis: r,
    $borderColor: i,
    $color: o,
    $flex: s,
    $fontSize: a,
    $grow: c,
    $hasRadius: h,
    $padding: f,
    $paddingBottom: d,
    $paddingLeft: p,
    $paddingRight: v,
    $paddingTop: w,
    $margin: b,
    $marginLeft: y,
    $marginBottom: $,
    $marginRight: A,
    $marginTop: k,
    $shadow: T,
    $shrink: R,
    $lineHeight: _,
    $fontWeight: D,
    $width: P,
    $minWidth: H,
    $maxWidth: z,
    $height: j,
    $minHeight: K,
    $maxHeight: te,
    $top: ee,
    $left: re,
    $bottom: de,
    $right: ie,
    $borderRadius: se,
    $borderStyle: X,
    $borderWidth: ce,
    $pointerEvents: Le,
    $display: Ae,
    $position: qe,
    $zIndex: He,
    $overflow: Ze,
    $cursor: xe,
    $transition: Ve,
    $transform: Oe,
    $animation: Ue,
    $textAlign: Ee,
    $textTransform: je
  }, ...Rt });
}), cX = W.div`
  ${({ theme: t, ...e }) => uf(
  {
    padding: e.$padding,
    paddingTop: e.$paddingTop,
    paddingBottom: e.$paddingBottom,
    paddingLeft: e.$paddingLeft,
    paddingRight: e.$paddingRight,
    margin: e.$margin,
    marginTop: e.$marginTop,
    marginBottom: e.$marginBottom,
    marginLeft: e.$marginLeft,
    marginRight: e.$marginRight,
    top: e.$top,
    left: e.$left,
    bottom: e.$bottom,
    right: e.$right,
    width: e.$width,
    minWidth: e.$minWidth,
    maxWidth: e.$maxWidth,
    height: e.$height,
    minHeight: e.$minHeight,
    maxHeight: e.$maxHeight,
    color: e.$color,
    background: e.$background,
    fontSize: e.$fontSize,
    fontWeight: e.$fontWeight,
    lineHeight: e.$lineHeight,
    borderRadius: e.$hasRadius ? t.borderRadius : e.$borderRadius,
    borderStyle: e.$borderColor && !e.$borderStyle ? "solid" : e.$borderStyle,
    borderWidth: e.$borderColor && !e.$borderWidth ? "1px" : e.$borderWidth,
    borderColor: e.$borderColor,
    zIndex: e.$zIndex,
    boxShadow: e.$shadow,
    display: e.$display,
    pointerEvents: e.$pointerEvents,
    cursor: e.$cursor,
    textAlign: e.$textAlign,
    textTransform: e.$textTransform,
    transition: e.$transition,
    transform: e.$transform,
    animation: e.$animation,
    position: e.$position,
    overflow: e.$overflow,
    flex: e.$flex,
    flexShrink: e.$shrink,
    flexGrow: e.$grow,
    flexBasis: e.$basis
  },
  t
)};
`, ge = gn((t, e) => {
  const { className: n, alignItems: r, direction: i, inline: o, gap: s, justifyContent: a, wrap: c, ...h } = t;
  return /* @__PURE__ */ m(uX, { className: n, ref: e, ...{
    $alignItems: r,
    $direction: i,
    $gap: s,
    $justifyContent: a,
    $wrap: c,
    $inline: o
  }, ...h });
}), uX = W($e)`
  ${({ theme: t, $display: e = "flex", $alignItems: n = "center", $direction: r = "row", ...i }) => uf(
  {
    gap: i.$gap,
    alignItems: n,
    justifyContent: i.$justifyContent,
    flexWrap: i.$wrap,
    flexDirection: r,
    display: i.$inline ? "inline-flex" : e
  },
  t
)};
`, hX = "alpha", fX = "beta", dX = "delta", gX = "epsilon", Ow = "omega", pX = "pi", mX = "sigma", f$ = Ie`
  display: block;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
`, vX = ({ $variant: t = Ow, theme: e }) => {
  switch (t) {
    case hX:
      return `
        font-weight: ${e.fontWeights.bold};
        font-size: ${e.fontSizes[5]};
        line-height: ${e.lineHeights[2]};
      `;
    case fX:
      return `
        font-weight: ${e.fontWeights.bold};
        font-size: ${e.fontSizes[4]};
        line-height: ${e.lineHeights[1]};
      `;
    case dX:
      return `
        font-weight: ${e.fontWeights.semiBold};
        font-size: ${e.fontSizes[3]};
        line-height: ${e.lineHeights[2]};
      `;
    case gX:
      return `
        font-size: ${e.fontSizes[3]};
        line-height: ${e.lineHeights[6]};
      `;
    case Ow:
      return `
        font-size: ${e.fontSizes[2]};
        line-height: ${e.lineHeights[4]};
      `;
    case pX:
      return `
        font-size: ${e.fontSizes[1]};
        line-height: ${e.lineHeights[3]};
      `;
    case mX:
      return `
        font-weight: ${e.fontWeights.bold};
        font-size: ${e.fontSizes[0]};
        line-height: ${e.lineHeights[5]};
        text-transform: uppercase;
      `;
    default:
      return `
        font-size: ${e.fontSizes[2]};
      `;
  }
}, _e = gn(
  (t, e) => {
    const {
      ellipsis: n,
      textColor: r = "currentcolor",
      textDecoration: i,
      textTransform: o,
      variant: s,
      lineHeight: a,
      fontWeight: c,
      fontSize: h,
      ...f
    } = t;
    return /* @__PURE__ */ m(bX, { ref: e, tag: "span", ...{
      $ellipsis: n,
      $textColor: r,
      $textDecoration: i,
      $textTransform: o,
      $variant: s,
      $lineHeight: a,
      $fontWeight: c,
      $fontSize: h
    }, ...f });
  }
), bX = W($e)`
  ${vX}
  ${({ $ellipsis: t }) => t ? f$ : ""}

  ${({ theme: t, ...e }) => uf(
  {
    color: e.$textColor,
    textDecoration: e.$textDecoration,
    textTransform: e.$textTransform,
    lineHeight: e.$lineHeight,
    fontWeight: e.$fontWeight,
    fontSize: e.$fontSize
  },
  t
)}
`, [wX, nm] = _l("Accordion"), xX = C.forwardRef(({ children: t, size: e = "S", ...n }, r) => /* @__PURE__ */ m(yX, { ref: r, $size: e, collapsible: !0, ...n, type: "single", children: /* @__PURE__ */ m(wX, { size: e, children: t }) })), yX = W(DI)`
  background-color: ${(t) => t.theme.colors.neutral0};

  ${(t) => t.$size === "S" ? Ie`
        border-radius: ${(e) => e.theme.borderRadius};
        border: solid 1px ${(e) => e.theme.colors.neutral200};
      ` : Ie``}
`, CX = C.forwardRef((t, e) => {
  const { size: n } = nm("Item");
  return /* @__PURE__ */ m($X, { $size: n, "data-size": n, ref: e, ...t });
}), $X = W(II)`
  overflow: hidden;
  margin: 1px 0;

  &:first-child {
    border-top-left-radius: 0.3rem;
    border-top-right-radius: 0.3rem;
    margin-top: 0;
  }

  &:last-child {
    border-bottom-left-radius: 0.3rem;
    border-bottom-right-radius: 0.3rem;
    margin-bottom: 0;
  }

  &[data-size='S'] {
    & + & {
      border-top: solid 1px ${(t) => t.theme.colors.neutral200};
    }
  }

  &[data-state='open'] {
    box-shadow: 0 0 0 1px ${(t) => t.theme.colors.primary600};
  }

  &:not([data-disabled]):hover {
    box-shadow: 0 0 0 1px ${(t) => t.theme.colors.primary600};
  }

  /* This applies our desired focus effect correctly. */
  &:focus-within {
    position: relative;
    z-index: 1;
    box-shadow: 0 0 0 1px ${(t) => t.theme.colors.primary600};
  }

  @media (prefers-reduced-motion: no-preference) {
    transition: box-shadow ${(t) => t.theme.motion.timings[120]}
      ${(t) => t.theme.motion.easings.easeOutQuad};
  }
`, SX = C.forwardRef(
  ({ caretPosition: t = "left", description: e, icon: n, iconProps: r, children: i, ...o }, s) => {
    const { size: a } = nm("Trigger");
    return /* @__PURE__ */ ae(g$, { $caretPosition: t, $size: a, ref: s, ...o, children: [
      t === "left" ? /* @__PURE__ */ m(bh, { $size: a, children: /* @__PURE__ */ m(Wi, { width: a === "S" ? "1.2rem" : "1.6rem", height: a === "S" ? "1.2rem" : "1.6rem" }) }) : null,
      /* @__PURE__ */ ae(ge, { tag: "span", gap: 2, overflow: "hidden", children: [
        n && a === "S" ? /* @__PURE__ */ m(d$, { children: /* @__PURE__ */ m(n, { ...r }) }) : null,
        /* @__PURE__ */ ae(ge, { alignItems: "flex-start", direction: "column", tag: "span", ref: s, overflow: "hidden", children: [
          /* @__PURE__ */ m(
            _e,
            {
              fontWeight: a === "S" ? "bold" : void 0,
              ellipsis: !0,
              variant: a === "M" ? "delta" : void 0,
              textAlign: "left",
              width: "100%",
              children: i
            }
          ),
          e && a === "M" ? /* @__PURE__ */ m(_e, { textAlign: "left", children: e }) : null
        ] })
      ] }),
      t === "right" ? /* @__PURE__ */ m(bh, { $size: a, children: /* @__PURE__ */ m(Wi, { width: a === "S" ? "1.2rem" : "1.6rem", height: a === "S" ? "1.2rem" : "1.6rem" }) }) : null
    ] });
  }
), d$ = W($e)`
  color: ${(t) => t.theme.colors.neutral500};
  display: flex;

  @media (prefers-reduced-motion: no-preference) {
    transition: ${(t) => t.theme.transitions.color};
  }
`, bh = W(ge).attrs((t) => ({
  ...t,
  tag: "span"
}))`
  background-color: ${(t) => t.theme.colors.neutral200};
  width: ${(t) => t.$size === "S" ? "2.4rem" : "3.2rem"};
  height: ${(t) => t.$size === "S" ? "2.4rem" : "3.2rem"};
  flex: ${(t) => t.$size === "S" ? "0 0 2.4rem" : "0 0 3.2rem"};
  border-radius: 50%;
  justify-content: center;

  @media (prefers-reduced-motion: no-preference) {
    transition:
      transform ${(t) => t.theme.motion.timings[200]} ${(t) => t.theme.motion.easings.authenticMotion},
      ${(t) => t.theme.transitions.backgroundColor};
  }
`, g$ = W(LI)`
  display: flex;
  align-items: center;
  justify-content: ${(t) => t.$caretPosition === "left" ? "flex-start" : "space-between"};
  width: 100%;
  gap: ${(t) => t.theme.spaces[4]};
  padding-inline: ${(t) => t.$size === "S" ? t.theme.spaces[4] : t.theme.spaces[6]};
  padding-block: ${(t) => t.$size === "S" ? t.theme.spaces[3] : t.theme.spaces[6]};
  cursor: pointer;
  color: ${(t) => t.theme.colors.neutral800};
  overflow: hidden;

  &[data-disabled] {
    cursor: default;
    color: ${(t) => t.theme.colors.neutral600};
  }

  &[data-state='open'] > ${bh} {
    transform: rotate(180deg);
  }

  /* we remove the default focus because the entire item should have the focus style and the default would be hidden. */
  &:focus-visible {
    outline: none;
  }

  @media (prefers-reduced-motion: no-preference) {
    transition: ${(t) => t.theme.transitions.color};
  }
`, AX = C.forwardRef((t, e) => {
  const { size: n } = nm("Trigger");
  return /* @__PURE__ */ m(p$, { $size: n, ...t, ref: e });
}), p$ = W(ge).attrs((t) => ({
  ...t,
  tag: "span"
}))`
  padding-inline: ${(t) => t.$size === "S" ? t.theme.spaces[2] : t.theme.spaces[6]};
  padding-block: ${(t) => t.$size === "S" ? t.theme.spaces[2] : t.theme.spaces[6]};

  // Remove default IconButton styles so there are no backgrounds or borders.
  & > button {
    border: none;
    background: none;
    color: ${(t) => t.theme.colors.neutral600};

    @media (prefers-reduced-motion: no-preference) {
      transition: ${(t) => t.theme.transitions.color};
    }
  }
`, kX = C.forwardRef(({ variant: t = "primary", ...e }, n) => /* @__PURE__ */ m(MX, { $variant: t, ref: n, ...e })), MX = W(_I)`
  display: flex;
  align-items: center;
  background-color: ${(t) => t.$variant === "primary" ? t.theme.colors.neutral0 : t.theme.colors.neutral100};

  &[data-disabled] {
    background-color: ${(t) => t.theme.colors.neutral150};
  }

  &:not([data-disabled]) {
    &:hover,
    &[data-state='open'] {
      background-color: ${(t) => t.theme.colors.primary100};

      & > ${g$} {
        color: ${(t) => t.theme.colors.primary600};

        & ${d$} {
          color: ${(t) => t.theme.colors.primary600};
        }

        & ${bh} {
          background-color: ${(t) => t.theme.colors.primary200};
        }
      }

      & > ${p$} > button {
        color: ${(t) => t.theme.colors.primary600};
      }
    }
  }

  @media (prefers-reduced-motion: no-preference) {
    transition: ${(t) => t.theme.transitions.backgroundColor};
  }
`, TX = C.forwardRef((t, e) => /* @__PURE__ */ m(OX, { ref: e, ...t })), RX = tn`
  from {
    height: 0;
  }
  to {
    height: var(--radix-accordion-content-height);
  }
`, EX = tn`
  from {
    height: var(--radix-accordion-content-height);
  }
  to {
    height: 0;
  }
`, OX = W(BI)`
  overflow: hidden;

  @media (prefers-reduced-motion: no-preference) {
    &[data-state='open'] {
      animation: ${RX} ${(t) => t.theme.motion.timings[320]}
        ${(t) => t.theme.motion.easings.authenticMotion};
    }

    &[data-state='closed'] {
      animation: ${EX} ${(t) => t.theme.motion.timings[320]}
        ${(t) => t.theme.motion.easings.authenticMotion};
    }
  }
`, Gte = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Actions: AX,
  Content: TX,
  Header: kX,
  Item: CX,
  Root: xX,
  Trigger: SX
}, Symbol.toStringTag, { value: "Module" })), hf = Ie`
  position: relative;
  outline: none;

  &:after {
    transition-property: all;
    transition-duration: 0.2s;
    border-radius: 8px;
    content: '';
    position: absolute;
    top: -4px;
    bottom: -4px;
    left: -4px;
    right: -4px;
    border: 2px solid transparent;
  }

  &:focus-visible {
    outline: none;

    &:after {
      border-radius: 8px;
      content: '';
      position: absolute;
      top: -5px;
      bottom: -5px;
      left: -5px;
      right: -5px;
      border: 2px solid ${(t) => t.theme.colors.primary600};
    }
  }
`, zo = ({ tag: t, ...e }) => /* @__PURE__ */ m(DX, { ...e, as: t || "span" }), DX = W.span`
  border: 0;
  clip: rect(0 0 0 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
`, Ks = ({ children: t, label: e }) => {
  const n = C.Children.only(t);
  return /* @__PURE__ */ ae(Gs, { children: [
    C.cloneElement(n, {
      // accessibility
      "aria-hidden": "true",
      focusable: "false"
      // See: https://allyjs.io/tutorials/focusing-in-svg.html#making-svg-elements-focusable
    }),
    /* @__PURE__ */ m(zo, { children: e })
  ] });
};
Ks.displayName = "AccessibleIcon";
const m$ = (t) => {
  switch (t) {
    case "danger":
      return "danger100";
    case "success":
      return "success100";
    case "warning":
      return "warning100";
    default:
      return "primary100";
  }
}, IX = (t) => m$(t).replace("100", "200"), cg = ({ theme: t, $variant: e }) => e === "danger" ? t.colors.danger700 : e === "success" ? t.colors.success700 : e === "warning" ? t.colors.warning700 : t.colors.primary700, _X = W($e)`
  ${hf};
`, LX = W(ge)`
  svg {
    height: 100%;
    width: 100%;

    path {
      fill: ${cg};
    }
  }
`, BX = ({ variant: t, ...e }) => t === "success" ? /* @__PURE__ */ m(w_, { ...e }) : t === "danger" || t === "warning" ? /* @__PURE__ */ m(_N, { ...e }) : /* @__PURE__ */ m(WL, { ...e }), NX = W($e)`
  & a > span {
    color: ${cg};
  }

  svg path {
    fill: ${cg};
  }
`, Yte = ({
  title: t,
  children: e,
  variant: n = "default",
  onClose: r,
  closeLabel: i,
  titleAs: o = "p",
  action: s,
  ...a
}) => /* @__PURE__ */ ae(
  ge,
  {
    alignItems: "flex-start",
    background: m$(n),
    borderColor: IX(n),
    shadow: "filterShadow",
    gap: 3,
    hasRadius: !0,
    padding: 5,
    paddingRight: 6,
    ...a,
    children: [
      /* @__PURE__ */ m(LX, { height: "2rem", shrink: 0, $variant: n, width: "2rem", children: /* @__PURE__ */ m(BX, { "aria-hidden": !0, variant: n }) }),
      /* @__PURE__ */ ae(
        ge,
        {
          alignItems: "start",
          gap: s ? 2 : 1,
          wrap: "wrap",
          role: n === "danger" ? "alert" : "status",
          width: "100%",
          children: [
            t && /* @__PURE__ */ m(_e, { fontWeight: "bold", textColor: "neutral800", tag: o, children: t }),
            /* @__PURE__ */ m(_e, { tag: "p", textColor: "neutral800", children: e }),
            s && /* @__PURE__ */ m(NX, { $variant: n, children: s })
          ]
        }
      ),
      /* @__PURE__ */ m(
        _X,
        {
          tag: "button",
          background: "transparent",
          borderColor: void 0,
          height: "1.6rem",
          width: "1.6rem",
          marginTop: 1,
          onClick: r,
          color: "neutral700",
          children: /* @__PURE__ */ m(Ks, { label: i, children: /* @__PURE__ */ m(Vo, {}) })
        }
      )
    ]
  }
);
function Or({ prop: t, defaultProp: e, onChange: n = () => {
} }) {
  const [r, i] = v$({ defaultProp: e, onChange: n }), o = t !== void 0, s = o ? t : r, a = Ot(n), c = C.useCallback(
    (h) => {
      if (o) {
        const d = typeof h == "function" ? h(t) : h;
        d !== t && a(d);
      } else
        i(h);
    },
    [o, t, i, a]
  );
  return [s, c];
}
function v$({ defaultProp: t, onChange: e }) {
  const n = C.useState(t), [r] = n, i = C.useRef(r), o = Ot(e);
  return C.useEffect(() => {
    i.current !== r && (o(r), i.current = r);
  }, [r, i, o]), n;
}
const ug = {
  easeInSine: "cubic-bezier(0.47, 0, 0.745, 0.715)",
  easeOutSine: "cubic-bezier(0.39, 0.575, 0.565, 1)",
  easeInOutSine: "cubic-bezier(0.39, 0.575, 0.565, 1)",
  easeInQuad: "cubic-bezier(0.55, 0.085, 0.68, 0.53)",
  easeOutQuad: "cubic-bezier(0.25, 0.46, 0.45, 0.94)",
  easeInOutQuad: "cubic-bezier(0.25, 0.46, 0.45, 0.94)",
  easeInCubic: "cubic-bezier(0.55, 0.055, 0.675, 0.19)",
  easeOutCubic: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  easeInOutCubic: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  easeInQuart: "cubic-bezier(0.895, 0.03, 0.685, 0.22)",
  easeOutQuart: "cubic-bezier(0.165, 0.84, 0.44, 1)",
  easeInOutQuart: "cubic-bezier(0.165, 0.84, 0.44, 1)",
  easeInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
  easeOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  easeInOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  easeInExpo: "cubic-bezier(0.95, 0.05, 0.795, 0.035)",
  easeOutExpo: "cubic-bezier(0.19, 1, 0.22, 1)",
  easeInOutExpo: "cubic-bezier(0.19, 1, 0.22, 1)",
  easeInCirc: "cubic-bezier(0.6, 0.04, 0.98, 0.335)",
  easeOutCirc: "cubic-bezier(0.075, 0.82, 0.165, 1)",
  easeInOutCirc: "cubic-bezier(0.075, 0.82, 0.165, 1)",
  easeInBack: "cubic-bezier(0.6, -0.28, 0.735, 0.045)",
  easeOutBack: "cubic-bezier(0.175, 0.885, 0.32, 1.275)",
  easeInOutBack: "cubic-bezier(0.68, -0.55, 0.265, 1.55)",
  easeInOutFast: "cubic-bezier(1,0,0,1)",
  authenticMotion: "cubic-bezier(.4,0,.2,1)"
}, hg = {
  320: "320ms",
  200: "200ms",
  120: "120ms"
}, FX = {
  color: `color ${hg[120]} ${ug.easeOutQuad}`,
  backgroundColor: `background-color ${hg[120]} ${ug.easeOutQuad}`
}, kt = {
  overlayFadeIn: tn`
    from {
      opacity: 0;
    }
    to {
      opacity: 0.2;
    }
  `,
  modalPopIn: tn`
    from {
      transform:translate(-50%, -50%)  scale(0.8);
      opacity: 0;
    }
    to {
      transform: translate(-50%, -50%) scale(1);
      opacity: 1;
    }
  `,
  modalPopOut: tn`
    from {
      transform: translate(-50%, -50%) scale(1);
      opacity: 1;
    }
    to {
      transform:translate(-50%, -50%)  scale(0.8);
      opacity: 0;
    }
  `,
  popIn: tn`
    from {
      transform: scale(0.8);
      opacity: 0;
    }
    to {
      transform: scale(1);
      opacity: 1;
    }
  `,
  popOut: tn`
    from {
      transform: scale(1);
      opacity: 1;
    }
    to {
      transform: scale(0.8);
      opacity: 0;
    }
  `,
  slideDownIn: tn`
    from {
      opacity: 0;
      transform: translateY(-10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  `,
  slideDownOut: tn`
    from {
      opacity: 1;
      transform: translateY(0);
    }
    to {
      opacity: 0;
      transform: translateY(-10px);
    }
  `,
  slideUpIn: tn`
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  `,
  slideUpOut: tn`
    from {
      opacity: 1;
      transform: translateY(0);
    }
    to {
      opacity: 0;
      transform: translateY(10px);
    }
  `,
  fadeIn: tn`
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  `,
  fadeOut: tn`
    from {
      opacity: 1;
    }
    to {
      opacity: 0;
    }
  `
}, gl = 32, Dw = 2, VX = C.forwardRef(
  ({ onLoadingStatusChange: t, delayMs: e = 600, src: n, alt: r, fallback: i, preview: o = !1, ...s }, a) => {
    const [c, h] = Or({
      onChange: t
    }), [f, d] = C.useState(!1), p = o && c === "loaded";
    return /* @__PURE__ */ ae(P3, { onOpenChange: (w) => {
      p && d(w);
    }, children: [
      /* @__PURE__ */ m(W3, { asChild: !0, children: /* @__PURE__ */ ae(fg, { ref: a, ...s, children: [
        p ? /* @__PURE__ */ m(
          HX,
          {
            width: "100%",
            height: "100%",
            position: "absolute",
            background: "neutral0",
            zIndex: "overlay",
            style: { opacity: f ? 0.4 : 0 }
          }
        ) : null,
        /* @__PURE__ */ m(PX, { src: n, alt: r, onLoadingStatusChange: h }),
        /* @__PURE__ */ m(qN, { delayMs: e, children: /* @__PURE__ */ m(_e, { fontWeight: "bold", textTransform: "uppercase", children: i }) })
      ] }) }),
      p ? /* @__PURE__ */ m(z3, { children: /* @__PURE__ */ m(WX, { side: "top", sideOffset: 4, children: /* @__PURE__ */ m(zX, { src: n, alt: r }) }) }) : null
    ] });
  }
), b$ = Ie`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  vertical-align: middle;
  overflow: hidden;
  user-select: none;
  overflow: hidden;
  border-radius: 50%;
`, w$ = Ie`
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: inherit;
`, fg = W(UN)`
  position: relative;
  z-index: 0;
  ${b$}
  width: ${gl / 10}rem;
  height: ${gl / 10}rem;
  /* TODO: we should get the user email & hash it to turn it into a hex-value so different emails can consistently get a different background */
  background-color: ${(t) => t.theme.colors.primary600};
  color: ${(t) => t.theme.colors.neutral0};
`, HX = W($e)`
  @media (prefers-reduced-motion: no-preference) {
    transition: opacity ${(t) => t.theme.motion.timings[200]}
      ${(t) => t.theme.motion.easings.authenticMotion};
  }
`, PX = W(KN)`
  ${w$}
`, WX = W(U3)`
  ${b$}
  width: ${gl * Dw / 10}rem;
  height: ${gl * Dw / 10}rem;

  @media (prefers-reduced-motion: no-preference) {
    animation: ${kt.fadeIn} ${(t) => t.theme.motion.timings[200]}
      ${(t) => t.theme.motion.easings.authenticMotion};
  }
`, zX = W.img`
  ${w$}
`, UX = C.forwardRef((t, e) => /* @__PURE__ */ m(KX, { ...t, ref: e, tag: "div" })), KX = W(ge)`
  & > ${fg} + ${fg} {
    margin-left: -${gl / 10 / 2}rem;
  }
`, jte = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Group: UX,
  Item: VX
}, Symbol.toStringTag, { value: "Module" })), x$ = ({
  active: t = !1,
  size: e = "M",
  textColor: n = "neutral600",
  backgroundColor: r = "neutral150",
  children: i,
  minWidth: o = 5,
  ...s
}) => {
  const a = e === "S" ? 1 : 2;
  return /* @__PURE__ */ m(
    qX,
    {
      inline: !0,
      alignItems: "center",
      justifyContent: "center",
      minWidth: o,
      paddingLeft: a,
      paddingRight: a,
      background: t ? "primary200" : r,
      $size: e,
      ...s,
      children: /* @__PURE__ */ m(_e, { variant: "sigma", textColor: t ? "primary600" : n, lineHeight: "1rem", children: i })
    }
  );
}, qX = W(ge)`
  border-radius: ${({ theme: t, $size: e }) => e === "S" ? "2px" : t.borderRadius};
  ${({ $size: t, theme: e }) => t === "S" ? Ie`
        padding-block: 0.3rem;
        padding-inline ${e.spaces[1]}
      ` : Ie`
      padding-block: 0.7rem;
      padding-inline ${e.spaces[2]}
    `};
`, Ll = gn(
  ({ href: t, disabled: e = !1, isExternal: n = !1, ...r }, i) => /* @__PURE__ */ m(
    GX,
    {
      tag: "a",
      ref: i,
      target: n ? "_blank" : void 0,
      rel: n ? "noreferrer noopener" : void 0,
      href: t,
      tabIndex: e ? -1 : void 0,
      "aria-disabled": e,
      pointerEvents: e ? "none" : void 0,
      cursor: e ? void 0 : "pointer",
      ...r
    }
  )
), GX = W($e)`
  text-decoration: none;

  &:visited {
    color: inherit;
  }
`, y$ = () => /* @__PURE__ */ m($e, { "aria-hidden": !0, paddingLeft: 1, paddingRight: 1, children: /* @__PURE__ */ m(_e, { variant: "pi", textColor: "neutral500", children: "/" }) });
y$.displayName = "Divider";
const YX = W(ge)`
  // CrumbLinks do have padding-x, because they need to have a
  // interaction effect, which mis-aligns the breadcrumbs on the left.
  // This normalizes the behavior by moving the first item to left by
  // the same amount it has inner padding
  & > *:first-child {
    margin-left: ${({ theme: t }) => `calc(-1*${t.spaces[2]})`};
  }
`, jX = C.forwardRef(
  ({ label: t, children: e, ...n }, r) => {
    const i = C.Children.toArray(e);
    return /* @__PURE__ */ m($e, { "aria-label": t, tag: "nav", ...n, ref: r, children: /* @__PURE__ */ m(YX, { tag: "ol", children: C.Children.map(i, (o, s) => {
      const a = i.length > 1 && s + 1 < i.length;
      return /* @__PURE__ */ ae(ge, { inline: !0, tag: "li", children: [
        o,
        a && /* @__PURE__ */ m(y$, {})
      ] });
    }) }) });
  }
);
jX.displayName = "Breadcrumbs";
const XX = C.forwardRef(
  ({ children: t, isCurrent: e = !1, ...n }, r) => /* @__PURE__ */ m($e, { paddingLeft: 2, paddingRight: 2, paddingTop: 1, paddingBottom: 1, ref: r, children: /* @__PURE__ */ m(
    _e,
    {
      variant: "pi",
      textColor: "neutral800",
      fontWeight: e ? "bold" : "regular",
      "aria-current": e,
      ...n,
      children: t
    }
  ) })
);
XX.displayName = "Crumb";
const ZX = W(Ll)`
  border-radius: ${({ theme: t }) => t.borderRadius};
  color: ${({ theme: t }) => t.colors.neutral600};
  font-size: ${({ theme: t }) => t.fontSizes[1]};
  line-height: ${({ theme: t }) => t.lineHeights[4]};
  padding: ${({ theme: t }) => `${t.spaces[1]} ${t.spaces[2]}`};
  text-decoration: none;

  :hover,
  :focus {
    background-color: ${({ theme: t }) => t.colors.neutral200};
    color: ${({ theme: t }) => t.colors.neutral700};
  }
`, QX = C.forwardRef(({ children: t, ...e }, n) => /* @__PURE__ */ m(ZX, { ref: n, ...e, children: t }));
QX.displayName = "CrumbLink";
const qs = (t) => t.replaceAll(":", "");
function JX(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e);
}
function C$(...t) {
  return (e) => t.forEach((n) => JX(n, e));
}
function An(...t) {
  return C.useCallback(C$(...t), t);
}
const eZ = () => typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), _o = eZ() ? Ce : yh, tZ = C.useId || (() => {
});
let nZ = 0;
const Vn = (t) => {
  const [e, n] = C.useState(tZ());
  return _o(() => {
    t || n((r) => r ?? String(nZ++));
  }, [t]), t?.toString() ?? (e || "");
}, Bl = (t, e, { selectorToWatch: n, skipWhen: r = !1 }) => {
  const i = Hg(e);
  C.useEffect(() => {
    if (r || !t.current)
      return;
    const o = {
      root: t.current,
      rootMargin: "0px"
    }, s = (h) => {
      h.forEach((f) => {
        f.isIntersecting && t.current && t.current.scrollHeight > t.current.clientHeight && i(f);
      });
    }, a = new IntersectionObserver(s, o), c = t.current.querySelector(n);
    return c && a.observe(c), () => {
      a.disconnect();
    };
  }, [r, i, n, t]);
}, rm = "success-light", im = "danger-light", ff = "default", Nl = "tertiary", Fl = "secondary", $$ = "danger", S$ = "success", df = "ghost", om = [rm, im], rZ = [ff, Nl, Fl, $$, S$, df, ...om], iZ = ["XS", "S", "M", "L"], ir = (t) => t === rm || t === im ? `${t.substring(0, t.lastIndexOf("-"))}` : t === Nl ? "neutral" : t === ff || t === Fl || rZ.every((e) => e !== t) ? "primary" : `${t}`, A$ = ({ theme: t }) => Ie`
    border: 1px solid ${t.colors.neutral200};
    background: ${t.colors.neutral150};
    color: ${t.colors.neutral600};
    cursor: default;
  `, k$ = ({ theme: t, $variant: e }) => [...om, Fl].includes(e) ? Ie`
      background-color: ${t.colors.neutral0};
    ` : e === Nl ? Ie`
      background-color: ${t.colors.neutral100};
    ` : e === df ? Ie`
      background-color: ${t.colors.neutral100};
    ` : e === ff ? Ie`
      border: 1px solid ${t.colors.buttonPrimary500};
      background: ${t.colors.buttonPrimary500};
    ` : Ie`
    border: 1px solid ${t.colors[`${ir(e)}500`]};
    background: ${t.colors[`${ir(e)}500`]};
  `, M$ = ({ theme: t, $variant: e }) => [...om, Fl].includes(e) ? Ie`
      background-color: ${t.colors.neutral0};
      border: 1px solid ${t.colors[`${ir(e)}600`]};
      color: ${t.colors[`${ir(e)}600`]};
    ` : e === Nl || e === df ? Ie`
      background-color: ${t.colors.neutral150};
    ` : Ie`
    border: 1px solid ${t.colors[`${ir(e)}600`]};
    background: ${t.colors[`${ir(e)}600`]};
  `, T$ = ({ theme: t, $variant: e }) => {
  switch (e) {
    case im:
    case rm:
    case Fl:
      return Ie`
        border: 1px solid ${t.colors[`${ir(e)}200`]};
        background: ${t.colors[`${ir(e)}100`]};
        color: ${t.colors[`${ir(e)}700`]};
      `;
    case Nl:
      return Ie`
        border: 1px solid ${t.colors.neutral200};
        background: ${t.colors.neutral0};
        color: ${t.colors.neutral800};
      `;
    case df:
      return Ie`
        border: 1px solid transparent;
        background: transparent;
        color: ${t.colors.neutral800};

        svg {
          fill: ${t.colors.neutral500};
        }
      `;
    case S$:
    case $$:
      return Ie`
        border: 1px solid ${t.colors[`${ir(e)}600`]};
        background: ${t.colors[`${ir(e)}600`]};
        color: ${t.colors.neutral0};
      `;
    default:
      return Ie`
        border: 1px solid ${t.colors.buttonPrimary600};
        background: ${t.colors.buttonPrimary600};
        color: ${t.colors.buttonNeutral0};
      `;
  }
}, dg = gn(
  ({
    variant: t = ff,
    startIcon: e,
    endIcon: n,
    disabled: r = !1,
    children: i,
    onClick: o,
    size: s = iZ[1],
    loading: a = !1,
    fullWidth: c = !1,
    ...h
  }, f) => {
    const d = r || a;
    return /* @__PURE__ */ ae(
      aZ,
      {
        ref: f,
        "aria-disabled": d,
        disabled: d,
        $size: s,
        $variant: t,
        tag: "button",
        onClick: (v) => {
          !d && o && o(v);
        },
        hasRadius: !0,
        gap: 2,
        inline: !0,
        alignItems: "center",
        justifyContent: "center",
        width: c ? "100%" : void 0,
        paddingLeft: 4,
        paddingRight: 4,
        cursor: "pointer",
        ...h,
        children: [
          (e || a) && /* @__PURE__ */ m(ge, { tag: "span", "aria-hidden": !0, children: a ? /* @__PURE__ */ m(sZ, {}) : e }),
          /* @__PURE__ */ m(_e, { variant: s === "S" ? "pi" : void 0, fontWeight: "bold", children: i }),
          n && /* @__PURE__ */ m(ge, { tag: "span", "aria-hidden": !0, children: n })
        ]
      }
    );
  }
), oZ = tn`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(359deg);
  }
`, sZ = W(Hx)`
  animation: ${oZ} 2s infinite linear;
  will-change: transform;
`, aZ = W(ge)`
  height: ${({ theme: t, $size: e }) => t.sizes.button[e]};
  text-decoration: none;
  ${T$}

  &:hover {
    ${k$}
  }

  &:active {
    ${M$}
  }

  &[aria-disabled='true'] {
    ${A$}
  }

  @media (prefers-reduced-motion: no-preference) {
    transition:
      ${(t) => t.theme.transitions.backgroundColor},
      ${(t) => t.theme.transitions.color},
      border-color ${(t) => t.theme.motion.timings[200]} ${(t) => t.theme.motion.easings.easeOutQuad};
  }
`, R$ = C.forwardRef(
  ({
    children: t,
    description: e,
    label: n,
    defaultOpen: r,
    open: i,
    onOpenChange: o,
    delayDuration: s = 500,
    disableHoverableContent: a,
    ...c
  }, h) => !n && !e ? t : /* @__PURE__ */ ae(
    P3,
    {
      defaultOpen: r,
      open: i,
      onOpenChange: o,
      delayDuration: s,
      disableHoverableContent: a,
      children: [
        /* @__PURE__ */ m(W3, { asChild: !0, children: t }),
        /* @__PURE__ */ m(z3, { children: /* @__PURE__ */ m(lZ, { ref: h, sideOffset: 8, ...c, children: /* @__PURE__ */ m(_e, { variant: "pi", fontWeight: "bold", children: n || e }) }) })
      ]
    }
  )
), lZ = W(U3)`
  background-color: ${(t) => t.theme.colors.neutral900};
  color: ${(t) => t.theme.colors.neutral0};
  padding-inline: ${(t) => t.theme.spaces[2]};
  padding-block: ${(t) => t.theme.spaces[2]};
  border-radius: ${(t) => t.theme.borderRadius};
  z-index: ${(t) => t.theme.zIndices.tooltip};
  will-change: opacity;
  transform-origin: var(--radix-tooltip-content-transform-origin);

  @media (prefers-reduced-motion: no-preference) {
    animation: ${kt.fadeIn} ${(t) => t.theme.motion.timings[200]}
      ${(t) => t.theme.motion.easings.authenticMotion};
  }
`, Lo = gn(
  ({
    label: t,
    background: e,
    children: n,
    disabled: r = !1,
    onClick: i,
    size: o = "S",
    variant: s = "tertiary",
    withTooltip: a = !0,
    ...c
  }, h) => {
    const d = /* @__PURE__ */ m(
      Na,
      {
        "aria-disabled": r,
        background: r ? "neutral150" : e,
        tag: "button",
        display: "inline-flex",
        justifyContent: "center",
        hasRadius: !0,
        cursor: "pointer",
        ...c,
        ref: h,
        $size: o,
        onClick: (p) => {
          !r && i && i(p);
        },
        $variant: s,
        children: /* @__PURE__ */ m(Ks, { label: t, children: n })
      }
    );
    return a ? /* @__PURE__ */ m(R$, { label: t, children: d }) : d;
  }
), Na = W(ge)`
  text-decoration: none;

  ${(t) => {
  switch (t.$size) {
    case "XS":
      return Ie`
          padding-block: 0.25rem;
          padding-inline: 0.25rem;
        `;
    case "S":
      return Ie`
          padding-block: 0.7rem;
          padding-inline: 0.7rem;
        `;
    case "M":
      return Ie`
          padding-block: 0.9rem;
          padding-inline: 0.9rem;
        `;
    case "L":
      return Ie`
          padding-block: 1.1rem;
          padding-inline: 1.1rem;
        `;
  }
}}
  ${T$}
  ${(t) => t.$variant === "tertiary" ? Ie`
          color: ${t.theme.colors.neutral500};
        ` : ""}

  &:hover {
    ${k$}
    ${(t) => t.$variant === "tertiary" ? Ie`
            color: ${t.theme.colors.neutral600};
          ` : ""}
  }

  &:active {
    ${M$}
  }

  &[aria-disabled='true'] {
    ${A$}
  }

  @media (prefers-reduced-motion: no-preference) {
    transition:
      ${(t) => t.theme.transitions.backgroundColor},
      ${(t) => t.theme.transitions.color},
      border-color ${(t) => t.theme.motion.timings[200]} ${(t) => t.theme.motion.easings.easeOutQuad};
  }
`, Xte = W(ge)`
  & ${Na}:first-child {
    border-radius: ${({ theme: t }) => `${t.borderRadius} 0 0 ${t.borderRadius}`};
  }

  & ${Na}:last-child {
    border-radius: ${({ theme: t }) => `0 ${t.borderRadius} ${t.borderRadius} 0`};
  }

  & ${Na} {
    border-radius: 0;

    & + ${Na} {
      border-left: none;
    }
  }
`, cZ = gn(
  ({ children: t, href: e, disabled: n = !1, startIcon: r, endIcon: i, isExternal: o = !1, ...s }, a) => /* @__PURE__ */ ae(uZ, { ref: a, href: e, disabled: n, isExternal: o, ...s, children: [
    r,
    /* @__PURE__ */ m(_e, { textColor: n ? "neutral600" : "primary600", children: t }),
    i,
    e && !i && o && /* @__PURE__ */ m(sL, {})
  ] })
), uZ = W(Ll)`
  display: inline-flex;
  align-items: center;
  text-decoration: none;
  gap: ${({ theme: t }) => t.spaces[2]};
  pointer-events: ${({ disabled: t }) => t ? "none" : void 0};

  svg {
    font-size: 1rem;

    path {
      fill: ${({ disabled: t, theme: e }) => t ? e.colors.neutral600 : e.colors.primary600};
    }
  }

  &:hover {
    & > span {
      color: ${({ theme: t }) => t.colors.primary500};
    }

    svg path {
      fill: ${({ theme: t }) => t.colors.primary500};
    }
  }

  &:active {
    color: ${({ theme: t }) => t.colors.primary700};
  }

  ${hf};
`, hZ = bV, fZ = C.forwardRef(
  ({ label: t, endIcon: e = /* @__PURE__ */ m(Wi, { width: "1.2rem", height: "1.2rem", "aria-hidden": !0 }), tag: n = dg, icon: r, ...i }, o) => {
    const s = {
      ...i,
      ref: o,
      type: "button"
    };
    return /* @__PURE__ */ m(wV, { asChild: !0, disabled: s.disabled, children: n === Lo ? /* @__PURE__ */ m(Lo, { label: t, variant: "tertiary", ...s, children: r }) : /* @__PURE__ */ m(dg, { endIcon: e, variant: "ghost", ...s }) });
  }
), dZ = C.forwardRef(
  ({ children: t, intersectionId: e, onCloseAutoFocus: n, popoverPlacement: r = "bottom-start", ...i }, o) => {
    const [s, a] = r.split("-");
    return /* @__PURE__ */ m(cy, { children: /* @__PURE__ */ m(gZ, { align: a, side: s, loop: !0, onCloseAutoFocus: n, asChild: !0, children: /* @__PURE__ */ ae(
      E$,
      {
        ref: o,
        direction: "column",
        borderColor: "neutral150",
        hasRadius: !0,
        background: "neutral0",
        shadow: "filterShadow",
        maxHeight: "15rem",
        padding: 1,
        marginTop: 1,
        marginBottom: 1,
        alignItems: "flex-start",
        position: "relative",
        overflow: "auto",
        ...i,
        children: [
          t,
          /* @__PURE__ */ m($e, { id: e, width: "100%", height: "1px" })
        ]
      }
    ) }) });
  }
), E$ = W(ge)`
  scrollbar-width: none;
  -ms-overflow-style: none;
  -webkit-overflow-scrolling: touch;
  z-index: ${(t) => t.theme.zIndices.popover};

  &::-webkit-scrollbar {
    display: none;
  }
`, gZ = W(xV)`
  @media (prefers-reduced-motion: no-preference) {
    animation-duration: ${(t) => t.theme.motion.timings[200]};

    &[data-state='open'] {
      animation-timing-function: ${(t) => t.theme.motion.easings.authenticMotion};

      &[data-side='top'] {
        animation-name: ${kt.slideUpIn};
      }

      &[data-side='bottom'] {
        animation-name: ${kt.slideDownIn};
      }
    }
  }
`, pZ = ({ onSelect: t, disabled: e = !1, isLink: n, startIcon: r, endIcon: i, isExternal: o, ...s }) => /* @__PURE__ */ m(CV, { asChild: !0, onSelect: t, disabled: e, children: n || o ? /* @__PURE__ */ m(
  mZ,
  {
    color: "neutral800",
    startIcon: r,
    endIcon: i,
    ...s,
    isExternal: o ?? !1,
    children: /* @__PURE__ */ m(_e, { children: s.children })
  }
) : /* @__PURE__ */ ae(
  D$,
  {
    cursor: "pointer",
    color: "neutral800",
    background: "transparent",
    borderStyle: "none",
    gap: 2,
    ...s,
    children: [
      r && /* @__PURE__ */ m(ge, { tag: "span", "aria-hidden": !0, children: r }),
      /* @__PURE__ */ m(_e, { grow: 1, children: s.children }),
      i && /* @__PURE__ */ m(ge, { tag: "span", "aria-hidden": !0, children: i })
    ]
  }
) }), O$ = ({ theme: t }) => Ie`
  text-align: left;
  width: 100%;
  border-radius: ${t.borderRadius};
  padding: ${t.spaces[2]} ${t.spaces[4]};

  &[aria-disabled='true'] {
    cursor: not-allowed;
    color: ${t.colors.neutral500};
  }

  &[data-highlighted] {
    background-color: ${t.colors.primary100};
  }

  &:focus-visible {
    outline: none;

    &:after {
      content: none;
    }
  }
`, D$ = W(ge)`
  ${O$}
`, mZ = W(cZ)`
  /* We include this here again because typically when people use OptionLink they provide an as prop which cancels the Box props */
  color: ${({ theme: t, color: e }) => Eu(t.colors, e, void 0)};
  text-decoration: none;

  &:hover {
    color: unset;
  }

  /* TODO: do we need this? */
  svg > path,
  &:focus-visible svg > path {
    fill: currentColor;
  }

  ${O$}
`, vZ = W($e)`
  /* Negative horizontal margin to compensate Menu.Content's padding */
  margin: ${({ theme: t }) => t.spaces[1]} -${({ theme: t }) => t.spaces[1]};
  width: calc(100% + ${({ theme: t }) => t.spaces[2]});
  /* Hide separator if there's nothing above in the menu */
  &:first-child {
    display: none;
  }
`;
C.forwardRef((t, e) => /* @__PURE__ */ m($V, { ...t, asChild: !0, children: /* @__PURE__ */ m(vZ, { height: "1px", shrink: 0, background: "neutral150", ref: e }) }));
C.forwardRef((t, e) => /* @__PURE__ */ m(yV, { asChild: !0, children: /* @__PURE__ */ m(bZ, { ref: e, variant: "sigma", textColor: "neutral600", ...t }) }));
const bZ = W(_e)`
  padding: ${({ theme: t }) => t.spaces[2]} ${({ theme: t }) => t.spaces[4]};
`;
C.forwardRef(({ disabled: t = !1, ...e }, n) => /* @__PURE__ */ m(SV, { asChild: !0, disabled: t, children: /* @__PURE__ */ ae(
  wZ,
  {
    ref: n,
    color: "neutral800",
    tag: "button",
    type: "button",
    background: "transparent",
    borderStyle: "none",
    gap: 5,
    ...e,
    children: [
      /* @__PURE__ */ m(_e, { children: e.children }),
      /* @__PURE__ */ m(up, { fill: "neutral500", height: "1.2rem", width: "1.2rem" })
    ]
  }
) }));
const wZ = W(D$)`
  &[data-state='open'] {
    background-color: ${({ theme: t }) => t.colors.primary100};
  }
`;
C.forwardRef((t, e) => /* @__PURE__ */ m(cy, { children: /* @__PURE__ */ m(AV, { sideOffset: 8, asChild: !0, children: /* @__PURE__ */ m(
  E$,
  {
    ref: e,
    direction: "column",
    borderStyle: "solid",
    borderWidth: "1px",
    borderColor: "neutral150",
    hasRadius: !0,
    background: "neutral0",
    shadow: "filterShadow",
    maxHeight: "15rem",
    padding: 1,
    alignItems: "flex-start",
    overflow: "auto",
    ...t
  }
) }) }));
const xZ = hZ, yZ = fZ, CZ = dZ, $Z = pZ, SZ = C.forwardRef(
  ({ children: t, onOpen: e, onClose: n, popoverPlacement: r, onReachEnd: i, ...o }, s) => {
    const a = C.useRef(null), c = An(s, a), h = C.useRef(null), [f, d] = C.useState(!1), p = (y) => {
      i && i(y);
    }, v = (y) => {
      y && typeof e == "function" ? e() : !y && typeof n == "function" && n(), d(y);
    }, w = Vn(), b = `intersection-${qs(w)}`;
    return Bl(h, p, {
      selectorToWatch: `#${b}`,
      /**
       * We need to know when the select is open because only then will viewportRef
       * not be null. Because it uses a portal that (sensibly) is not mounted 24/7.
       */
      skipWhen: !f
    }), /* @__PURE__ */ ae(xZ, { onOpenChange: v, children: [
      /* @__PURE__ */ m(yZ, { ref: c, ...o, children: o.label }),
      /* @__PURE__ */ m(CZ, { ref: h, intersectionId: b, popoverPlacement: r, children: t })
    ] });
  }
), Zte = $Z, AZ = W(SZ)`
  padding: ${({ theme: t }) => `${t.spaces[1]} ${t.spaces[2]}`};
  height: unset;

  :hover,
  :focus {
    background-color: ${({ theme: t }) => t.colors.neutral200};
  }
`, kZ = C.forwardRef(
  ({ children: t, ...e }, n) => /* @__PURE__ */ m(AZ, { ref: n, endIcon: null, size: "S", ...e, children: t })
);
kZ.displayName = "CrumbSimpleMenu";
const I$ = C.createContext({ id: "" }), MZ = () => C.useContext(I$);
C.forwardRef(({ id: t, ...e }, n) => {
  const r = Vn(t), i = C.useMemo(() => ({ id: r }), [r]);
  return /* @__PURE__ */ m(I$.Provider, { value: i, children: /* @__PURE__ */ m(
    $e,
    {
      ref: n,
      id: t,
      tabIndex: 0,
      hasRadius: !0,
      background: "neutral0",
      borderStyle: "solid",
      borderWidth: "1px",
      borderColor: "neutral150",
      shadow: "tableShadow",
      tag: "article",
      "aria-labelledby": `${r}-title`,
      ...e
    }
  ) });
});
const TZ = C.forwardRef(({ position: t, ...e }, n) => /* @__PURE__ */ m(RZ, { ref: n, $position: t, ...e, direction: "row", gap: 2 })), RZ = W(ge)`
  position: absolute;
  top: ${({ theme: t }) => t.spaces[3]};
  right: ${({ $position: t, theme: e }) => {
  if (t === "end")
    return e.spaces[3];
}};
  left: ${({ $position: t, theme: e }) => {
  if (t === "start")
    return e.spaces[3];
}};
`;
W.img`
  // inline flows is based on typography and displays an extra white space below the image
  // switch to block is required in order to make the img stick the bottom of the container
  // addition infos: https://stackoverflow.com/questions/5804256/image-inside-div-has-extra-space-below-the-image
  margin: 0;
  padding: 0;
  max-height: 100%;
  max-width: 100%;
  object-fit: contain;
`;
W.div`
  display: flex;
  justify-content: center;
  height: ${({ $size: t }) => t === "S" ? "8.8rem" : "16.4rem"};
  width: 100%;
  background: repeating-conic-gradient(${({ theme: t }) => t.colors.neutral100} 0% 25%, transparent 0% 50%) 50% / 20px
    20px;
  border-top-left-radius: ${({ theme: t }) => t.borderRadius};
  border-top-right-radius: ${({ theme: t }) => t.borderRadius};
`;
W.div`
  margin-left: auto;
  flex-shrink: 0;
`;
W(x$)`
  margin-left: ${({ theme: t }) => t.spaces[1]};
`;
const EZ = ({ fill: t, ...e }) => {
  const { colors: n } = V();
  return /* @__PURE__ */ m(
    $e,
    {
      tag: "svg",
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: t ? n[t] : void 0,
      ...e,
      children: /* @__PURE__ */ m("path", { d: "M29.0613 10.0613L13.0613 26.0613C12.9219 26.2011 12.7563 26.3121 12.574 26.3878C12.3917 26.4635 12.1962 26.5024 11.9988 26.5024C11.8013 26.5024 11.6059 26.4635 11.4235 26.3878C11.2412 26.3121 11.0756 26.2011 10.9363 26.0613L3.93626 19.0613C3.79673 18.9217 3.68605 18.7561 3.61053 18.5738C3.53502 18.3915 3.49615 18.1961 3.49615 17.9988C3.49615 17.8014 3.53502 17.606 3.61053 17.4237C3.68605 17.2414 3.79673 17.0758 3.93626 16.9363C4.07579 16.7967 4.24143 16.686 4.42374 16.6105C4.60604 16.535 4.80143 16.4962 4.99876 16.4962C5.19608 16.4962 5.39147 16.535 5.57378 16.6105C5.75608 16.686 5.92173 16.7967 6.06126 16.9363L12 22.875L26.9388 7.93876C27.2205 7.65697 27.6027 7.49866 28.0013 7.49866C28.3998 7.49866 28.782 7.65697 29.0638 7.93876C29.3455 8.22055 29.5039 8.60274 29.5039 9.00126C29.5039 9.39977 29.3455 9.78197 29.0638 10.0638L29.0613 10.0613Z" })
    }
  );
}, Iw = C.forwardRef(
  ({ defaultChecked: t, checked: e, onCheckedChange: n, ...r }, i) => {
    const o = C.useRef(null), [s, a] = Or({
      defaultProp: t,
      prop: e,
      onChange: n
    }), c = An(o, i);
    return /* @__PURE__ */ m(OZ, { ref: c, checked: s, onCheckedChange: a, ...r, children: /* @__PURE__ */ ae(DZ, { forceMount: !0, children: [
      s === !0 ? /* @__PURE__ */ m(EZ, { width: "1.6rem", fill: "neutral0" }) : null,
      s === "indeterminate" ? /* @__PURE__ */ m(fB, { fill: "neutral0" }) : null
    ] }) });
  }
), OZ = W(IV)`
  background: ${(t) => t.theme.colors.neutral0};
  width: 2rem;
  height: 2rem;
  border-radius: ${(t) => t.theme.borderRadius};
  border: 1px solid ${(t) => t.theme.colors.neutral300};
  position: relative;
  z-index: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  // this ensures the checkbox is always a square even in flex-containers.
  flex: 0 0 2rem;

  &[data-state='checked'],
  &[data-state='indeterminate'] {
    border: 1px solid ${(t) => t.theme.colors.primary600};
    background-color: ${(t) => t.theme.colors.primary600};
  }

  &[data-disabled] {
    background-color: ${(t) => t.theme.colors.neutral200};
  }

  /* increase target size for touch devices https://www.w3.org/WAI/WCAG21/Understanding/target-size.html */
  &::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100%;
    height: 100%;
    z-index: -1;
    min-width: 44px;
    min-height: 44px;
  }
`, DZ = W(_V)`
  display: inline-flex;
  pointer-events: auto !important;
  width: 100%;
  height: 100%;
  cursor: pointer;
  justify-content: center;
  align-items: center;

  &[data-disabled] {
    cursor: not-allowed;
  }
`, sm = C.forwardRef(({ children: t, ...e }, n) => {
  const r = Vn(e.id);
  return t ? /* @__PURE__ */ ae(ge, { gap: 2, children: [
    /* @__PURE__ */ m(Iw, { id: r, ...e }),
    /* @__PURE__ */ m(_e, { tag: "label", textColor: "neutral800", htmlFor: r, children: t })
  ] }) : /* @__PURE__ */ m(Iw, { ref: n, ...e });
});
C.forwardRef((t, e) => {
  const { id: n } = MZ();
  return /* @__PURE__ */ m(TZ, { position: "start", children: /* @__PURE__ */ m(sm, { "aria-labelledby": `${n}-title`, ...t, ref: e }) });
});
W($e)`
  word-break: break-all;
`;
W(ge)`
  border-bottom: 1px solid ${({ theme: t }) => t.colors.neutral150};
`;
const Bt = {
  DOWN: "ArrowDown",
  UP: "ArrowUp",
  RIGHT: "ArrowRight",
  LEFT: "ArrowLeft",
  ESCAPE: "Escape",
  ENTER: "Enter",
  TAB: "Tab",
  END: "End",
  HOME: "Home",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown"
}, IZ = W($e)`
  grid-template-columns: auto 1fr auto;
  grid-template-areas: 'startAction slides endAction';
`, _Z = W(ge)`
  grid-area: slides;
`, _w = W($e)`
  grid-area: ${({ $area: t }) => t};

  &:focus svg path,
  &:hover svg path {
    fill: ${({ theme: t }) => t.colors.neutral900};
  }
`, LZ = C.forwardRef(
  ({ actions: t, children: e, label: n, nextLabel: r, onNext: i, onPrevious: o, previousLabel: s, secondaryLabel: a, selectedSlide: c, ...h }, f) => {
    const d = C.useRef(null), p = C.useRef(null), v = C.Children.map(
      e,
      (b, y) => C.cloneElement(b, { selected: y === c })
    );
    return /* @__PURE__ */ m($e, { ref: f, ...h, onKeyDown: (b) => {
      switch (b.key) {
        case Bt.RIGHT: {
          b.preventDefault(), p?.current && p.current.focus(), i && i();
          break;
        }
        case Bt.LEFT: {
          b.preventDefault(), d?.current && d.current.focus(), o && o();
          break;
        }
      }
    }, children: /* @__PURE__ */ ae($e, { padding: 2, borderColor: "neutral200", hasRadius: !0, background: "neutral100", children: [
      /* @__PURE__ */ ae(
        IZ,
        {
          tag: "section",
          "aria-roledescription": "carousel",
          "aria-label": n,
          display: "grid",
          position: "relative",
          children: [
            v && v.length > 1 && /* @__PURE__ */ ae(Gs, { children: [
              /* @__PURE__ */ m(_w, { tag: "button", onClick: o, $area: "startAction", ref: d, type: "button", children: /* @__PURE__ */ m(Ks, { label: s, children: /* @__PURE__ */ m(Vx, { width: "1.6rem", height: "1.6rem", fill: "neutral600" }) }) }),
              /* @__PURE__ */ m(_w, { tag: "button", onClick: i, $area: "endAction", ref: p, type: "button", children: /* @__PURE__ */ m(Ks, { label: r, children: /* @__PURE__ */ m(up, { width: "1.6rem", height: "1.6rem", fill: "neutral600" }) }) })
            ] }),
            /* @__PURE__ */ m(_Z, { "aria-live": "polite", paddingLeft: 2, paddingRight: 2, width: "100%", overflow: "hidden", children: v }),
            t
          ]
        }
      ),
      a && /* @__PURE__ */ m($e, { paddingTop: 2, paddingLeft: 4, paddingRight: 4, children: /* @__PURE__ */ m(R$, { label: a, children: /* @__PURE__ */ m(ge, { justifyContent: "center", children: /* @__PURE__ */ m(_e, { variant: "pi", textColor: "neutral600", ellipsis: !0, children: a }) }) }) })
    ] }) });
  }
), BZ = {
  accordions: {
    S: "4.8rem",
    M: "8.8rem"
  },
  button: {
    S: "3.2rem",
    M: "3.6rem",
    L: "4rem"
  }
}, _$ = {
  sizes: BZ,
  zIndices: {
    navigation: 100,
    overlay: 300,
    modal: 310,
    dialog: 320,
    popover: 500,
    notification: 700,
    tooltip: 1e3
  },
  spaces: ["0px", "4px", "8px", "12px", "16px", "20px", "24px", "32px", "40px", "48px", "56px", "64px"],
  borderRadius: "4px",
  breakpoints: {
    initial: "@media(min-width: 0px)",
    small: "@media(min-width: 520px)",
    medium: "@media(min-width: 768px)",
    large: "@media(min-width: 1080px)"
  },
  fontSizes: ["1.1rem", "1.2rem", "1.4rem", "1.6rem", "1.8rem", "3.2rem"],
  lineHeights: [1.14, 1.22, 1.25, 1.33, 1.43, 1.45, 1.5],
  fontWeights: {
    regular: 400,
    semiBold: 500,
    bold: 600
  },
  transitions: FX,
  motion: {
    easings: ug,
    timings: hg
  }
}, NZ = {
  color: {
    alternative100: "#f6ecfc",
    alternative200: "#e0c1f4",
    alternative500: "#ac73e6",
    alternative600: "#9736e8",
    alternative700: "#8312d1",
    buttonNeutral0: "#ffffff",
    buttonPrimary500: "#7b79ff",
    buttonPrimary600: "#4945ff",
    danger100: "#fcecea",
    danger200: "#f5c0b8",
    danger500: "#ee5e52",
    danger600: "#d02b20",
    danger700: "#b72b1a",
    neutral0: "#ffffff",
    neutral100: "#f6f6f9",
    neutral1000: "#181826",
    neutral150: "#eaeaef",
    neutral200: "#dcdce4",
    neutral300: "#c0c0cf",
    neutral400: "#a5a5ba",
    neutral500: "#8e8ea9",
    neutral600: "#666687",
    neutral700: "#4a4a6a",
    neutral800: "#32324d",
    neutral900: "#212134",
    primary100: "#f0f0ff",
    primary200: "#d9d8ff",
    primary500: "#7b79ff",
    primary600: "#4945ff",
    primary700: "#271fe0",
    secondary100: "#eaf5ff",
    secondary200: "#b8e1ff",
    secondary500: "#66b7f1",
    secondary600: "#0c75af",
    secondary700: "#006096",
    success100: "#eafbe7",
    success200: "#c6f0c2",
    success500: "#5cb176",
    success600: "#328048",
    success700: "#2f6846",
    warning100: "#fdf4dc",
    warning200: "#fae7b9",
    warning500: "#f29d41",
    warning600: "#d9822f",
    warning700: "#be5d01"
  }
}, FZ = {
  shadow: {
    filterShadow: "0px 1px 4px rgba(33, 33, 52, 0.1)",
    focus: "inset 2px 0px 0px rgb(39, 31, 224), inset 0px 2px 0px rgb(39, 31, 224), inset -2px 0px 0px rgb(39, 31, 224), inset 0px -2px 0px rgb(39, 31, 224)",
    focusShadow: "0px 0px 6px rgba(76, 191, 255, 0.75)",
    popupShadow: "0px 2px 15px rgba(33, 33, 52, 0.1)",
    tableShadow: "0px 1px 4px rgba(33, 33, 52, 0.1)"
  }
}, VZ = {
  colors: NZ.color,
  shadows: FZ.shadow,
  ..._$
}, HZ = {
  color: {
    alternative100: "#181826",
    alternative200: "#4a4a6a",
    alternative500: "#ac73e6",
    alternative600: "#ac73e6",
    alternative700: "#e0c1f4",
    buttonNeutral0: "#ffffff",
    buttonPrimary500: "#7b79ff",
    buttonPrimary600: "#4945ff",
    danger100: "#181826",
    danger200: "#4a4a6a",
    danger500: "#ee5e52",
    danger600: "#ee5e52",
    danger700: "#ee5e52",
    neutral0: "#212134",
    neutral100: "#181826",
    neutral1000: "#ffffff",
    neutral150: "#32324d",
    neutral200: "#4a4a6a",
    neutral300: "#666687",
    neutral400: "#a5a5ba",
    neutral500: "#c0c0cf",
    neutral600: "#a5a5ba",
    neutral700: "#eaeaef",
    neutral800: "#ffffff",
    neutral900: "#ffffff",
    primary100: "#181826",
    primary200: "#4a4a6a",
    primary500: "#4945ff",
    primary600: "#7b79ff",
    primary700: "#7b79ff",
    secondary100: "#181826",
    secondary200: "#4a4a6a",
    secondary500: "#66b7f1",
    secondary600: "#66b7f1",
    secondary700: "#b8e1ff",
    success100: "#181826",
    success200: "#4a4a6a",
    success500: "#5cb176",
    success600: "#5cb176",
    success700: "#c6f0c2",
    warning100: "#181826",
    warning200: "#4a4a6a",
    warning500: "#f29d41",
    warning600: "#f29d41",
    warning700: "#fae7b9"
  }
}, PZ = {
  shadow: {
    filterShadow: "1px 1px 10px rgba(3, 3, 5, 0.35)",
    focus: "inset 2px 0px 0px rgb(39, 31, 224), inset 0px 2px 0px rgb(39, 31, 224), inset -2px 0px 0px rgb(39, 31, 224), inset 0px -2px 0px rgb(39, 31, 224)",
    focusShadow: "0px 0px 6px rgba(76, 191, 255, 0.75)",
    popupShadow: "1px 1px 10px rgba(3, 3, 5, 0.35)",
    tableShadow: "1px 1px 10px rgba(3, 3, 5, 0.2)"
  }
}, Qte = {
  colors: HZ.color,
  shadows: PZ.shadow,
  ..._$
}, Qi = (t = "&") => ({ theme: e, $hasError: n = !1 }) => Ie`
    outline: none;
    box-shadow: none;
    transition-property: border-color, box-shadow, fill;
    transition-duration: 0.2s;

    ${t}:focus-within {
      border: 1px solid ${n ? e.colors.danger600 : e.colors.primary600};
      box-shadow: ${n ? e.colors.danger600 : e.colors.primary600} 0px 0px 0px 2px;
    }
  `, [WZ, kn] = _l("Field", {}), Bo = C.forwardRef(
  ({ children: t, name: e, error: n = !1, hint: r, id: i, required: o = !1, ...s }, a) => {
    const c = Vn(i), [h, f] = C.useState();
    return /* @__PURE__ */ m(
      WZ,
      {
        name: e,
        id: c,
        error: n,
        hint: r,
        required: o,
        labelNode: h,
        setLabelNode: f,
        children: /* @__PURE__ */ m(ge, { direction: "column", alignItems: "stretch", gap: 1, ref: a, ...s, children: t })
      }
    );
  }
), am = C.forwardRef(({ children: t, action: e, ...n }, r) => {
  const { id: i, required: o, setLabelNode: s } = kn("Label"), a = An(r, s);
  return t ? /* @__PURE__ */ ae(
    zZ,
    {
      ref: a,
      variant: "pi",
      textColor: "neutral800",
      fontWeight: "bold",
      ...n,
      id: `${i}-label`,
      htmlFor: i,
      tag: "label",
      ellipsis: !0,
      children: [
        t,
        o && /* @__PURE__ */ m(_e, { "aria-hidden": !0, lineHeight: "1em", textColor: "danger600", children: "*" }),
        e && /* @__PURE__ */ m(UZ, { marginLeft: 1, children: e })
      ]
    }
  ) : null;
}), zZ = W(_e)`
  display: flex;
`, UZ = W(ge)`
  line-height: 0;
  color: ${({ theme: t }) => t.colors.neutral500};
`, gf = C.forwardRef(
  ({
    endAction: t,
    startAction: e,
    disabled: n = !1,
    onChange: r,
    hasError: i,
    required: o,
    className: s,
    size: a = "M",
    ...c
  }, h) => {
    const { id: f, error: d, hint: p, name: v, required: w } = kn("Input");
    let b;
    d ? b = `${f}-error` : p && (b = `${f}-hint`);
    const y = !!d, $ = C.useRef(null), A = C.useRef(null), k = An(A, h), T = (R) => {
      !n && r && r(R);
    };
    return C.useLayoutEffect(() => {
      if ($.current && A.current) {
        const R = $.current.offsetWidth, _ = A.current;
        if (_) {
          const D = R + 8 + 16;
          _.style.paddingRight = `${D}px`;
        }
      }
    }, [t]), /* @__PURE__ */ ae(
      GZ,
      {
        gap: 2,
        justifyContent: "space-between",
        $hasError: y || i,
        $disabled: n,
        $size: a,
        $hasLeftAction: !!e,
        $hasRightAction: !!t,
        className: s,
        children: [
          e,
          /* @__PURE__ */ m(
            KZ,
            {
              id: f,
              name: v,
              ref: k,
              $size: a,
              "aria-describedby": b,
              "aria-invalid": y || i,
              "aria-disabled": n,
              disabled: n,
              "data-disabled": n ? "" : void 0,
              onChange: T,
              "aria-required": w || o,
              $hasLeftAction: !!e,
              $hasRightAction: !!t,
              ...c
            }
          ),
          t && /* @__PURE__ */ m(qZ, { ref: $, children: t })
        ]
      }
    );
  }
), KZ = W.input`
  border: none;
  border-radius: ${({ theme: t }) => t.borderRadius};
  cursor: ${(t) => t["aria-disabled"] ? "not-allowed" : void 0};

  color: ${({ theme: t }) => t.colors.neutral800};
  font-weight: 400;
  font-size: ${(t) => t.theme.fontSizes[2]};
  line-height: 2.2rem;
  display: block;
  width: 100%;
  background: inherit;

  ::placeholder {
    color: ${({ theme: t }) => t.colors.neutral500};
    opacity: 1;
  }

  &[aria-disabled='true'] {
    color: inherit;
  }

  //focus managed by InputWrapper
  &:focus {
    outline: none;
    box-shadow: none;
  }

  ${(t) => {
  switch (t.$size) {
    case "S":
      return Ie`
          padding-inline-start: ${t.$hasLeftAction ? 0 : t.theme.spaces[4]};
          padding-inline-end: ${t.$hasRightAction ? 0 : t.theme.spaces[4]};
          padding-block: ${t.theme.spaces[1]};
        `;
    default:
      return Ie`
          padding-inline-start: ${t.$hasLeftAction ? 0 : t.theme.spaces[4]};
          padding-inline-end: ${t.$hasRightAction ? 0 : t.theme.spaces[4]};
          padding-block: ${t.theme.spaces[2]};
        `;
  }
}}
`, qZ = W(ge)`
  position: absolute;
  right: ${({ theme: t }) => t.spaces[4]};
  top: 50%;
  transform: translateY(-50%);
`, GZ = W(ge)`
  border: 1px solid ${({ theme: t, $hasError: e }) => e ? t.colors.danger600 : t.colors.neutral200};
  border-radius: ${({ theme: t }) => t.borderRadius};
  background: ${({ theme: t }) => t.colors.neutral0};
  padding-inline-start: ${({ $hasLeftAction: t, theme: e }) => t ? e.spaces[4] : 0};
  position: relative;

  ${Qi()}
  ${({ theme: t, $disabled: e }) => e ? Ie`
          color: ${t.colors.neutral600};
          background: ${t.colors.neutral150};
        ` : void 0};
`, L$ = () => {
  const { id: t, hint: e, error: n } = kn("Hint");
  return !e || n ? null : /* @__PURE__ */ m(_e, { variant: "pi", tag: "p", id: `${t}-hint`, textColor: "neutral600", children: e });
}, B$ = () => {
  const { id: t, error: e } = kn("Error");
  return !e || typeof e != "string" ? null : /* @__PURE__ */ m(_e, { variant: "pi", tag: "p", id: `${t}-error`, textColor: "danger600", "data-strapi-field-error": !0, children: e });
}, YZ = C.forwardRef(({ label: t, children: e, ...n }, r) => /* @__PURE__ */ m(
  jZ,
  {
    justifyContent: "unset",
    background: "transparent",
    borderStyle: "none",
    ...n,
    type: "button",
    tag: "button",
    ref: r,
    children: /* @__PURE__ */ m(Ks, { label: t, children: e })
  }
)), jZ = W(ge)`
  font-size: 1.6rem;
  padding: 0;
`, Jte = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Action: YZ,
  Error: B$,
  Hint: L$,
  Input: gf,
  Label: am,
  Root: Bo,
  useField: kn
}, Symbol.toStringTag, { value: "Module" }));
C.forwardRef(
  ({
    actions: t,
    children: e,
    error: n,
    hint: r,
    label: i,
    labelAction: o,
    nextLabel: s,
    onNext: a,
    onPrevious: c,
    previousLabel: h,
    required: f,
    secondaryLabel: d,
    selectedSlide: p,
    id: v,
    ...w
  }, b) => {
    const y = Vn(v);
    return /* @__PURE__ */ m(Bo, { hint: r, error: n, id: y, required: f, children: /* @__PURE__ */ ae(ge, { direction: "column", alignItems: "stretch", gap: 1, children: [
      i && /* @__PURE__ */ m(am, { action: o, children: i }),
      /* @__PURE__ */ m(
        LZ,
        {
          ref: b,
          actions: t,
          label: i,
          nextLabel: s,
          onNext: a,
          onPrevious: c,
          previousLabel: h,
          secondaryLabel: d,
          selectedSlide: p,
          id: y,
          ...w,
          children: e
        }
      ),
      /* @__PURE__ */ m(L$, {}),
      /* @__PURE__ */ m(B$, {})
    ] }) });
  }
);
W($e)`
  ${f$}
`;
const pf = C.forwardRef(
  ({ children: t, viewportRef: e, ...n }, r) => /* @__PURE__ */ ae(XZ, { ref: r, ...n, children: [
    /* @__PURE__ */ m(ZZ, { ref: e, children: t }),
    /* @__PURE__ */ m(Lw, { orientation: "vertical", children: /* @__PURE__ */ m(Bw, {}) }),
    /* @__PURE__ */ m(Lw, { orientation: "horizontal", children: /* @__PURE__ */ m(Bw, {}) })
  ] })
), XZ = W(XV)`
  width: 100%;
  height: 100%;
  overflow: hidden;
  display: flex;
`, ZZ = W(ZV)`
  min-width: 100%;
`, Lw = W(QV)`
  display: flex;
  /* ensures no selection */
  user-select: none;
  /* disable browser handling of all panning and zooming gestures on touch devices */
  touch-action: none;

  &[data-orientation='vertical'] {
    width: 0.4rem;
    margin: 0.4rem;
  }

  &[data-orientation='horizontal'] {
    flex-direction: column;
    height: 0.4rem;
    margin: 0.4rem;
  }
`, Bw = W(JV)`
  position: relative;
  flex: 1;
  background-color: ${(t) => t.theme.colors.neutral150};
  border-radius: 0.4rem;

  /* increase target size for touch devices https://www.w3.org/WAI/WCAG21/Understanding/target-size.html */
  &::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100%;
    height: 100%;
    min-width: 44px;
    min-height: 44px;
  }
`, QZ = "data:image/svg+xml,%3csvg%20width='63'%20height='63'%20viewBox='0%200%2063%2063'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M42.5563%2011.9816C39.484%2010.3071%2035.8575%209.29097%2032.3354%209.13521C28.6443%208.92888%2024.8295%209.72318%2021.3336%2011.4129C20.9123%2011.5901%2020.5376%2011.8101%2020.1722%2012.0249L20.0108%2012.1179C19.8774%2012.1951%2019.7441%2012.2724%2019.608%2012.3536C19.3253%2012.5146%2019.0492%2012.6744%2018.7544%2012.8792C18.5463%2013.0329%2018.3395%2013.1759%2018.1301%2013.323C17.5658%2013.7208%2016.9868%2014.1317%2016.4983%2014.5979C14.8476%2015.9524%2013.5571%2017.6075%2012.6071%2018.9214C10.4365%2022.1566%209.08622%2025.9567%208.80702%2029.6143L8.7764%2030.1588C8.73328%2030.9196%208.68476%2031.7057%208.75353%2032.4555C8.76648%2032.6084%208.7661%2032.7638%208.77506%2032.914C8.78895%2033.229%208.80152%2033.5373%208.846%2033.8672L9.07396%2035.4221C9.09756%2035.5764%209.1198%2035.7413%209.1633%2035.9263L9.65919%2037.9272L10.138%2039.2823C10.2729%2039.6673%2010.4158%2040.0751%2010.6%2040.43C12.0292%2043.637%2014.1425%2046.4578%2016.7063%2048.585C19.0508%2050.5296%2021.824%2052.0023%2024.7491%2052.8452L26.2371%2053.2376C26.3781%2053.2693%2026.4926%2053.2889%2026.6031%2053.3058L26.7775%2053.3311C27.0052%2053.3636%2027.2195%2053.3986%2027.4445%2053.435C27.8598%2053.5076%2028.2672%2053.5748%2028.7079%2053.6183L30.5641%2053.7229C30.9516%2053.7249%2031.3352%2053.7068%2031.7081%2053.6874C31.9039%2053.681%2032.0984%2053.6681%2032.3288%2053.662C34.5253%2053.4772%2036.5106%2053.0634%2038.0516%2052.4652C38.1769%2052.4171%2038.3008%2052.3796%2038.4234%2052.3355C38.6727%2052.2499%2038.9259%2052.167%2039.1432%2052.0599L40.8591%2051.2626L42.5702%2050.266C42.9009%2050.0682%2043.0205%2049.6414%2042.8282%2049.2984C42.632%2048.9526%2042.2034%2048.8308%2041.8634%2049.0166L40.1792%2049.9218L38.4995%2050.6224C38.3169%2050.6953%2038.121%2050.7534%2037.9224%2050.8155C37.7838%2050.8489%2037.6518%2050.8983%2037.5012%2050.9408C36.0711%2051.435%2034.2445%2051.7425%2032.244%2051.8346C32.0442%2051.8383%2031.8471%2051.8379%2031.654%2051.8403C31.3051%2051.8414%2030.9602%2051.8451%2030.6392%2051.8305L28.9177%2051.6725C28.5476%2051.619%2028.1695%2051.5427%2027.7848%2051.4678C27.5639%2051.4167%2027.3376%2051.3737%2027.1299%2051.3374L26.9529%2051.2987C26.8704%2051.2834%2026.7772%2051.2667%2026.7333%2051.2543L25.3466%2050.8322C22.7651%2049.9789%2020.33%2048.5729%2018.2942%2046.7557C16.1056%2044.7951%2014.3339%2042.2335%2013.1742%2039.3582C12.0276%2036.6013%2011.5988%2033.2792%2011.9716%2030.0076C12.3145%2027.0213%2013.3948%2024.1635%2015.1858%2021.5083C15.3034%2021.3339%2015.421%2021.1596%2015.5212%2021.0196C16.4309%2019.8688%2017.5408%2018.5589%2018.9483%2017.496C19.3367%2017.1525%2019.7862%2016.856%2020.2611%2016.5478C20.4878%2016.4009%2020.7079%2016.2553%2020.8907%2016.1306C21.0974%2016.0048%2021.3188%2015.8831%2021.5348%2015.7694C21.6761%2015.6975%2021.8162%2015.619%2021.9388%2015.5576L22.1002%2015.4646C22.4002%2015.3037%2022.6749%2015.1546%2022.9908%2015.039L24.1186%2014.5715C24.3399%2014.4844%2024.5718%2014.4159%2024.7997%2014.3447C24.953%2014.2982%2025.0982%2014.2635%2025.2635%2014.2078C25.786%2014.0182%2026.3283%2013.9112%2026.9105%2013.7965C27.117%2013.7571%2027.3302%2013.7163%2027.5608%2013.6585C27.7553%2013.611%2027.9737%2013.5969%2028.2082%2013.5762C28.364%2013.5603%2028.5172%2013.5483%2028.6318%2013.5333C28.7876%2013.5173%2028.9342%2013.5066%2029.0927%2013.4867C29.3285%2013.4555%2029.5456%2013.4347%2029.7494%2013.4337C30.0237%2013.44%2030.2994%2013.4357%2030.5777%2013.4274C31.0811%2013.421%2031.5579%2013.4197%2032.0318%2013.4914C34.9664%2013.7352%2037.7144%2014.6085%2040.2052%2016.0868C42.3489%2017.3655%2044.2716%2019.1525%2045.7607%2021.264C47.0255%2023.0628%2047.9756%2025.0528%2048.4928%2027.0393C48.572%2027.3176%2048.6299%2027.5931%2048.6839%2027.8659C48.7154%2028.0428%2048.7563%2028.2145%2048.7892%2028.3636C48.8037%2028.4541%2048.8208%2028.5406%2048.8445%2028.6258C48.8749%2028.7443%2048.8986%2028.864%2048.9116%2028.9651L48.9793%2029.6047C48.9922%2029.7748%2049.0132%2029.9331%2049.0301%2030.0887C49.0668%2030.3268%2049.0889%2030.5608%2049.0964%2030.7561L49.1083%2031.9001C49.1312%2032.3307%2049.089%2032.7116%2049.0522%2033.0673C49.0384%2033.2598%2049.0126%2033.4443%2049.0123%2033.5824C48.9961%2033.6926%2048.9918%2033.7935%2048.9836%2033.8917C48.9753%2034.0072%2048.9724%2034.1148%2048.9414%2034.2554L48.5449%2036.3059C48.3134%2037.8623%2049.3793%2039.3365%2050.9488%2039.5822C52.0417%2039.7601%2053.1536%2039.2819%2053.7711%2038.3664C54.0063%2038.0176%2054.1604%2037.6257%2054.2227%2037.2064L54.5217%2035.2574C54.5514%2035.0756%2054.572%2034.83%2054.5846%2034.5791L54.6028%2034.2338C54.6098%2034.0598%2054.6223%2033.8779%2054.6347%2033.6788C54.6734%2033.1052%2054.7163%2032.4479%2054.6619%2031.8058L54.5867%2030.4289C54.5622%2030.0952%2054.5097%2029.76%2054.4559%2029.4181C54.431%2029.2572%2054.4048%2029.0896%2054.3826%2028.9074L54.2687%2028.104C54.2332%2027.9244%2054.1804%2027.7273%2054.1329%2027.5396L54.0643%2027.2454C54.0195%2027.071%2053.9773%2026.8927%2053.9338%2026.7076C53.8455%2026.3309%2053.7479%2025.9422%2053.613%2025.5571C52.84%2023.0292%2051.5383%2020.5194%2049.8338%2018.2799C47.8544%2015.682%2045.3333%2013.5087%2042.5563%2011.9816Z'%20fill='%234945FF'/%3e%3c/svg%3e", JZ = C.forwardRef(({ children: t, small: e = !1, ...n }, r) => /* @__PURE__ */ ae("div", { role: "alert", "aria-live": "assertive", ref: r, ...n, children: [
  /* @__PURE__ */ m(zo, { children: t }),
  /* @__PURE__ */ m(tQ, { src: QZ, "aria-hidden": !0, $small: e })
] })), eQ = tn`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(359deg);
  }
`, tQ = W.img`
  animation: ${eQ} 1s infinite linear;
  will-change: transform;
  ${({ $small: t, theme: e }) => t && `width: ${e.spaces[6]}; height: ${e.spaces[6]};`}
`, nQ = C.forwardRef(
  ({
    allowCustomValue: t,
    autocomplete: e,
    children: n,
    className: r,
    clearLabel: i = "Clear",
    creatable: o = !1,
    creatableStartIcon: s,
    createMessage: a = (Le) => `Create "${Le}"`,
    defaultFilterValue: c,
    defaultTextValue: h,
    defaultOpen: f = !1,
    open: d,
    onOpenChange: p,
    disabled: v = !1,
    hasError: w,
    id: b,
    filterValue: y,
    hasMoreItems: $ = !1,
    isPrintableCharacter: A,
    loading: k = !1,
    loadingMessage: T = "Loading content...",
    name: R,
    noOptionsMessage: _ = () => "No results found",
    onChange: D,
    onClear: P,
    onCreateOption: H,
    onFilterValueChange: z,
    onInputChange: j,
    onTextValueChange: K,
    onLoadMore: te,
    placeholder: ee = "Select or enter a value",
    required: re = !1,
    size: de = "M",
    startIcon: ie,
    textValue: se,
    value: X,
    ...ce
  }, be) => {
    const [Le, Ae] = Or({
      prop: d,
      defaultProp: f,
      onChange: p
    }), [qe, He] = Or({
      prop: se,
      defaultProp: t && !h ? X : h,
      onChange: K
    }), [Ze, xe] = Or({
      prop: y,
      defaultProp: c,
      onChange: z
    }), Ve = C.useRef(null), Oe = C.useRef(null), Ue = An(Oe, be), Ee = C.useRef(null), je = (qt) => {
      P && !v && (He(""), xe(""), P(qt), Oe.current.focus());
    }, Rt = (qt) => {
      Ae(qt);
    }, at = (qt) => {
      He(qt);
    }, Qe = (qt) => {
      xe(qt);
    }, an = (qt) => {
      j && j(qt);
    }, Ct = (qt) => {
      D && D(qt);
    }, Uo = (qt) => {
      te && $ && !k && te(qt);
    }, Ko = () => {
      H && qe && o !== "visible" ? H(qe) : H && o === "visible" && (H(), Ae(!1));
    }, Pr = Vn(), It = `intersection-${qs(Pr)}`;
    Bl(Ve, Uo, {
      selectorToWatch: `#${It}`,
      /**
       * We need to know when the select is open because only then will viewportRef
       * not be null. Because it uses a portal that (sensibly) is not mounted 24/7.
       */
      skipWhen: !Le
    });
    const { error: Wr, ...zr } = kn("Combobox"), vf = !!Wr || w, Ur = zr.id ?? b, bf = zr.name ?? R, Ji = zr.required || re;
    let mr;
    return Wr ? mr = `${Ur}-error` : zr.hint && (mr = `${Ur}-hint`), /* @__PURE__ */ ae(
      sr.Root,
      {
        autocomplete: e || (o === !0 ? "list" : "both"),
        onOpenChange: Rt,
        open: Le,
        onTextValueChange: at,
        textValue: qe,
        allowCustomValue: !!o || t,
        disabled: v,
        required: Ji,
        value: X,
        onValueChange: Ct,
        filterValue: Ze,
        onFilterValueChange: Qe,
        isPrintableCharacter: A,
        visible: o === "visible",
        children: [
          /* @__PURE__ */ ae(rQ, { $hasError: vf, $size: de, className: r, children: [
            /* @__PURE__ */ ae(ge, { flex: "1", tag: "span", gap: 3, children: [
              ie ? /* @__PURE__ */ m(ge, { flex: "0 0 1.6rem", tag: "span", "aria-hidden": !0, children: ie }) : null,
              /* @__PURE__ */ m(
                iQ,
                {
                  placeholder: ee,
                  id: Ur,
                  "aria-invalid": !!Wr,
                  onChange: an,
                  ref: Ue,
                  name: bf,
                  "aria-describedby": mr,
                  ...ce
                }
              )
            ] }),
            /* @__PURE__ */ ae(ge, { tag: "span", gap: 3, children: [
              qe && P ? /* @__PURE__ */ m(
                Lo,
                {
                  size: "XS",
                  variant: "ghost",
                  onClick: je,
                  "aria-disabled": v,
                  "aria-label": i,
                  label: i,
                  ref: Ee,
                  children: /* @__PURE__ */ m(Vo, {})
                }
              ) : null,
              /* @__PURE__ */ m(oQ, { children: /* @__PURE__ */ m(Wi, { fill: "neutral500" }) })
            ] })
          ] }),
          /* @__PURE__ */ m(sr.Portal, { children: /* @__PURE__ */ m(sQ, { sideOffset: 4, children: /* @__PURE__ */ ae(sr.Viewport, { ref: Ve, children: [
            /* @__PURE__ */ ae(lQ, { children: [
              n,
              o !== !0 && !k ? /* @__PURE__ */ m(sr.NoValueFound, { asChild: !0, children: /* @__PURE__ */ m(gg, { $hasHover: !1, children: /* @__PURE__ */ m(_e, { children: _(qe ?? "") }) }) }) : null,
              k ? /* @__PURE__ */ m(ge, { justifyContent: "center", alignItems: "center", paddingTop: 2, paddingBottom: 2, children: /* @__PURE__ */ m(JZ, { small: !0, children: T }) }) : null,
              /* @__PURE__ */ m($e, { id: It, width: "100%", height: "1px" })
            ] }),
            o ? /* @__PURE__ */ m(aQ, { onPointerUp: Ko, onClick: Ko, asChild: !0, children: /* @__PURE__ */ m(gg, { children: /* @__PURE__ */ ae(ge, { gap: 2, children: [
              s && /* @__PURE__ */ m($e, { tag: "span", "aria-hidden": !0, display: "inline-flex", children: s }),
              /* @__PURE__ */ m(_e, { children: a(qe ?? "") })
            ] }) }) }) : null
          ] }) }) })
        ]
      }
    );
  }
), rQ = W(sr.Trigger)`
  position: relative;
  border: 1px solid ${({ theme: t, $hasError: e }) => e ? t.colors.danger600 : t.colors.neutral200};
  border-radius: ${({ theme: t }) => t.borderRadius};
  background: ${({ theme: t }) => t.colors.neutral0};
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: ${({ theme: t }) => t.spaces[4]};

  ${(t) => {
  switch (t.$size) {
    case "S":
      return Ie`
          padding-inline-start: ${({ theme: e }) => e.spaces[4]};
          padding-inline-end: ${({ theme: e }) => e.spaces[3]};
          padding-block: ${({ theme: e }) => e.spaces[1]};
        `;
    default:
      return Ie`
          padding-inline-start: ${({ theme: e }) => e.spaces[4]};
          padding-inline-end: ${({ theme: e }) => e.spaces[3]};
          padding-block: ${({ theme: e }) => e.spaces[2]};
        `;
  }
}}

  &[data-disabled] {
    color: ${({ theme: t }) => t.colors.neutral600};
    background: ${({ theme: t }) => t.colors.neutral150};
    cursor: not-allowed;
  }

  /* Required to ensure the below inputFocusStyles are adhered too */
  &:focus-visible {
    outline: none;
  }

  ${({ theme: t, $hasError: e }) => Qi()({ theme: t, $hasError: e })};
`, iQ = W(sr.TextInput)`
  width: 100%;
  font-size: 1.4rem;
  line-height: 2.2rem;
  color: ${({ theme: t }) => t.colors.neutral800};
  padding: 0;
  border: none;
  background-color: transparent;

  &:focus-visible {
    outline: none;
  }

  &[aria-disabled='true'] {
    cursor: inherit;
  }
`, oQ = W(sr.Icon)`
  border: none;
  background: transparent;
  padding: 0;
  color: ${({ theme: t }) => t.colors.neutral600};
  display: flex;

  &[aria-disabled='true'] {
    cursor: inherit;
  }
`, sQ = W(sr.Content)`
  background: ${({ theme: t }) => t.colors.neutral0};
  box-shadow: ${({ theme: t }) => t.shadows.filterShadow};
  border: 1px solid ${({ theme: t }) => t.colors.neutral150};
  border-radius: ${({ theme: t }) => t.borderRadius};
  width: var(--radix-combobox-trigger-width);
  /* This is from the design-system figma file. */
  max-height: 15rem;
  z-index: ${({ theme: t }) => t.zIndices.popover};

  &:focus-visible {
    outline: ${({ theme: t }) => `2px solid ${t.colors.primary600}`};
    outline-offset: 2px;
  }

  @media (prefers-reduced-motion: no-preference) {
    animation-duration: ${(t) => t.theme.motion.timings[200]};

    /* The select can't animate out yet, watch https://github.com/radix-ui/primitives/issues/1893, or take a look and solve it yourself. */
    &[data-state='open'] {
      animation-timing-function: ${(t) => t.theme.motion.easings.authenticMotion};

      &[data-side='top'] {
        animation-name: ${kt.slideUpIn};
      }

      &[data-side='bottom'] {
        animation-name: ${kt.slideDownIn};
      }
    }
  }
`, aQ = W(sr.CreateItem)`
  && {
    border-top: 1px solid ${({ theme: t }) => t.colors.neutral150};
    background: ${({ theme: t }) => t.colors.neutral0};
    cursor: pointer;
    padding: ${({ theme: t }) => t.spaces[1]};
    position: sticky;
    bottom: 0;
    left: 0;
  }
  &&:hover,
  &&[data-highlighted] {
    background-color: transparent;
  }
  && > div {
    padding: ${({ theme: t }) => t.spaces[2]} ${({ theme: t }) => t.spaces[4]};
  }
  && > div:hover,
  &&[data-highlighted] > div {
    background-color: ${({ theme: t }) => t.colors.primary100};
  }
`, lQ = W(pf)`
  padding: ${({ theme: t }) => t.spaces[1]};
`, cQ = C.forwardRef(
  ({ children: t, value: e, disabled: n, textValue: r, ...i }, o) => /* @__PURE__ */ m(sr.ComboboxItem, { asChild: !0, value: e, disabled: n, textValue: r, children: /* @__PURE__ */ m(gg, { ref: o, ...i, children: /* @__PURE__ */ m(sr.ItemText, { asChild: !0, children: /* @__PURE__ */ m(_e, { children: t }) }) }) })
), gg = W.div`
  width: 100%;
  border: none;
  text-align: left;
  outline-offset: -3px;
  padding: ${({ theme: t }) => t.spaces[2]} ${({ theme: t }) => t.spaces[4]};
  background-color: ${({ theme: t }) => t.colors.neutral0};
  border-radius: ${({ theme: t }) => t.borderRadius};
  user-select: none;

  &[data-state='checked'] {
    background-color: ${({ theme: t }) => t.colors.primary100};
    color: ${({ theme: t }) => t.colors.primary600};
    font-weight: bold;
  }

  &:hover,
  &[data-highlighted] {
    outline: none;
    background-color: ${({ theme: t, $hasHover: e = !0 }) => e ? t.colors.primary100 : t.colors.neutral0};
  }

  &[data-highlighted] {
    color: ${({ theme: t }) => t.colors.primary600};
    font-weight: bold;
  }
`, uQ = qH, hQ = C.forwardRef((t, e) => /* @__PURE__ */ m(GH, { ...t, asChild: !0, ref: e })), fQ = C.forwardRef((t, e) => /* @__PURE__ */ ae(YH, { children: [
  /* @__PURE__ */ m(dQ, {}),
  /* @__PURE__ */ m(gQ, { ref: e, ...t })
] })), dQ = W(jH)`
  background-color: ${(t) => t.theme.colors.neutral800};
  position: fixed;
  inset: 0;
  z-index: ${(t) => t.theme.zIndices.overlay};
  opacity: 0.2;

  @media (prefers-reduced-motion: no-preference) {
    animation: ${kt.overlayFadeIn} ${(t) => t.theme.motion.timings[200]}
      ${(t) => t.theme.motion.easings.authenticMotion};
  }
`, gQ = W(XH)`
  max-width: 42rem;
  height: min-content;
  width: 100%;
  overflow: hidden;
  margin: 0 auto;
  display: flex;
  flex-direction: column;

  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);

  border-radius: ${(t) => t.theme.borderRadius};
  background-color: ${(t) => t.theme.colors.neutral0};
  box-shadow: ${(t) => t.theme.shadows.popupShadow};
  z-index: ${(t) => t.theme.zIndices.modal};

  @media (prefers-reduced-motion: no-preference) {
    &[data-state='open'] {
      animation-duration: ${(t) => t.theme.motion.timings[200]};
      animation-timing-function: ${(t) => t.theme.motion.easings.authenticMotion};
      animation-name: ${kt.modalPopIn};
    }

    &[data-state='closed'] {
      animation-duration: ${(t) => t.theme.motion.timings[120]};
      animation-timing-function: ${(t) => t.theme.motion.easings.easeOutQuad};
      animation-name: ${kt.modalPopOut};
    }
  }
`, pQ = C.forwardRef(({ children: t, ...e }, n) => /* @__PURE__ */ m(JH, { asChild: !0, children: /* @__PURE__ */ m(mQ, { tag: "h2", variant: "beta", ref: n, padding: 6, fontWeight: "bold", ...e, children: t }) })), mQ = W(_e)`
  display: flex;
  justify-content: center;
  border-bottom: solid 1px ${(t) => t.theme.colors.neutral150};
`, vQ = C.forwardRef(({ children: t, icon: e, ...n }, r) => /* @__PURE__ */ m(
  ge,
  {
    ref: r,
    gap: 2,
    direction: "column",
    paddingTop: 8,
    paddingBottom: 8,
    paddingLeft: 6,
    paddingRight: 6,
    ...n,
    children: typeof t == "string" ? /* @__PURE__ */ ae(Gs, { children: [
      e ? C.cloneElement(e, {
        width: 24,
        height: 24
      }) : null,
      /* @__PURE__ */ m(N$, { children: t })
    ] }) : t
  }
)), N$ = C.forwardRef((t, e) => /* @__PURE__ */ m(eP, { asChild: !0, children: /* @__PURE__ */ m(_e, { ref: e, variant: "omega", ...t, tag: "p" }) })), bQ = C.forwardRef((t, e) => /* @__PURE__ */ m(wQ, { ref: e, gap: 2, padding: 4, justifyContent: "space-between", ...t, tag: "footer" })), wQ = W(ge)`
  border-top: solid 1px ${(t) => t.theme.colors.neutral150};
  flex: 1;
`, xQ = C.forwardRef((t, e) => /* @__PURE__ */ m(QH, { ...t, asChild: !0, ref: e })), yQ = C.forwardRef((t, e) => /* @__PURE__ */ m(ZH, { ...t, asChild: !0, ref: e })), ene = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Action: yQ,
  Body: vQ,
  Cancel: xQ,
  Content: fQ,
  Description: N$,
  Footer: bQ,
  Header: pQ,
  Root: uQ,
  Trigger: hQ
}, Symbol.toStringTag, { value: "Module" }));
function ui(t, e) {
  const n = C.useRef(null);
  return e && n.current && CQ(e, n.current) && (e = n.current), n.current = e ?? null, C.useMemo(() => new bR(t, e), [t, e]);
}
function CQ(t, e) {
  if (t === e)
    return !0;
  const n = Object.keys(t), r = Object.keys(e);
  if (n.length !== r.length)
    return !1;
  for (const i of n)
    if (e[i] !== t[i])
      return !1;
  return !0;
}
const _0 = {
  Log: "live-region-log",
  Status: "live-region-status",
  Alert: "live-region-alert"
}, $Q = () => /* @__PURE__ */ ae(zo, { children: [
  /* @__PURE__ */ m("p", { role: "log", "aria-live": "polite", id: _0.Log, "aria-relevant": "all" }),
  /* @__PURE__ */ m("p", { role: "status", "aria-live": "polite", id: _0.Status, "aria-relevant": "all" }),
  /* @__PURE__ */ m("p", { role: "alert", "aria-live": "assertive", id: _0.Alert, "aria-relevant": "all" })
] }), SQ = PT`
${Ie`
  *,
  *::before,
  *::after {
    box-sizing: border-box;
  }

  * {
    margin: 0;
  }

  html {
    /* Sets 1rem === 10px */
    font-size: 62.5%;
  }

  body {
    height: 100%;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans',
      'Helvetica Neue', sans-serif;
    color: ${({ theme: t }) => t.colors.neutral800};
    line-height: 1.5;
    -webkit-font-smoothing: antialiased;
  }

  img,
  picture,
  video,
  canvas {
    display: block;
    max-width: 100%;
  }

  input,
  button,
  textarea,
  select {
    padding: 0;
    font: inherit;
  }

  button {
    border: unset;
    background: unset;
    padding: unset;
    margin: unset;
  }

  p,
  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    overflow-wrap: break-word;
    font: unset;
  }

  #root {
    isolation: isolate;
  }

  ol,
  ul {
    list-style: none;
    padding: unset;
    margin: unset;
  }

  table {
    border-collapse: collapse;
    border-spacing: 0;
  }

  *:focus-visible {
    outline: 2px solid ${({ theme: t }) => t.colors.primary600};
    outline-offset: 2px;
  }

  *:has(> :disabled:not(button)) {
    cursor: not-allowed !important;
  }

  [aria-disabled='true']:not(button) {
    cursor: not-allowed !important;
  }

  /* Focusing the button with a mouse, touch, or stylus will show a subtle drop shadow. */
  *:focus:not(:focus-visible) {
    outline: none;
  }

  .lock-body-scroll {
    height: 100vh;
    overflow-y: hidden;
  }
`}
`, Nw = "en-EN", F$ = () => typeof navigator > "u" ? Nw : navigator.language ? navigator.language : Nw, [AQ, mf] = _l("StrapiDesignSystem", {
  locale: F$()
}), tne = ({
  children: t,
  locale: e = F$(),
  theme: n = VZ,
  tooltipConfig: r
}) => (_o(() => {
  const i = document.createElement("style");
  i.type = "text/css", i.appendChild(
    document.createTextNode(`
        * {
          -webkit-transition: none !important;
          -moz-transition: none !important;
          -o-transition: none !important;
          -ms-transition: none !important;
          transition: none !important;
          animation: none !important;
        }
    `)
  ), document.head.appendChild(i), window.getComputedStyle(i).opacity, document.head.removeChild(i);
}, [n]), /* @__PURE__ */ m(AQ, { locale: e, children: /* @__PURE__ */ ae(HT, { theme: n, children: [
  /* @__PURE__ */ m(dO, { ...r, children: t }),
  /* @__PURE__ */ m($Q, {}),
  /* @__PURE__ */ m(SQ, {})
] }) })), kQ = _R, V$ = C.forwardRef(
  ({ container: t = globalThis?.document?.body, ...e }, n) => t ? Xw(/* @__PURE__ */ m($e, { ref: n, ...e }), t) : null
);
V$.displayName = "Portal";
const MQ = C.forwardRef(
  ({ onClear: t, clearLabel: e = "Clear", startIcon: n, disabled: r, hasError: i, children: o, id: s, size: a = "M", withTags: c, ...h }, f) => {
    const d = C.useRef(null), p = (b) => {
      t && !r && (t(b), d.current.focus());
    }, { labelNode: v } = kn("SelectTrigger"), w = An(d, f);
    return /* @__PURE__ */ m(dr.Trigger, { asChild: !0, children: /* @__PURE__ */ ae(
      RQ,
      {
        "aria-disabled": r,
        $hasError: i,
        ref: w,
        alignItems: "center",
        justifyContent: "space-between",
        position: "relative",
        overflow: "hidden",
        hasRadius: !0,
        background: r ? "neutral150" : "neutral0",
        gap: 4,
        cursor: "default",
        "aria-labelledby": v ? `${s}-label` : void 0,
        $size: a,
        $withTags: c,
        ...h,
        children: [
          /* @__PURE__ */ ae(ge, { flex: "1", tag: "span", gap: 3, children: [
            n && /* @__PURE__ */ m(ge, { tag: "span", "aria-hidden": !0, children: n }),
            o
          ] }),
          /* @__PURE__ */ ae(ge, { tag: "span", gap: 3, children: [
            t ? /* @__PURE__ */ m(
              TQ,
              {
                tag: "button",
                hasRadius: !0,
                background: "transparent",
                role: "button",
                tabIndex: 0,
                onClick: p,
                "aria-disabled": r,
                "aria-label": e,
                title: e,
                cursor: "pointer",
                children: /* @__PURE__ */ m(Vo, {})
              }
            ) : null,
            /* @__PURE__ */ m(EQ, { children: /* @__PURE__ */ m(Wi, {}) })
          ] })
        ]
      }
    ) });
  }
), TQ = W($e)`
  border: none;
  display: flex;

  svg {
    height: 1.1rem;
    width: 1.1rem;
  }

  svg path {
    fill: ${({ theme: t }) => t.colors.neutral500};
  }
`, RQ = W(ge)`
  border: 1px solid ${({ theme: t, $hasError: e }) => e ? t.colors.danger600 : t.colors.neutral200};
  ${(t) => {
  switch (t.$size) {
    case "S":
      return Ie`
          padding-block: ${t.theme.spaces[1]};
          padding-inline-start: ${t.$withTags ? t.theme.spaces[1] : t.theme.spaces[4]};
          padding-inline-end: ${t.theme.spaces[3]};
        `;
    default:
      return Ie`
          padding-block: ${t.$withTags ? "0.3rem" : t.theme.spaces[2]};
          padding-inline-start: ${t.$withTags ? t.theme.spaces[1] : t.theme.spaces[4]};
          padding-inline-end: ${t.theme.spaces[3]};
        `;
  }
}}
  cursor: pointer;

  &[aria-disabled='true'] {
    color: ${(t) => t.theme.colors.neutral500};
  }

  /* Required to ensure the below inputFocusStyles are adhered too */
  &:focus-visible {
    outline: none;
  }

  ${({ theme: t, $hasError: e }) => Qi()({ theme: t, $hasError: e })};
`, EQ = W(dr.Icon)`
  display: flex;
  & > svg {
    fill: ${({ theme: t }) => t.colors.neutral500};
  }
`, OQ = C.forwardRef(({ children: t, placeholder: e, ...n }, r) => /* @__PURE__ */ m(DQ, { ref: r, ellipsis: !0, ...n, children: /* @__PURE__ */ m(IQ, { placeholder: e, children: t }) })), DQ = W(_e)`
  flex: 1;
  font-size: 1.4rem;
  line-height: 2.2rem;
`, IQ = W(dr.Value)`
  display: flex;
  gap: ${({ theme: t }) => t.spaces[1]};
  flex-wrap: wrap;
`, _Q = C.forwardRef((t, e) => /* @__PURE__ */ m(LQ, { ref: e, ...t, children: /* @__PURE__ */ m(pf, { children: t.children }) })), LQ = W(dr.Content)`
  background: ${({ theme: t }) => t.colors.neutral0};
  box-shadow: ${({ theme: t }) => t.shadows.filterShadow};
  border: 1px solid ${({ theme: t }) => t.colors.neutral150};
  border-radius: ${({ theme: t }) => t.borderRadius};
  min-width: var(--radix-select-trigger-width);
  max-height: 15.6rem;
  z-index: ${({ theme: t }) => t.zIndices.popover};

  @media (prefers-reduced-motion: no-preference) {
    animation-duration: ${(t) => t.theme.motion.timings[200]};

    /* The select can't animate out yet, watch https://github.com/radix-ui/primitives/issues/1893, or take a look and solve it yourself. */
    &[data-state='open'] {
      animation-timing-function: ${(t) => t.theme.motion.easings.authenticMotion};

      &[data-side='top'] {
        animation-name: ${kt.slideUpIn};
      }

      &[data-side='bottom'] {
        animation-name: ${kt.slideDownIn};
      }
    }
  }
`, BQ = W(dr.Viewport)`
  padding: ${({ theme: t }) => t.spaces[1]};
`, NQ = C.forwardRef((t, e) => /* @__PURE__ */ m(VQ, { ref: e, ...t })), FQ = Ie`
  width: 100%;
  border: none;
  text-align: left;
  outline-offset: -3px;
  border-radius: ${(t) => t.theme.borderRadius};
  padding: ${(t) => `${t.theme.spaces[2]} ${t.theme.spaces[4]}`};
  padding-left: ${({ theme: t }) => t.spaces[4]};
  background-color: ${({ theme: t }) => t.colors.neutral0};
  display: flex;
  align-items: center;
  gap: ${({ theme: t }) => t.spaces[2]};
  white-space: nowrap;
  user-select: none;
  color: ${({ theme: t }) => t.colors.neutral800};

  &:focus-visible {
    outline: none;
    background-color: ${({ theme: t }) => t.colors.primary100};
    cursor: pointer;
  }
`, VQ = W(dr.Item)`
  ${FQ}

  &:hover {
    background-color: ${({ theme: t }) => t.colors.primary100};
    cursor: pointer;
  }

  &[data-state='checked'] {
    font-weight: bold;
    color: ${({ theme: t }) => t.colors.primary600};
    font-weight: bold;
  }
`, H$ = dr.Root, P$ = MQ, W$ = OQ, z$ = dr.Portal, U$ = _Q, K$ = BQ, lm = NQ, q$ = dr.ItemIndicator, G$ = dr.ItemText, HQ = dr.Group, Fw = C.forwardRef(
  ({
    children: t,
    clearLabel: e = "Clear",
    customizeContent: n,
    disabled: r,
    hasError: i,
    id: o,
    name: s,
    onChange: a,
    onClear: c,
    onCloseAutoFocus: h,
    onReachEnd: f,
    placeholder: d,
    required: p,
    size: v,
    startIcon: w,
    value: b,
    ...y
  }, $) => {
    const [A, k] = C.useState(), [T, R] = C.useState(!1), _ = (be) => {
      R(be);
    }, D = (be) => {
      c && c(be), a || k("");
    }, P = (be) => {
      a ? a(typeof b == "number" ? Number(be) : be) : k(be);
    }, H = C.useRef(null), z = Vn(), j = `intersection-${qs(z)}`;
    Bl(H, (be) => {
      f && f(be);
    }, {
      selectorToWatch: `#${j}`,
      /**
       * We need to know when the select is open because only then will viewportRef
       * not be null. Because it uses a portal that (sensibly) is not mounted 24/7.
       */
      skipWhen: !T
    });
    const { error: te, required: ee, ...re } = kn("SingleSelect"), de = !!te || i, ie = re.id ?? o, se = re.name ?? s;
    let X;
    te ? X = `${ie}-error` : re.hint && (X = `${ie}-hint`);
    const ce = (typeof b < "u" && b !== null ? b.toString() : A) ?? "";
    return /* @__PURE__ */ ae(
      H$,
      {
        onOpenChange: _,
        disabled: r,
        required: ee ?? p,
        onValueChange: P,
        value: ce,
        ...y,
        children: [
          /* @__PURE__ */ m(
            P$,
            {
              ref: $,
              id: ie,
              name: se,
              startIcon: w,
              hasError: de,
              disabled: r,
              clearLabel: e,
              onClear: ce && c ? D : void 0,
              "aria-label": y["aria-label"],
              "aria-describedby": X ?? y["aria-describedby"],
              size: v,
              children: /* @__PURE__ */ m(W$, { placeholder: d, textColor: ce ? "neutral800" : "neutral600", children: ce && n ? n(ce) : void 0 })
            }
          ),
          /* @__PURE__ */ m(z$, { children: /* @__PURE__ */ m(U$, { position: "popper", sideOffset: 4, onCloseAutoFocus: h, children: /* @__PURE__ */ ae(K$, { ref: H, children: [
            t,
            /* @__PURE__ */ m($e, { id: j, width: "100%", height: "1px" })
          ] }) }) })
        ]
      }
    );
  }
), Vw = C.forwardRef(
  ({ value: t, startIcon: e, children: n, ...r }, i) => /* @__PURE__ */ ae(lm, { ref: i, value: t.toString(), ...r, children: [
    e && /* @__PURE__ */ m(ge, { tag: "span", "aria-hidden": !0, children: e }),
    /* @__PURE__ */ m(_e, { lineHeight: "20px", width: "100%", children: /* @__PURE__ */ m(G$, { children: n }) })
  ] })
), PQ = 200, Hw = 15, [WQ, sa] = _l("DatePicker"), zQ = C.forwardRef(
  ({
    /**
     * DatePickerCalendar props
     */
    calendarLabel: t,
    className: e,
    initialDate: n,
    locale: r,
    maxDate: i,
    minDate: o,
    monthSelectLabel: s = "Month",
    onChange: a,
    value: c,
    yearSelectLabel: h = "Year",
    /**
     * Combobox props
     */
    hasError: f,
    id: d,
    name: p,
    disabled: v = !1,
    required: w = !1,
    onClear: b,
    clearLabel: y = "Clear",
    size: $ = "M",
    ...A
  }, k) => {
    const T = Os(), R = mf("DatePicker"), _ = r ?? R.locale, D = ui(_, {
      day: "2-digit",
      month: "2-digit",
      year: "numeric"
    }), [P, H] = C.useState(!1), [z, j] = C.useState(null), [K, te] = C.useState(null), [ee, re] = C.useState(null), [de, ie] = C.useState(), [se, X] = Or({
      defaultProp: n ? uo(n) : void 0,
      prop: c ? uo(c) : void 0,
      onChange(Qe) {
        a && a(Qe?.toDate(T));
      }
    }), [ce, be] = C.useMemo(() => {
      const Qe = n ? uo(n) : bg("UTC"), an = o ? uo(o) : Qe.set({ day: 1, month: 1, year: Qe.year - PQ });
      let Ct = i ? uo(i) : Qe.set({ day: 31, month: 12, year: Qe.year + Hw });
      return Ct.compare(an) < 0 && (Ct = an.set({ day: 31, month: 12, year: an.year + Hw })), [an, Ct];
    }, [o, i, n]), [Le, Ae] = C.useState(
      UQ({
        currentValue: se,
        minDate: ce,
        maxDate: be
      })
    ), qe = Vn(), He = C.useRef(null), Ze = (Qe) => {
      b && !v && (ie(""), X(void 0), b(Qe), K?.focus());
    }, xe = C.useCallback(
      (Qe) => {
        Qe && se && Ae(se), H(Qe);
      },
      [se]
    );
    _o(() => {
      if (c) {
        const Qe = uo(c);
        ie(D.format(Qe.toDate(T))), Ae(Qe);
      } else
        ie("");
    }, [c, D, T]), _o(() => {
      if (n && de === void 0) {
        const Qe = uo(n);
        ie(D.format(Qe.toDate(T)));
      }
    }, [n, de, D, T]);
    const { error: Ve, ...Oe } = kn("Combobox"), Ue = !!Ve || f, Ee = Oe.id ?? d, je = Oe.name ?? p, Rt = Oe.required || w;
    let at;
    return Ve ? at = `${Ee}-error` : Oe.hint && (at = `${Ee}-hint`), /* @__PURE__ */ ae(
      WQ,
      {
        calendarDate: Le,
        content: ee,
        contentId: qe,
        disabled: v,
        locale: _,
        minDate: ce,
        maxDate: be,
        open: P,
        onCalendarDateChange: Ae,
        onContentChange: re,
        onOpenChange: xe,
        onTextInputChange: te,
        onTextValueChange: ie,
        onTriggerChange: j,
        onValueChange: X,
        required: Rt,
        textInput: K,
        textValue: de,
        timeZone: T,
        trigger: z,
        value: se,
        children: [
          /* @__PURE__ */ ae(qQ, { className: e, hasError: Ue, size: $, children: [
            /* @__PURE__ */ m(o_, { fill: "neutral500", "aria-hidden": !0 }),
            /* @__PURE__ */ m(jQ, { ref: k, "aria-describedby": at, id: Ee, name: je, ...A }),
            de && b ? /* @__PURE__ */ m(
              Lo,
              {
                size: "XS",
                variant: "ghost",
                onClick: Ze,
                "aria-disabled": v,
                "aria-label": y,
                label: y,
                ref: He,
                children: /* @__PURE__ */ m(Vo, {})
              }
            ) : null
          ] }),
          /* @__PURE__ */ m(V$, { children: /* @__PURE__ */ m(JQ, { label: t, children: /* @__PURE__ */ m(iJ, { monthSelectLabel: s, yearSelectLabel: h }) }) })
        ]
      }
    );
  }
), Pw = (t) => !!t.match(/^[^a-zA-Z]*$/), UQ = ({ currentValue: t, minDate: e, maxDate: n }) => {
  const r = bg("UTC");
  return t || (F0(e, r) === e && V0(n, r) === n ? r : F0(e, r) === r ? e : V0(n, r) === r ? n : r);
}, KQ = "DatePickerTrigger", qQ = C.forwardRef(
  ({ hasError: t, size: e, ...n }, r) => {
    const i = sa(KQ), o = An(r, (a) => i.onTriggerChange(a)), s = () => {
      i.disabled || i.onOpenChange(!0);
    };
    return /* @__PURE__ */ m(
      Js,
      {
        asChild: !0,
        trapped: i.open,
        onMountAutoFocus: (a) => {
          a.preventDefault();
        },
        onUnmountAutoFocus: (a) => {
          document.getSelection()?.empty(), a.preventDefault();
        },
        children: /* @__PURE__ */ m(
          GQ,
          {
            ref: o,
            $hasError: t,
            $size: e,
            ...n,
            hasRadius: !0,
            gap: 3,
            overflow: "hidden",
            background: i.disabled ? "neutral150" : "neutral0",
            onClick: xo(n.onClick, () => {
              i.textInput?.focus();
            }),
            onPointerDown: xo(n.onPointerDown, (a) => {
              const c = a.target;
              c.hasPointerCapture(a.pointerId) && c.releasePointerCapture(a.pointerId), (c.closest("button") ?? c.closest("div")) === a.currentTarget && a.button === 0 && a.ctrlKey === !1 && (s(), i.textInput?.focus());
            })
          }
        )
      }
    );
  }
), GQ = W(ge)`
  border: 1px solid ${({ theme: t, $hasError: e }) => e ? t.colors.danger600 : t.colors.neutral200};
  ${(t) => {
  switch (t.$size) {
    case "S":
      return Ie`
          padding-block: ${t.theme.spaces[1]};
          padding-inline: ${t.theme.spaces[3]};
        `;
    default:
      return Ie`
          padding-block: ${t.theme.spaces[2]};
          padding-inline: ${t.theme.spaces[3]};
        `;
  }
}}

  & > svg {
    flex: 1 0 auto;
  }

  &[data-disabled] {
    color: ${({ theme: t }) => t.colors.neutral600};
    background: ${({ theme: t }) => t.colors.neutral150};
    cursor: not-allowed;
  }

  /* Required to ensure the below inputFocusStyles are adhered too */
  &:focus-visible {
    outline: none;
  }

  ${({ theme: t, $hasError: e }) => Qi()({ theme: t, $hasError: e })};
`, YQ = "DatePickerTextInput", jQ = C.forwardRef(
  ({ placeholder: t, ...e }, n) => {
    const r = sa(YQ), { onTextValueChange: i, textValue: o, onTextInputChange: s, onOpenChange: a, disabled: c, locale: h } = r, f = An(n, ($) => s($)), d = () => {
      c || a(!0);
    }, p = ui(h, {
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    }), [v, w, b] = C.useMemo(() => {
      const $ = p.formatToParts(/* @__PURE__ */ new Date()), A = $.filter(
        (R) => R.type === "year" || R.type === "month" || R.type === "day"
      ), k = A.map((R) => {
        switch (R.type) {
          case "day":
            return "DD";
          case "month":
            return "MM";
          case "year":
            return "YYYY";
          default:
            return "";
        }
      }), T = $.find((R) => R.type === "literal")?.value ?? "";
      return [k, T, A];
    }, [p]), y = v.map(($) => `\\d{${$.length}}`).join(`\\${w}`);
    return /* @__PURE__ */ m(
      ZQ,
      {
        role: "combobox",
        type: "text",
        inputMode: "numeric",
        ref: f,
        "aria-autocomplete": "none",
        "aria-controls": r.contentId,
        "aria-disabled": r.disabled,
        "aria-expanded": r.open,
        "aria-required": r.required,
        "aria-haspopup": "dialog",
        "data-state": r.open ? "open" : "closed",
        disabled: c,
        "data-disabled": c ? "" : void 0,
        pattern: y,
        placeholder: t ?? v.join(w),
        ...e,
        value: o ?? "",
        onBlur: xo(e.onBlur, () => {
          if (!r.textValue) {
            r.onValueChange(void 0);
            return;
          }
          r.onTextValueChange(p.format(r.calendarDate.toDate(r.timeZone))), r.onValueChange(r.calendarDate);
        }),
        onChange: xo(e.onChange, ($) => {
          if (Pw($.target.value)) {
            const A = $.target.value.split(w), [k, T, R] = b.map((te, ee) => {
              const re = A[ee];
              return {
                ...te,
                value: re
              };
            }).sort((te, ee) => te.type === "year" ? 1 : ee.type === "year" ? -1 : te.type === "month" ? 1 : ee.type === "month" ? -1 : 0).map((te) => te.value), _ = r.calendarDate.year;
            let D = r.calendarDate.year;
            if (R) {
              const te = R.length === 1 ? `0${R}` : R;
              D = R.length < 3 ? Number(`${_}`.slice(0, 4 - te.length) + te) : Number(te);
            }
            R && R.length < 3 && D > r.maxDate.year && (D -= 100);
            const P = r.calendarDate.set({ year: D }), H = P.calendar.getMonthsInYear(P), z = P.set({
              month: T && Number(T) <= H ? Number(T) : void 0
            }), j = z.calendar.getDaysInMonth(z), K = z.set({
              day: k && Number(k) <= j ? Number(k) : void 0
            });
            r.onCalendarDateChange(XQ(K, r.minDate, r.maxDate)), r.onTextValueChange($.target.value);
          }
        }),
        onKeyDown: xo(e.onKeyDown, ($) => {
          if (!r.open && (Pw($.key) || ["ArrowDown", "Backspace"].includes($.key)))
            d();
          else if (["Tab"].includes($.key) && r.open)
            $.preventDefault();
          else if (["Escape"].includes($.key))
            r.open ? r.onOpenChange(!1) : (r.onValueChange(void 0), r.onTextValueChange("")), $.preventDefault();
          else if (r.open && ["ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"].includes($.key))
            switch ($.preventDefault(), $.key) {
              case "ArrowDown": {
                const A = r.calendarDate.add({ weeks: 1 });
                if (r.maxDate && A.compare(r.maxDate) > 0)
                  return;
                r.onCalendarDateChange(A);
                return;
              }
              case "ArrowRight": {
                const A = r.calendarDate.add({ days: 1 });
                if (r.maxDate && A.compare(r.maxDate) > 0)
                  return;
                r.onCalendarDateChange(A);
                return;
              }
              case "ArrowUp": {
                const A = r.calendarDate.subtract({ weeks: 1 });
                if (r.minDate && A.compare(r.minDate) < 0)
                  return;
                r.onCalendarDateChange(A);
                return;
              }
              case "ArrowLeft": {
                const A = r.calendarDate.subtract({ days: 1 });
                if (r.minDate && A.compare(r.minDate) < 0)
                  return;
                r.onCalendarDateChange(A);
              }
            }
          else r.open && ["Enter"].includes($.key) && ($.preventDefault(), i(p.format(r.calendarDate.toDate(r.timeZone))), r.onValueChange(r.calendarDate), r.onOpenChange(!1));
        })
      }
    );
  }
);
function XQ(t, e, n) {
  return e && (t = V0(t, e)), n && (t = F0(t, n)), t;
}
const ZQ = W.input`
  width: 100%;
  font-size: 1.4rem;
  line-height: 2.2rem;
  color: ${({ theme: t }) => t.colors.neutral800};
  border: none;
  background-color: transparent;

  &:focus-visible {
    outline: none;
  }

  &[aria-disabled='true'] {
    cursor: inherit;
  }
`, QQ = "DatePickerContent", JQ = C.forwardRef((t, e) => {
  const [n, r] = C.useState(), i = sa(QQ);
  if (_o(() => {
    r(new DocumentFragment());
  }, []), !i.open) {
    const o = n;
    return o ? Xw(/* @__PURE__ */ m("div", { children: t.children }), o) : null;
  }
  return /* @__PURE__ */ m(tJ, { ...t, ref: e });
}), eJ = "DatePickerContent", tJ = C.forwardRef(
  (t, e) => {
    const { label: n = "Choose date", ...r } = t, { onOpenChange: i, ...o } = sa(eJ), { x: s, y: a, refs: c, strategy: h, placement: f } = tP({
      strategy: "fixed",
      placement: "bottom-start",
      middleware: [
        nP({
          mainAxis: 4
        }),
        rP(),
        iP()
      ],
      elements: {
        reference: o.trigger
      },
      whileElementsMounted: M3
    });
    C.useEffect(() => {
      const p = () => {
        i(!1);
      };
      return window.addEventListener("blur", p), window.addEventListener("resize", p), () => {
        window.removeEventListener("blur", p), window.removeEventListener("resize", p);
      };
    }, [i]);
    const d = An(
      e,
      (p) => o.onContentChange(p),
      c.setFloating
    );
    return Qs(), /* @__PURE__ */ m(Lh, { allowPinchZoom: !0, children: /* @__PURE__ */ m(
      kQ,
      {
        asChild: !0,
        onFocusOutside: (p) => {
          p.preventDefault();
        },
        onDismiss: () => {
          i(!1);
        },
        children: /* @__PURE__ */ m(
          nJ,
          {
            ref: d,
            "data-state": o.open ? "open" : "closed",
            "data-side": f.includes("top") ? "top" : "bottom",
            onContextMenu: (p) => p.preventDefault(),
            id: o.contentId,
            role: "dialog",
            "aria-modal": "true",
            "aria-label": n,
            style: {
              left: s,
              top: a,
              position: h
            },
            hasRadius: !0,
            background: "neutral0",
            padding: 1,
            ...r
          }
        )
      }
    ) });
  }
), nJ = W($e)`
  box-shadow: ${({ theme: t }) => t.shadows.filterShadow};
  z-index: ${({ theme: t }) => t.zIndices.popover};
  border: 1px solid ${({ theme: t }) => t.colors.neutral150};

  @media (prefers-reduced-motion: no-preference) {
    animation-duration: ${(t) => t.theme.motion.timings[200]};

    &[data-state='open'] {
      animation-timing-function: ${(t) => t.theme.motion.easings.authenticMotion};

      &[data-side='top'] {
        animation-name: ${kt.slideUpIn};
      }

      &[data-side='bottom'] {
        animation-name: ${kt.slideDownIn};
      }
    }
  }
`, rJ = "DatePickerCalendar", iJ = C.forwardRef(
  ({ monthSelectLabel: t, yearSelectLabel: e, ...n }, r) => {
    const { locale: i, timeZone: o, minDate: s, maxDate: a, calendarDate: c, onCalendarDateChange: h } = sa(rJ), f = YT(c), d = C.useMemo(() => {
      const k = s.year, T = a.year;
      return [...Array(T - k + 1).keys()].map((R) => (k + R).toString());
    }, [s, a]), p = ui(i, { month: "long" }), v = C.useMemo(
      () => [...Array(c.calendar.getMonthsInYear(c)).keys()].map(
        (k) => p.format(c.set({ month: k + 1 }).toDate(o))
      ),
      [c, p, o]
    ), w = ui(i, { weekday: "short" }), b = C.useMemo(() => {
      const k = t3(bg(o), i);
      return [...new Array(7).keys()].map((T) => {
        const _ = k.add({ days: T }).toDate(o);
        return w.format(_);
      });
    }, [o, i, w]), y = (k) => {
      if (typeof k == "number")
        return;
      const T = c.set({ month: v.indexOf(k) + 1 });
      h(T);
    }, $ = (k) => {
      if (typeof k == "number")
        return;
      const T = c.set({ year: parseInt(k, 10) });
      h(T);
    }, A = oJ(f, i);
    return /* @__PURE__ */ ae(ge, { ref: r, direction: "column", alignItems: "stretch", padding: 4, ...n, children: [
      /* @__PURE__ */ ae(sJ, { justifyContent: "flex-start", paddingBottom: 4, paddingLeft: 2, paddingRight: 2, gap: 2, children: [
        /* @__PURE__ */ m(Bo, { children: /* @__PURE__ */ m(
          Fw,
          {
            "aria-label": t,
            value: v[c.month - 1],
            onChange: y,
            children: v.map((k) => /* @__PURE__ */ m(Vw, { value: k, children: k }, k))
          }
        ) }),
        /* @__PURE__ */ m(Bo, { children: /* @__PURE__ */ m(Fw, { value: c.year.toString(), "aria-label": e, onChange: $, children: d.map((k) => /* @__PURE__ */ m(Vw, { value: k, children: k }, k)) }) })
      ] }),
      /* @__PURE__ */ ae("table", { role: "grid", children: [
        /* @__PURE__ */ m("thead", { "aria-hidden": !0, children: /* @__PURE__ */ m("tr", { "aria-rowindex": 0, children: b.map((k, T) => /* @__PURE__ */ m(aJ, { "aria-colindex": T, children: k }, k)) }) }),
        /* @__PURE__ */ m("tbody", { children: [...new Array(6).keys()].map((k) => /* @__PURE__ */ m("tr", { "aria-rowindex": k + 2, children: A(k).map(
          (T, R) => T ? /* @__PURE__ */ m(
            uJ,
            {
              "aria-colindex": R + 1,
              date: T,
              startDate: f,
              disabled: s.compare(T) > 0 || T.compare(a) > 0
            },
            T.toString()
          ) : /* @__PURE__ */ m(Y$, { "aria-colindex": R + 1 }, R + 1)
        ) }, k)) })
      ] })
    ] });
  }
), oJ = (t, e) => (n) => {
  let r = t.add({ weeks: n });
  const i = [];
  r = t3(r, e);
  const o = Jw(r, e);
  for (let s = 0; s < o; s++)
    i.push(null);
  for (; i.length < 7; ) {
    i.push(r);
    const s = r.add({ days: 1 });
    if (Qw(r, s))
      break;
    r = s;
  }
  for (; i.length < 7; )
    i.push(null);
  return i;
}, sJ = W(ge)`
  div[role='combobox'] {
    border: 1px solid transparent;
    background: transparent;
    font-weight: ${(t) => t.theme.fontWeights.bold};

    svg {
      fill: ${({ theme: t }) => t.colors.neutral500};
    }

    &:hover {
      background-color: ${({ theme: t }) => t.colors.neutral100};
    }
  }
`, aJ = C.forwardRef(
  ({ children: t, ...e }, n) => /* @__PURE__ */ m(lJ, { tag: "th", role: "gridcell", ref: n, ...e, height: "2.4rem", width: "3.2rem", children: /* @__PURE__ */ m(_e, { variant: "pi", fontWeight: "bold", color: "neutral800", children: t.slice(0, 2) }) })
), lJ = W($e)`
  border-radius: ${({ theme: t }) => t.borderRadius};
  text-transform: capitalize;
`, cJ = "DatePickerCalendarCell", uJ = C.forwardRef(
  ({ date: t, startDate: e, disabled: n, ...r }, i) => {
    const { timeZone: o, locale: s, calendarDate: a, onValueChange: c, onOpenChange: h, onTextValueChange: f, onCalendarDateChange: d } = sa(cJ), p = Qw(a, t), v = ui(s, {
      weekday: "long",
      day: "numeric",
      month: "long",
      year: "numeric"
    }), w = C.useMemo(() => v.format(t.toDate(o)), [v, t, o]), b = ui(s, {
      day: "numeric",
      calendar: t.calendar.identifier
    }), y = C.useMemo(
      () => b.formatToParts(t.toDate(o)).find((R) => R.type === "day").value,
      [b, t, o]
    ), $ = ui(s, {
      day: "2-digit",
      month: "2-digit",
      year: "numeric"
    }), A = jT(e), k = t.compare(e) < 0 || t.compare(A) > 0;
    let T = "neutral900";
    return p ? T = "primary600" : k && (T = "neutral600"), /* @__PURE__ */ m(
      Y$,
      {
        tag: "td",
        role: "gridcell",
        ref: i,
        "aria-selected": p,
        ...r,
        hasRadius: !0,
        "aria-label": w,
        tabIndex: p ? 0 : -1,
        background: p ? "primary100" : "neutral0",
        cursor: "pointer",
        onPointerDown: xo(r.onPointerDown, (R) => {
          R.preventDefault(), d(t), c(t), f($.format(t.toDate(o))), h(!1);
        }),
        "aria-disabled": n,
        children: /* @__PURE__ */ m(_e, { variant: "pi", textColor: T, children: y })
      }
    );
  }
), Y$ = W($e)`
  text-align: center;
  padding: 0.7rem;
  // Trick to prevent the outline from overflowing because of the general outline-offset
  outline-offset: -2px !important;
  &[aria-disabled='true'] {
    pointer-events: none;
    opacity: 0.5;
  }

  &[aria-disabled='false'] {
    &:hover {
      background: ${({ theme: t }) => t.colors.primary100};
      color: ${({ theme: t }) => t.colors.primary600};
    }
  }
`, uo = (t) => {
  const e = t.toISOString(), n = f3(e, "UTC");
  return o3(n);
}, L0 = (t) => !!t.match(/^[^a-zA-Z]*$/);
function hJ(t = "") {
  return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
const fJ = C.forwardRef(
  ({ step: t = 15, value: e, defaultValue: n, onChange: r, ...i }, o) => {
    const s = mf("TimePicker"), [a, c] = C.useState(""), [h, f] = Or({
      prop: e,
      defaultProp: n,
      onChange: r
    }), d = ui(s.locale, {
      hour: "2-digit",
      minute: "2-digit",
      hour12: !1
    }), p = C.useMemo(() => {
      const T = d.formatToParts(/* @__PURE__ */ new Date()), { value: R } = T.find((_) => _.type === "literal");
      return R;
    }, [d]), v = C.useMemo(() => {
      const T = 60 / t;
      return [...Array(24).keys()].flatMap(
        (R) => [...Array(T).keys()].map((_) => d.format(new Date(0, 0, 0, R, _ * t)))
      );
    }, [t, d]), w = (T) => {
      (!T || L0(T)) && c(T);
    }, b = (T) => {
      const [R, _] = T.split(p);
      if (!R && !_)
        return;
      const D = Number(R ?? "0"), P = Number(_ ?? "0");
      if (!(D > 23 || P > 59))
        return d.format(new Date(0, 0, 0, D, P));
    }, y = (T) => {
      const R = b(T.target.value);
      R ? (c(R), f(R)) : c(h);
    }, $ = (T) => {
      if (typeof T < "u") {
        const R = b(T);
        f(R);
      } else
        f(T);
    };
    C.useEffect(() => {
      const T = typeof e > "u" ? "" : e;
      L0(T) && c(T);
    }, [e, c]);
    const k = `\\d{2}${hJ(p)}\\d{2}`;
    return /* @__PURE__ */ m(
      nQ,
      {
        ...i,
        ref: o,
        value: h,
        onChange: $,
        isPrintableCharacter: L0,
        allowCustomValue: !0,
        placeholder: `--${p}--`,
        autocomplete: "none",
        startIcon: /* @__PURE__ */ m(R_, { fill: "neutral500" }),
        inputMode: "numeric",
        pattern: k,
        textValue: a,
        onTextValueChange: w,
        onBlur: y,
        children: v.map((T) => /* @__PURE__ */ m(cQ, { value: T, children: T }, T))
      }
    );
  }
), dJ = W(zQ)`
  flex: 1 1 70%;
  min-width: 120px;
`, gJ = W(fJ)`
  flex: 1 1 30%;
  min-width: 140px;
`;
C.forwardRef(
  ({
    clearLabel: t = "clear",
    dateLabel: e = "Choose date",
    timeLabel: n = "Choose time",
    disabled: r = !1,
    hasError: i,
    onChange: o,
    onClear: s,
    required: a = !1,
    step: c,
    value: h,
    initialDate: f,
    size: d,
    ...p
  }, v) => {
    const w = C.useRef(null), [b, y] = Or({
      defaultProp: f ? Ea(f, !1) : void 0,
      prop: h ? Ea(h, !1) : h ?? void 0,
      onChange(te) {
        o && o(te?.toDate(Os()));
      }
    }), $ = mf("DateTimePicker"), A = ui($.locale, {
      hour: "2-digit",
      minute: "2-digit",
      hour12: !1
    }), k = b ? A.format(b.toDate(Os())) : "", T = (te) => {
      let ee = te ? Ea(te) : void 0;
      if (!(ee && b && ee.compare(b) === 0)) {
        if (k && ee) {
          const [re, de] = k.split(":");
          ee = ee.set({ hour: parseInt(re, 10), minute: parseInt(de, 10) });
        }
        y(ee);
      }
    }, R = (te) => {
      if (!te)
        return;
      const [ee, re] = te.split(":"), de = b ? b.set({ hour: parseInt(ee, 10), minute: parseInt(re, 10) }) : Ea(/* @__PURE__ */ new Date()).set({
        hour: parseInt(ee, 10),
        minute: parseInt(re, 10)
      });
      y(de);
    }, _ = (te) => {
      y(void 0), s && s(te);
    }, D = () => {
      const te = b ? b.set({ hour: 0, minute: 0 }) : Ea(/* @__PURE__ */ new Date());
      y(te);
    }, P = An(w, v), { error: H, id: z, labelNode: j } = kn("DateTimePicker"), K = !!H || i;
    return /* @__PURE__ */ ae(ge, { "aria-labelledby": j ? `${z}-label` : void 0, role: "group", flex: "1", gap: 1, children: [
      /* @__PURE__ */ m(Bo, { children: /* @__PURE__ */ m(
        dJ,
        {
          ...p,
          size: d,
          value: b?.toDate("UTC"),
          onChange: T,
          required: a,
          onClear: s ? _ : void 0,
          clearLabel: `${t} date`,
          disabled: r,
          ref: P,
          "aria-label": e
        }
      ) }),
      /* @__PURE__ */ m(Bo, { children: /* @__PURE__ */ m(
        gJ,
        {
          size: d,
          hasError: K,
          value: k,
          onChange: R,
          onClear: s && k !== void 0 && k !== "00:00" ? D : void 0,
          clearLabel: `${t} time`,
          required: a,
          disabled: r,
          step: c,
          "aria-label": n
        }
      ) })
    ] });
  }
);
const Ea = (t, e = !0) => {
  const n = t.toISOString();
  let r = uR(n);
  return e && (r = r.set({ hour: 0, minute: 0 })), Ao(r);
}, pJ = C.forwardRef((t, e) => /* @__PURE__ */ m(
  mJ,
  {
    ref: e,
    background: "neutral150",
    ...t,
    "data-orientation": "horizontal",
    role: "separator",
    tag: "div"
  }
)), mJ = W($e)`
  height: 1px;
  border: none;
  /* If contained in a Flex parent we want to prevent the Divider to shink */
  flex-shrink: 0;
`, vJ = W($e)`
  svg {
    height: 8.8rem;
  }
`;
C.forwardRef(
  ({ icon: t, content: e, action: n, hasRadius: r = !0, shadow: i = "tableShadow" }, o) => /* @__PURE__ */ ae(
    ge,
    {
      ref: o,
      alignItems: "center",
      direction: "column",
      padding: 11,
      background: "neutral0",
      hasRadius: r,
      shadow: i,
      children: [
        t ? /* @__PURE__ */ m(vJ, { paddingBottom: 6, "aria-hidden": !0, children: t }) : null,
        /* @__PURE__ */ m($e, { paddingBottom: 4, children: /* @__PURE__ */ m(_e, { variant: "delta", tag: "p", textAlign: "center", textColor: "neutral600", children: e }) }),
        n
      ]
    }
  )
);
const j$ = Ne.define(), X$ = Ne.define(), bJ = Se.mark({
  attributes: { style: "background-color: yellow; color: black" }
}), wJ = Kt.define({
  // Start with an empty set of decorations
  create() {
    return Se.none;
  },
  // This is called whenever the editor updates it computes the new set
  update(t, e) {
    return t = t.map(e.changes), e.effects.forEach((n) => {
      n.is(j$) ? t = t.update({
        add: n.value,
        sort: !0
      }) : n.is(X$) && (t = t.update({ filter: n.value }));
    }), t;
  },
  // Indicate that this field provides a set of decorations
  provide: (t) => fe.decorations.from(t)
});
C.forwardRef(
  ({
    hasError: t,
    required: e,
    id: n,
    value: r = "",
    disabled: i = !1,
    onChange: o = () => null,
    ...s
  }, a) => {
    const c = C.useRef(), h = C.useRef(), f = C.useRef(), { error: d, ...p } = kn("JsonInput"), v = !!d || t, w = p.id ?? n, b = p.required || e;
    let y;
    d ? y = `${w}-error` : p.hint && (y = `${w}-hint`);
    const $ = (H) => {
      const z = h.current?.doc;
      if (z) {
        const { text: j, to: K } = z.line(H), te = K - j.trimStart().length;
        K > te && f.current?.dispatch({
          effects: j$.of([bJ.range(te, K)])
        });
      }
    }, A = () => {
      const H = h.current?.doc;
      if (H) {
        const z = H.length || 0;
        f.current?.dispatch({
          effects: X$.of((j, K) => K <= 0 || j >= z)
        });
      }
    }, k = ({ state: H, view: z }) => {
      f.current = z, h.current = H, A();
      const K = SK()(z);
      K.length && $(H.doc.lineAt(K[0].from).number);
    }, T = (H, z) => {
      k(z), o(H);
    }, R = (H, z) => {
      f.current = H, h.current = z, k({ view: H, state: z });
    }, { setContainer: _, view: D } = BC({
      value: r,
      onCreateEditor: R,
      container: c.current,
      editable: !i,
      extensions: [MK(), wJ],
      onChange: T,
      theme: "dark",
      basicSetup: {
        lineNumbers: !0,
        bracketMatching: !0,
        closeBrackets: !0,
        indentOnInput: !0,
        syntaxHighlighting: !0,
        highlightSelectionMatches: !0,
        tabSize: 2
      }
    }), P = An(c, _);
    return C.useImperativeHandle(
      a,
      () => ({
        ...D?.dom,
        focus() {
          D && D.focus();
        },
        scrollIntoView(H) {
          D && D.dom.scrollIntoView(H);
        }
      }),
      [D]
    ), /* @__PURE__ */ m(
      xJ,
      {
        ref: P,
        $disabled: i,
        $hasError: v,
        alignItems: "stretch",
        fontSize: 2,
        hasRadius: !0,
        "aria-required": b,
        id: w,
        "aria-describedby": y,
        ...s
      }
    );
  }
);
const xJ = W(ge)`
  line-height: ${({ theme: t }) => t.lineHeights[2]};

  .cm-editor {
    /** 
     * Hard coded since the color is the same between themes,
     * theme.colors.neutral800 changes between themes 
     */
    background-color: #32324d;
    width: 100%;
    outline: none;
    cursor: ${({ $disabled: t }) => t ? "not-allowed" : "text"};
  }

  .cm-scroller {
    border: 1px solid ${({ theme: t, $hasError: e }) => e ? t.colors.danger600 : t.colors.neutral200};
    /* inputFocusStyle will receive hasError prop */
    ${Qi()}
  }

  .cm-editor,
  .cm-scroller {
    border-radius: ${({ theme: t }) => t.borderRadius};
  }

  .cm-gutters,
  .cm-activeLineGutter {
    /** 
     * Hard coded since the color is the same between themes,
     * theme.colors.neutral700 changes between themes 
     */
    background-color: #4a4a6a;
  }
`;
gn(
  ({ disabled: t, ...e }, n) => /* @__PURE__ */ m(
    dg,
    {
      ref: n,
      tag: Ll,
      tabIndex: t ? -1 : void 0,
      disabled: t,
      ...e
    }
  )
);
W($e)`
  // To prevent global outline on focus visible to force an outline when Main is focused
  &:focus-visible {
    outline: none;
  }
`;
W($e)`
  text-decoration: none;

  &:focus {
    left: ${({ theme: t }) => t.spaces[3]};
    top: ${({ theme: t }) => t.spaces[3]};
  }
`;
const yJ = Dy, CJ = C.forwardRef((t, e) => /* @__PURE__ */ m(Iy, { ...t, asChild: !0, ref: e })), $J = C.forwardRef((t, e) => /* @__PURE__ */ ae(_y, { children: [
  /* @__PURE__ */ m(SJ, {}),
  /* @__PURE__ */ m(AJ, { ref: e, ...t })
] })), SJ = W(Ly)`
  background-color: ${(t) => t.theme.colors.neutral800};
  position: fixed;
  inset: 0;
  z-index: ${(t) => t.theme.zIndices.overlay};
  opacity: 0.2;
  will-change: opacity;

  @media (prefers-reduced-motion: no-preference) {
    animation: ${kt.overlayFadeIn} ${(t) => t.theme.motion.timings[200]}
      ${(t) => t.theme.motion.easings.authenticMotion};
  }
`, AJ = W(By)`
  max-width: 83rem;
  max-height: 90vh;
  height: auto;
  width: 60%;
  overflow: hidden;
  margin: 0 auto;
  display: flex;
  flex-direction: column;

  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);

  border-radius: ${(t) => t.theme.borderRadius};
  background-color: ${(t) => t.theme.colors.neutral0};
  box-shadow: ${(t) => t.theme.shadows.popupShadow};
  z-index: ${(t) => t.theme.zIndices.modal};

  @media (prefers-reduced-motion: no-preference) {
    &[data-state='open'] {
      animation-duration: ${(t) => t.theme.motion.timings[200]};
      animation-timing-function: ${(t) => t.theme.motion.easings.authenticMotion};
      animation-name: ${kt.modalPopIn};
    }

    &[data-state='closed'] {
      animation-duration: ${(t) => t.theme.motion.timings[120]};
      animation-timing-function: ${(t) => t.theme.motion.easings.easeOutQuad};
      animation-name: ${kt.modalPopOut};
    }
  }
`, Z$ = C.forwardRef((t, e) => /* @__PURE__ */ m(xp, { ...t, asChild: !0, ref: e })), kJ = C.forwardRef(
  ({ children: t, closeLabel: e = "Close modal", ...n }, r) => /* @__PURE__ */ ae(
    MJ,
    {
      ref: r,
      padding: 4,
      paddingLeft: 5,
      paddingRight: 5,
      background: "neutral100",
      justifyContent: "space-between",
      ...n,
      tag: "header",
      children: [
        t,
        /* @__PURE__ */ m(Z$, { children: /* @__PURE__ */ m(Lo, { withTooltip: !1, label: e, children: /* @__PURE__ */ m(Vo, {}) }) })
      ]
    }
  )
), MJ = W(ge)`
  border-bottom: solid 1px ${(t) => t.theme.colors.neutral150};
`, TJ = C.forwardRef((t, e) => /* @__PURE__ */ m(Ny, { asChild: !0, children: /* @__PURE__ */ m(_e, { tag: "h2", variant: "omega", fontWeight: "bold", ref: e, ...t }) })), RJ = C.forwardRef(({ children: t, ...e }, n) => /* @__PURE__ */ m(EJ, { ref: n, ...e, children: t })), EJ = W(pf)`
  padding-inline: ${(t) => t.theme.spaces[8]};

  & > div {
    padding-block: ${(t) => t.theme.spaces[8]};

    & > div {
      // the scroll area component applies a display: table to the child, which we don't want.
      display: block !important;
    }
  }
`, OJ = C.forwardRef((t, e) => /* @__PURE__ */ m(
  DJ,
  {
    ref: e,
    padding: 4,
    paddingLeft: 5,
    paddingRight: 5,
    background: "neutral100",
    justifyContent: "space-between",
    ...t,
    tag: "footer"
  }
)), DJ = W(ge)`
  border-top: solid 1px ${(t) => t.theme.colors.neutral150};
  flex: 1;
`, nne = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Body: RJ,
  Close: Z$,
  Content: $J,
  Footer: OJ,
  Header: kJ,
  Root: yJ,
  Title: TJ,
  Trigger: CJ
}, Symbol.toStringTag, { value: "Module" })), IJ = "";
C.forwardRef(
  ({ startAction: t, locale: e, onValueChange: n, value: r, step: i = 1, disabled: o = !1, ...s }, a) => {
    const c = mf("NumberInput"), h = e || c.locale, f = C.useRef(new VC(h, { style: "decimal" })), d = C.useRef(new FC(h, { maximumFractionDigits: 20 })), [p, v] = _J({
      prop(_) {
        const D = String(r);
        return isNaN(Number(D)) || D !== _ && _ !== "" ? _ : d.current.format(Number(r));
      },
      defaultProp: IJ,
      onChange(_) {
        const D = f.current.parse(_ ?? "");
        n(isNaN(D) ? void 0 : D);
      }
    }), w = (_) => {
      v(String(_));
    }, b = ({ target: { value: _ } }) => {
      f.current.isValidPartialNumber(_) && w(_);
    }, $ = ((_) => {
      const D = _.toString();
      return D.includes(".") ? D.split(".")[1].length : 0;
    })(i), A = () => {
      if (!p) {
        w(i);
        return;
      }
      const _ = f.current.parse(p), D = isNaN(_) ? i : _ + i, P = parseFloat(D.toFixed($));
      w(d.current.format(P));
    }, k = () => {
      if (!p) {
        w(-i);
        return;
      }
      const _ = f.current.parse(p), D = isNaN(_) ? -i : _ - i, P = parseFloat(D.toFixed($));
      w(d.current.format(P));
    };
    return /* @__PURE__ */ m(
      gf,
      {
        ref: a,
        startAction: t,
        disabled: o,
        type: "text",
        inputMode: "decimal",
        onChange: b,
        onKeyDown: (_) => {
          if (!o)
            switch (_.key) {
              case Bt.DOWN: {
                _.preventDefault(), k();
                break;
              }
              case Bt.UP: {
                _.preventDefault(), A();
                break;
              }
            }
        },
        onBlur: () => {
          if (p) {
            const _ = f.current.parse(p), D = isNaN(_) ? "" : d.current.format(_);
            w(D);
          }
        },
        value: p,
        endAction: /* @__PURE__ */ ae(ge, { direction: "column", children: [
          /* @__PURE__ */ m(
            Ww,
            {
              disabled: o,
              "aria-hidden": !0,
              $reverse: !0,
              onClick: A,
              tabIndex: -1,
              type: "button",
              "data-testid": "ArrowUp",
              children: /* @__PURE__ */ m(Wi, { fill: "neutral500" })
            }
          ),
          /* @__PURE__ */ m(
            Ww,
            {
              disabled: o,
              "aria-hidden": !0,
              onClick: k,
              tabIndex: -1,
              type: "button",
              "data-testid": "ArrowDown",
              children: /* @__PURE__ */ m(Wi, { fill: "neutral500" })
            }
          )
        ] }),
        ...s
      }
    );
  }
);
const Ww = W.button`
  display: flex;
  justify-content: center;
  align-items: center;
  transform: translateY(${({ $reverse: t }) => t ? "-2px" : "2px"});
  cursor: ${({ disabled: t }) => t ? "not-allowed" : void 0};
  height: 1.1rem;

  svg {
    width: 1.2rem;
    transform: ${({ $reverse: t }) => t ? "rotateX(180deg)" : void 0};
  }
`;
function _J({
  prop: t,
  defaultProp: e,
  onChange: n = () => {
  }
}) {
  const [r, i] = v$({
    defaultProp: e,
    onChange: n
  }), o = t !== void 0, s = t instanceof Function ? t(r) : t, a = o ? s : r, c = Hg(n), h = C.useCallback(
    (f) => {
      if (o) {
        const p = typeof f == "function" ? f(s) : f;
        p !== s && (c(p), i(f));
      } else
        i(f);
    },
    [o, s, i, c]
  );
  return [a, h];
}
const LJ = C.createContext({ activePage: 1, pageCount: 1 }), cm = () => C.useContext(LJ);
gn(
  ({ children: t, ...e }, n) => {
    const { activePage: r } = cm(), i = r === 1;
    return /* @__PURE__ */ ae(J$, { ref: n, "aria-disabled": i, tabIndex: i ? -1 : void 0, ...e, children: [
      /* @__PURE__ */ m(zo, { children: t }),
      /* @__PURE__ */ m(Vx, { "aria-hidden": !0 })
    ] });
  }
);
gn(
  ({ children: t, ...e }, n) => {
    const { activePage: r, pageCount: i } = cm(), o = r === i;
    return /* @__PURE__ */ ae(J$, { ref: n, "aria-disabled": o, tabIndex: o ? -1 : void 0, ...e, children: [
      /* @__PURE__ */ m(zo, { children: t }),
      /* @__PURE__ */ m(up, { "aria-hidden": !0 })
    ] });
  }
);
const Q$ = W(Ll)`
  padding: ${({ theme: t }) => t.spaces[3]};
  border-radius: ${({ theme: t }) => t.borderRadius};
  box-shadow: ${({ $active: t, theme: e }) => t ? e.shadows.filterShadow : void 0};
  text-decoration: none;
  display: flex;

  ${hf}
`, J$ = W(Q$)`
  font-size: 1.1rem;

  svg path {
    fill: ${(t) => t["aria-disabled"] ? t.theme.colors.neutral300 : t.theme.colors.neutral600};
  }

  &:focus,
  &:hover {
    svg path {
      fill: ${(t) => t["aria-disabled"] ? t.theme.colors.neutral300 : t.theme.colors.neutral700};
    }
  }

  ${(t) => t["aria-disabled"] ? `
  pointer-events: none;
    ` : void 0}
`;
gn(
  ({ number: t, children: e, ...n }, r) => {
    const { activePage: i } = cm(), o = i === t;
    return /* @__PURE__ */ ae(BJ, { ref: r, ...n, "aria-current": o, $active: o, children: [
      /* @__PURE__ */ m(zo, { children: e }),
      /* @__PURE__ */ m(_e, { "aria-hidden": !0, fontWeight: o ? "bold" : void 0, lineHeight: "revert", variant: "pi", children: t })
    ] });
  }
);
const BJ = W(Q$)`
  color: ${({ theme: t, $active: e }) => e ? t.colors.primary700 : t.colors.neutral800};
  background: ${({ theme: t, $active: e }) => e ? t.colors.neutral0 : void 0};

  &:hover {
    box-shadow: ${({ theme: t }) => t.shadows.filterShadow};
  }
`, NJ = sj, FJ = C.forwardRef((t, e) => /* @__PURE__ */ m(aj, { ...t, asChild: !0, ref: e })), VJ = C.forwardRef((t, e) => /* @__PURE__ */ m(lj, { children: /* @__PURE__ */ m(HJ, { sideOffset: 4, side: "bottom", align: "start", ...t, ref: e }) })), HJ = W(cj)`
  box-shadow: ${({ theme: t }) => t.shadows.filterShadow};
  z-index: ${({ theme: t }) => t.zIndices.popover};
  background-color: ${(t) => t.theme.colors.neutral0};
  border: 1px solid ${({ theme: t }) => t.colors.neutral150};
  border-radius: ${({ theme: t }) => t.borderRadius};

  @media (prefers-reduced-motion: no-preference) {
    animation-duration: ${(t) => t.theme.motion.timings[200]};

    &[data-state='open'] {
      animation-timing-function: ${(t) => t.theme.motion.easings.authenticMotion};

      &[data-side='top'] {
        animation-name: ${kt.slideUpIn};
      }

      &[data-side='bottom'] {
        animation-name: ${kt.slideDownIn};
      }
    }

    &[data-state='closed'] {
      animation-timing-function: ${(t) => t.theme.motion.easings.easeOutQuad};

      &[data-side='top'] {
        animation-name: ${kt.slideUpOut};
      }

      &[data-side='bottom'] {
        animation-name: ${kt.slideDownOut};
      }
    }
  }
`, PJ = C.forwardRef(
  ({ children: t, intersectionId: e, onReachEnd: n, ...r }, i) => {
    const o = C.useRef(null), s = An(o, i), a = Vn();
    return Bl(o, n ?? (() => {
    }), {
      selectorToWatch: `#${qs(a)}`,
      skipWhen: !e || !n
    }), /* @__PURE__ */ ae(WJ, { ref: s, ...r, children: [
      t,
      e && n && /* @__PURE__ */ m($e, { id: qs(a), width: "100%", height: "1px" })
    ] });
  }
), WJ = W(pf)`
  height: 20rem;
`, rne = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Content: VJ,
  Root: NJ,
  ScrollArea: PJ,
  Trigger: FJ
}, Symbol.toStringTag, { value: "Module" }));
C.forwardRef(
  ({ size: t = "M", value: e, ...n }, r) => /* @__PURE__ */ m(zJ, { ref: r, $size: t, ...n, children: /* @__PURE__ */ m(UJ, { style: { transform: `translate3D(-${100 - (e ?? 0)}%, 0, 0)` } }) })
);
const zJ = W(bj)`
  position: relative;
  overflow: hidden;
  width: ${(t) => t.$size === "S" ? "7.8rem" : "10.2rem"};
  height: ${(t) => t.$size === "S" ? "0.4rem" : "0.8rem"};
  background-color: ${(t) => t.theme.colors.neutral600};
  border-radius: ${(t) => t.theme.borderRadius};

  /* Fix overflow clipping in Safari */
  /* https://gist.github.com/domske/b66047671c780a238b51c51ffde8d3a0 */
  transform: translateZ(0);
`, UJ = W(wj)`
  background-color: ${({ theme: t }) => t.colors.neutral0};
  border-radius: ${({ theme: t }) => t.borderRadius};
  width: 100%;
  height: 100%;

  @media (prefers-reduced-motion: no-preference) {
    transition: transform ${(t) => t.theme.motion.timings[320]}
      ${(t) => t.theme.motion.easings.authenticMotion};
  }
`;
C.forwardRef((t, e) => /* @__PURE__ */ m(KJ, { ref: e, ...t }));
const KJ = W(Lj)`
  display: flex;
  flex-direction: column;
  gap: ${(t) => t.theme.spaces[3]};
`;
C.forwardRef(({ children: t, id: e, ...n }, r) => {
  const i = Vn(e);
  return /* @__PURE__ */ ae(ge, { gap: 2, children: [
    /* @__PURE__ */ m(qJ, { id: i, ref: r, ...n, children: /* @__PURE__ */ m(GJ, {}) }),
    /* @__PURE__ */ m(_e, { tag: "label", htmlFor: i, children: t })
  ] });
});
const qJ = W(Bj)`
  background: ${(t) => t.theme.colors.neutral0};
  width: 2rem;
  height: 2rem;
  flex: 0 0 2rem;
  border-radius: 50%;
  border: 1px solid ${(t) => t.theme.colors.neutral300};
  position: relative;
  cursor: pointer;
  z-index: 0;

  @media (prefers-reduced-motion: no-preference) {
    transition: border-color ${(t) => t.theme.motion.timings[120]}
      ${(t) => t.theme.motion.easings.easeOutQuad};
  }

  &[data-state='checked'] {
    border: 1px solid ${(t) => t.theme.colors.primary600};
  }

  &[data-disabled] {
    cursor: not-allowed;
    background-color: ${(t) => t.theme.colors.neutral200};
  }

  /* increase target size for touch devices https://www.w3.org/WAI/WCAG21/Understanding/target-size.html */
  &::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100%;
    height: 100%;
    min-width: 44px;
    min-height: 44px;
  }
`, GJ = W(Nj)`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
  position: relative;

  &[data-state='checked'] {
    @media (prefers-reduced-motion: no-preference) {
      animation: ${kt.popIn} ${(t) => t.theme.motion.timings[200]};
    }
  }

  &::after {
    content: '';
    display: block;
    width: 1rem;
    height: 1rem;
    border-radius: 50%;
    background: ${(t) => t.theme.colors.primary600};
  }
`, YJ = (t) => {
  const e = t.querySelector('[tabindex="0"]');
  e && e.focus();
}, e8 = C.createContext({
  rowIndex: 0,
  colIndex: 0,
  setTableValues() {
    throw new Error("setTableValues must be initialized via the RawTableContext.Provider");
  }
}), jJ = () => C.useContext(e8), XJ = C.forwardRef(
  ({ colCount: t, rowCount: e, jumpStep: n = 3, initialCol: r = 0, initialRow: i = 0, ...o }, s) => {
    const a = C.useRef(null), c = C.useRef(!1), h = An(a, s), [f, d] = C.useState(i), [p, v] = C.useState(r), w = C.useCallback(({ colIndex: $, rowIndex: A }) => {
      v($), d(A);
    }, []);
    C.useEffect(() => {
      c.current && YJ(a.current), c.current || (c.current = !0);
    }, [p, f]);
    const b = ($) => {
      switch ($.key) {
        case Bt.RIGHT: {
          $.preventDefault(), v((A) => A < t - 1 ? A + 1 : A);
          break;
        }
        case Bt.LEFT: {
          $.preventDefault(), v((A) => A > 0 ? A - 1 : A);
          break;
        }
        case Bt.UP: {
          $.preventDefault(), d((A) => A > 0 ? A - 1 : A);
          break;
        }
        case Bt.DOWN: {
          $.preventDefault(), d((A) => A < e - 1 ? A + 1 : A);
          break;
        }
        case Bt.HOME: {
          $.preventDefault(), $.ctrlKey && d(0), v(0);
          break;
        }
        case Bt.END: {
          $.preventDefault(), $.ctrlKey && d(e - 1), v(t - 1);
          break;
        }
        case Bt.PAGE_DOWN: {
          $.preventDefault(), d((A) => A + n < e ? A + n : e - 1);
          break;
        }
        case Bt.PAGE_UP: {
          $.preventDefault(), d((A) => A - n > 0 ? A - n : 0);
          break;
        }
      }
    }, y = C.useMemo(() => ({ rowIndex: f, colIndex: p, setTableValues: w }), [p, f, w]);
    return /* @__PURE__ */ m(e8.Provider, { value: y, children: /* @__PURE__ */ m(
      "table",
      {
        role: "grid",
        ref: h,
        "aria-rowcount": e,
        "aria-colcount": t,
        onKeyDown: b,
        ...o
      }
    ) });
  }
), go = (t, e) => [
  ...t.querySelectorAll(
    'a, button, input, textarea, select, details, [tabindex]:not([tabindex="-1"])'
  )
].filter((i) => i.hasAttribute("disabled") ? !1 : e ? !0 : i.getAttribute("tabindex") !== "-1"), B0 = (t) => t.filter((e) => e.tagName === "INPUT" ? e.type !== "checkbox" && e.type !== "radio" : !1), t8 = C.forwardRef(
  ({ coords: t = { col: 0, row: 0 }, tag: e = "td", ...n }, r) => {
    const i = C.useRef(null), o = An(r, i), { rowIndex: s, colIndex: a, setTableValues: c } = jJ(), [h, f] = C.useState(!1), d = (w) => {
      const b = go(i.current, !0);
      if (b.length === 0 || b.length === 1 && B0(b).length === 0)
        return;
      if (b.length > 1 && !b.find(($) => $.tagName !== "BUTTON")) {
        w.preventDefault();
        const $ = b.findIndex((A) => A === document.activeElement);
        if (w.key === Bt.RIGHT) {
          const A = b[$ + 1];
          A && (w.stopPropagation(), A.focus());
        } else if (w.key === Bt.LEFT) {
          const A = b[$ - 1];
          A && (w.stopPropagation(), A.focus());
        }
        return;
      }
      const y = w.key === Bt.ENTER;
      if (y && !h)
        f(!0);
      else if ((w.key === Bt.ESCAPE || y) && h) {
        if (y && document.activeElement?.tagName === "A")
          return;
        f(!1), i.current.focus();
      } else h && w.stopPropagation();
    }, p = s === t.row - 1 && a === t.col - 1;
    _o(() => {
      const w = go(i.current, !0);
      w.length === 0 || w.length === 1 && B0(w).length !== 0 || w.length > 1 && w.find((b) => b.tagName !== "BUTTON") ? (i.current.setAttribute("tabIndex", !h && p ? "0" : "-1"), w.forEach((b, y) => {
        b.setAttribute("tabIndex", h ? "0" : "-1"), h && y === 0 && b.focus();
      })) : w.forEach((b) => {
        b.setAttribute("tabIndex", p ? "0" : "-1");
      });
    }, [h, p]);
    const v = C.useCallback(() => {
      const w = go(i.current, !0);
      w.length >= 1 && (B0(w).length !== 0 || !w.find((b) => b.tagName !== "BUTTON")) && f(!0), c({ rowIndex: t.row - 1, colIndex: t.col - 1 });
    }, [t, c]);
    return _o(() => {
      const w = i.current;
      return go(w, !0).forEach((y) => {
        y.addEventListener("focus", v);
      }), () => {
        go(w, !0).forEach(($) => {
          $.removeEventListener("focus", v);
        });
      };
    }, [v]), /* @__PURE__ */ m($e, { role: "gridcell", tag: e, ref: o, onKeyDown: d, ...n });
  }
), ZJ = (t) => /* @__PURE__ */ m(t8, { ...t, tag: "th" }), QJ = ({ children: t, ...e }) => {
  const n = C.Children.toArray(t).map((r) => C.isValidElement(r) ? C.cloneElement(r, { "aria-rowindex": 1 }) : r);
  return /* @__PURE__ */ m("thead", { ...e, children: n });
}, JJ = ({ children: t, ...e }) => {
  const n = C.Children.toArray(t).map((r, i) => C.isValidElement(r) ? C.cloneElement(r, { "aria-rowindex": i + 2 }) : r);
  return /* @__PURE__ */ m("tbody", { ...e, children: n });
}, eee = ({ children: t, ...e }) => {
  const n = C.Children.toArray(t).map((r, i) => C.isValidElement(r) ? C.cloneElement(r, {
    "aria-colindex": i + 1,
    coords: { col: i + 1, row: e["aria-rowindex"] }
  }) : r);
  return /* @__PURE__ */ m($e, { tag: "tr", ...e, children: n });
}, tee = W(Vo)`
  font-size: 0.5rem;
  path {
    fill: ${({ theme: t }) => t.colors.neutral500};
  }
`, n8 = W(Px)`
  font-size: 1rem;
  path {
    fill: ${({ theme: t }) => t.colors.neutral500};
  }
`, nee = W.div`
  border-radius: ${({ theme: t }) => t.borderRadius};
  border: 1px solid ${({ theme: t }) => t.colors.neutral150}

  &:focus-within {
    ${n8} {
      fill: ${({ theme: t }) => t.colors.primary600};
    }
  }
`, ree = W(gf)`
  border: 1px solid ${({ theme: t }) => t.colors.neutral150}
  height: 16px;
  padding: 0 0 0 8px;
  color: ${({ theme: t }) => t.colors.neutral800};

  &::placeholder {
    color: ${({ theme: t }) => t.colors.neutral500};
  }

  &:hover {
    button {
      cursor: pointer;
    }
  }

  ${Qi()}
`, iee = C.forwardRef(
  ({ name: t, children: e, value: n = "", onClear: r, clearLabel: i = "Clear", ...o }, s) => {
    const a = C.useRef(null), c = n.length > 0, h = (d) => {
      r(d), a.current.focus();
    }, f = C$(s, a);
    return /* @__PURE__ */ m(nee, { children: /* @__PURE__ */ ae(Bo, { name: t, children: [
      /* @__PURE__ */ m(zo, { children: /* @__PURE__ */ m(am, { children: e }) }),
      /* @__PURE__ */ m(
        ree,
        {
          size: "S",
          ref: f,
          value: n,
          startAction: /* @__PURE__ */ m(n8, { "aria-hidden": !0 }),
          endAction: c ? /* @__PURE__ */ m(
            Lo,
            {
              onClick: h,
              onMouseDown: (d) => {
                d.preventDefault();
              },
              label: i,
              size: "XS",
              variant: "ghost",
              type: "button",
              children: /* @__PURE__ */ m(tee, {})
            }
          ) : void 0,
          ...o
        }
      )
    ] }) });
  }
), oee = (t) => /* @__PURE__ */ m("form", { ...t, role: "search" }), see = W($e)`
  display: inline-flex;
  border: none;

  & > svg {
    height: 1.2rem;
    width: 1.2rem;
  }

  & > svg path {
    fill: ${({ theme: t, ...e }) => e["aria-disabled"] ? t.colors.neutral600 : t.colors.primary600};
  }

  &:hover {
    cursor: ${({ $iconAction: t }) => t ? "pointer" : "initial"};
  }
`, aee = ({ children: t, icon: e, label: n, disabled: r = !1, onClick: i, ...o }) => /* @__PURE__ */ ae(
  ge,
  {
    inline: !0,
    background: r ? "neutral200" : "primary100",
    color: r ? "neutral700" : "primary600",
    paddingLeft: 3,
    paddingRight: 1,
    borderColor: r ? "neutral300" : "primary200",
    hasRadius: !0,
    height: "3.2rem",
    ...o,
    children: [
      /* @__PURE__ */ m(lee, { $disabled: r, variant: "pi", fontWeight: "bold", children: t }),
      /* @__PURE__ */ m(
        see,
        {
          tag: "button",
          disabled: r,
          "aria-disabled": r,
          "aria-label": n,
          padding: 2,
          onClick: (a) => {
            r || !i || i(a);
          },
          $iconAction: !!i,
          children: e
        }
      )
    ]
  }
), lee = W(_e)`
  color: inherit;
  border-right: 1px solid ${({ theme: t, $disabled: e }) => e ? t.colors.neutral300 : t.colors.primary200};
  padding-right: ${({ theme: t }) => t.spaces[2]};
`, ine = C.forwardRef(
  ({
    children: t,
    clearLabel: e = "Clear",
    customizeContent: n,
    disabled: r,
    hasError: i,
    id: o,
    name: s,
    onChange: a,
    onClear: c,
    onCloseAutoFocus: h,
    onReachEnd: f,
    placeholder: d,
    required: p,
    size: v,
    startIcon: w,
    value: b,
    withTags: y,
    ...$
  }, A) => {
    const k = C.useRef(null), [T, R] = C.useState(), [_, D] = C.useState(!1), P = (Ae) => {
      a ? a(Ae) : R(Ae);
    }, H = (Ae) => () => {
      const qe = Array.isArray(b) ? b.filter((He) => He !== Ae) : (T ?? []).filter((He) => He !== Ae);
      a ? a(qe) : R(qe);
    }, z = (Ae) => {
      D(Ae);
    }, j = Vn(), K = `intersection-${qs(j)}`;
    Bl(k, (Ae) => {
      f && f(Ae);
    }, {
      selectorToWatch: `#${K}`,
      /**
       * We need to know when the select is open because only then will viewportRef
       * not be null. Because it uses a portal that (sensibly) is not mounted 24/7.
       */
      skipWhen: !_
    });
    const ee = typeof b < "u" && b !== null ? b : T, re = (Ae) => Ae && typeof Ae == "object" && Ae.value ? /* @__PURE__ */ m(
      aee,
      {
        tabIndex: -1,
        disabled: r,
        icon: /* @__PURE__ */ m(Vo, { width: `${14 / 16}rem`, height: `${14 / 16}rem` }),
        onClick: H(Ae.value),
        children: Ae.textValue
      },
      Ae.value
    ) : null, { error: de, ...ie } = kn("MultiSelect"), se = !!de || i, X = ie.id ?? o, ce = ie.name ?? s, be = ie.required ?? p;
    let Le;
    return de ? Le = `${X}-error` : ie.hint && (Le = `${X}-hint`), /* @__PURE__ */ ae(
      H$,
      {
        onOpenChange: z,
        disabled: r,
        required: be,
        onValueChange: P,
        value: ee,
        ...$,
        multi: !0,
        children: [
          /* @__PURE__ */ m(
            P$,
            {
              ref: A,
              id: X,
              name: ce,
              "aria-label": $["aria-label"],
              "aria-describedby": Le ?? $["aria-describedby"],
              startIcon: w,
              hasError: se,
              disabled: r,
              clearLabel: e,
              onClear: ee?.length ? c : void 0,
              withTags: !!(y && (ee?.length ?? !1)),
              size: v,
              children: /* @__PURE__ */ m(W$, { placeholder: d, textColor: ee?.length ? "neutral800" : "neutral600", children: ee?.length ? y ? re : n ? n(ee) : void 0 : void 0 })
            }
          ),
          /* @__PURE__ */ m(z$, { children: /* @__PURE__ */ m(U$, { position: "popper", sideOffset: 4, onCloseAutoFocus: h, children: /* @__PURE__ */ ae(K$, { ref: k, children: [
            t,
            /* @__PURE__ */ m($e, { id: K, width: "100%", height: "1px" })
          ] }) }) })
        ]
      }
    );
  }
), cee = C.forwardRef(
  ({ value: t, children: e, startIcon: n, ...r }, i) => /* @__PURE__ */ ae(lm, { ref: i, value: t.toString(), ...r, children: [
    n && /* @__PURE__ */ m($e, { tag: "span", "aria-hidden": !0, children: n }),
    /* @__PURE__ */ m(q$, { children: ({ isSelected: o, isIntermediate: s }) => /* @__PURE__ */ m(sm, { checked: s ? "indeterminate" : o }) }),
    /* @__PURE__ */ m(_e, { children: /* @__PURE__ */ m(G$, { children: e }) })
  ] })
);
C.forwardRef(
  ({ children: t, label: e, startIcon: n, values: r = [], ...i }, o) => /* @__PURE__ */ ae(HQ, { ref: o, children: [
    /* @__PURE__ */ ae(lm, { value: r, ...i, children: [
      n && /* @__PURE__ */ m($e, { tag: "span", "aria-hidden": !0, children: n }),
      /* @__PURE__ */ m(q$, { children: ({ isSelected: s, isIntermediate: a }) => /* @__PURE__ */ m(sm, { checked: a ? "indeterminate" : s }) }),
      /* @__PURE__ */ m(_e, { children: e })
    ] }),
    t
  ] })
);
W(cee)`
  padding-left: ${({ theme: t }) => t.spaces[7]};
`;
const uee = "23.2rem", one = C.forwardRef(({ ...t }, e) => /* @__PURE__ */ m(hee, { ref: e, ...t, tag: "nav" })), hee = W($e)`
  width: ${uee};
  background: ${({ theme: t }) => t.colors.neutral100};
  position: sticky;
  top: 0;
  height: 100vh;
  overflow-y: auto;
  border-right: 1px solid ${({ theme: t }) => t.colors.neutral200};
  z-index: 1;
`, zw = W(pJ)`
  width: 2.4rem;
  background-color: ${({ theme: t }) => t.colors.neutral200};
`, sne = ({
  tag: t = "h2",
  label: e,
  searchLabel: n = "",
  searchable: r = !1,
  onChange: i = () => {
  },
  value: o = "",
  onClear: s = () => {
  },
  onSubmit: a = () => {
  },
  id: c,
  placeholder: h
}) => {
  const [f, d] = C.useState(!1), p = J3(f), v = Vn(c), w = C.useRef(void 0), b = C.useRef(void 0);
  C.useEffect(() => {
    f && w.current && w.current.focus(), p && !f && b.current && b.current.focus();
  }, [f, p]);
  const y = () => {
    d((T) => !T);
  }, $ = (T) => {
    s(T), w.current.focus();
  }, A = (T) => {
    T.relatedTarget?.id !== v && d(!1);
  }, k = (T) => {
    T.key === Bt.ESCAPE && d(!1);
  };
  return f ? /* @__PURE__ */ ae($e, { paddingLeft: 4, paddingTop: 5, paddingBottom: 2, paddingRight: 4, children: [
    /* @__PURE__ */ m(oee, { children: /* @__PURE__ */ m(
      iee,
      {
        name: "searchbar",
        value: o,
        onChange: i,
        placeholder: h,
        onKeyDown: k,
        ref: w,
        onBlur: A,
        onClear: $,
        onSubmit: a,
        clearLabel: "Clear",
        children: n
      }
    ) }),
    /* @__PURE__ */ m($e, { paddingLeft: 2, paddingTop: 4, children: /* @__PURE__ */ m(zw, {}) })
  ] }) : /* @__PURE__ */ ae(ge, { direction: "column", alignItems: "flex-start", paddingLeft: 6, paddingTop: 6, paddingBottom: 2, paddingRight: 4, children: [
    /* @__PURE__ */ ae(ge, { justifyContent: "space-between", alignItems: "flex-start", width: "100%", gap: 2, children: [
      /* @__PURE__ */ m(_e, { variant: "beta", tag: t, children: e }),
      r && /* @__PURE__ */ m(Lo, { ref: b, onClick: y, label: n, children: /* @__PURE__ */ m(Px, {}) })
    ] }),
    /* @__PURE__ */ m($e, { paddingTop: 4, children: /* @__PURE__ */ m(zw, {}) })
  ] });
}, ane = gn(
  ({ active: t, children: e, icon: n = null, withBullet: r = !1, isSubSectionChild: i = !1, ...o }, s) => /* @__PURE__ */ ae(
    fee,
    {
      background: "neutral100",
      paddingLeft: i ? 9 : 7,
      paddingBottom: 2,
      paddingTop: 2,
      ref: s,
      ...o,
      children: [
        /* @__PURE__ */ ae(ge, { children: [
          n ? /* @__PURE__ */ m(dee, { children: n }) : /* @__PURE__ */ m(pg, { $active: t }),
          /* @__PURE__ */ m(_e, { paddingLeft: 2, children: e })
        ] }),
        r && /* @__PURE__ */ m(ge, { paddingRight: 4, children: /* @__PURE__ */ m(pg, { $active: !0 }) })
      ]
    }
  )
), pg = W.span`
  width: 0.4rem;
  height: 0.4rem;
  background-color: ${({ theme: t, $active: e }) => e ? t.colors.primary600 : t.colors.neutral600};
  border-radius: 50%;
`, fee = W(Ll)`
  display: flex;
  align-items: center;
  justify-content: space-between;
  text-decoration: none;
  color: ${({ theme: t }) => t.colors.neutral800};
  svg > * {
    fill: ${({ theme: t }) => t.colors.neutral600};
  }

  &.active {
    ${({ theme: t }) => Ie`
        background-color: ${t.colors.primary100};
        border-right: 2px solid ${t.colors.primary600};
        color: ${t.colors.primary700};
        font-weight: 500;
      `}

    ${pg} {
      background-color: ${({ theme: t }) => t.colors.primary600};
    }
  }

  &:focus-visible {
    outline-offset: -2px;
  }
`, dee = W.div`
  svg {
    height: 1.6rem;
    width: 1.6rem;
  }
`;
W.button`
  border: none;
  padding: 0;
  background: transparent;
  display: flex;
  align-items: center;
`;
const gee = ({
  collapsable: t = !1,
  label: e,
  onClick: n = () => {
  },
  ariaExpanded: r,
  ariaControls: i
}) => t ? /* @__PURE__ */ ae(
  ge,
  {
    tag: "button",
    onClick: n,
    "aria-expanded": r,
    "aria-controls": i,
    textAlign: "left",
    alignItems: "center",
    children: [
      /* @__PURE__ */ m($e, { paddingRight: 1, children: /* @__PURE__ */ m(_e, { variant: "sigma", textColor: "neutral600", children: e }) }),
      t && /* @__PURE__ */ m(
        Wi,
        {
          width: "1.2rem",
          "aria-hidden": !0,
          fill: "neutral500",
          style: { transform: r ? "rotateX(0deg)" : "rotateX(180deg)" }
        }
      )
    ]
  }
) : /* @__PURE__ */ m(ge, { children: /* @__PURE__ */ m($e, { paddingRight: 1, children: /* @__PURE__ */ m(_e, { variant: "sigma", textColor: "neutral600", children: e }) }) }), pee = W($e)`
  & > svg {
    height: 0.4rem;
    fill: ${({ theme: t }) => t.colors.neutral500};
  }
`, lne = ({ collapsable: t = !1, label: e, badgeLabel: n, children: r, id: i }) => {
  const [o, s] = C.useState(!0), a = Vn(i);
  return /* @__PURE__ */ ae(ge, { direction: "column", alignItems: "stretch", gap: 1, children: [
    /* @__PURE__ */ m(pee, { paddingLeft: 6, paddingTop: 2, paddingBottom: 2, paddingRight: 4, children: /* @__PURE__ */ ae($e, { position: "relative", paddingRight: n ? 6 : 0, children: [
      /* @__PURE__ */ m(
        gee,
        {
          onClick: () => {
            s((h) => !h);
          },
          ariaExpanded: o,
          ariaControls: a,
          collapsable: t,
          label: e
        }
      ),
      n && /* @__PURE__ */ m(
        x$,
        {
          backgroundColor: "neutral150",
          textColor: "neutral600",
          position: "absolute",
          right: 0,
          top: "50%",
          transform: "translateY(-50%)",
          children: n
        }
      )
    ] }) }),
    (!t || o) && /* @__PURE__ */ m("ol", { id: a, children: C.Children.map(r, (h, f) => /* @__PURE__ */ m("li", { children: h }, f)) })
  ] });
}, cne = ({ children: t, spacing: e = 2, horizontal: n = !1, ...r }) => /* @__PURE__ */ m($e, { paddingTop: 2, paddingBottom: 4, children: /* @__PURE__ */ m(
  ge,
  {
    tag: "ol",
    gap: e,
    direction: n ? "row" : "column",
    alignItems: n ? "center" : "stretch",
    ...r,
    children: C.Children.map(t, (i, o) => /* @__PURE__ */ m("li", { children: i }, o))
  }
) }), une = C.forwardRef(
  ({
    visibleLabels: t,
    onLabel: e = "On",
    offLabel: n = "Off",
    onCheckedChange: r,
    checked: i,
    defaultChecked: o,
    disabled: s,
    ...a
  }, c) => {
    const [h, f] = Or({
      prop: i,
      defaultProp: o
    });
    return /* @__PURE__ */ ae(ge, { gap: 3, children: [
      /* @__PURE__ */ m(
        mee,
        {
          ref: c,
          onCheckedChange: xo(r, (p) => {
            f(p);
          }),
          checked: h,
          disabled: s,
          ...a,
          children: /* @__PURE__ */ m(vee, {})
        }
      ),
      t ? /* @__PURE__ */ m(bee, { "aria-hidden": !0, "data-disabled": s, "data-state": h ? "checked" : "unchecked", children: h ? e : n }) : null
    ] });
  }
), mee = W(Kj)`
  width: 4rem;
  height: 2.4rem;
  border-radius: 1.2rem;
  background-color: ${({ theme: t }) => t.colors.danger500};

  &[data-state='checked'] {
    background-color: ${({ theme: t }) => t.colors.success500};
  }

  &[data-disabled] {
    background-color: ${({ theme: t }) => t.colors.neutral300};
  }

  @media (prefers-reduced-motion: no-preference) {
    transition: ${(t) => t.theme.transitions.backgroundColor};
  }
`, vee = W(qj)`
  display: block;
  height: 1.6rem;
  width: 1.6rem;
  border-radius: 50%;
  background-color: ${({ theme: t }) => t.colors.neutral0};
  transform: translateX(4px);

  &[data-state='checked'] {
    transform: translateX(20px);
  }

  @media (prefers-reduced-motion: no-preference) {
    transition: transform ${(t) => t.theme.motion.timings[120]}
      ${(t) => t.theme.motion.easings.authenticMotion};
  }
`, bee = W(_e)`
  color: ${(t) => t.theme.colors.danger600};

  &[data-state='checked'] {
    color: ${(t) => t.theme.colors.success600};
  }

  &[data-disabled='true'] {
    color: ${({ theme: t }) => t.colors.neutral500};
  }
`, [wee, um] = _l("Tabs");
C.forwardRef(
  ({ disabled: t = !1, variant: e = "regular", hasError: n, ...r }, i) => /* @__PURE__ */ m(wee, { disabled: t, hasError: n, variant: e, children: /* @__PURE__ */ m(xee, { ref: i, ...r }) })
);
const xee = W(nX)`
  width: 100%;
  position: relative;
`;
C.forwardRef((t, e) => {
  const { variant: n } = um("List");
  return /* @__PURE__ */ m(yee, { ref: e, ...t, $variant: n });
});
const yee = W(rX)`
  display: flex;
  align-items: ${(t) => t.$variant === "regular" ? "flex-end" : "unset"};
  position: relative;
  z-index: 0;
`;
C.forwardRef(
  ({ children: t, disabled: e, ...n }, r) => {
    const { disabled: i, variant: o, hasError: s } = um("Trigger"), a = i === !0 || i === n.value || e, c = s === n.value;
    return /* @__PURE__ */ ae(Cee, { ref: r, ...n, $hasError: c, $variant: o, disabled: a, children: [
      /* @__PURE__ */ m(i8, { fontWeight: "bold", variant: o === "simple" ? "sigma" : void 0, children: t }),
      o === "simple" ? /* @__PURE__ */ m(r8, {}) : null
    ] });
  }
);
const r8 = W.span`
  display: block;
  width: 100%;
  background-color: currentColor;
  position: absolute;
  bottom: 0;
  left: 0;
  opacity: 0;
  height: 0.2rem;
`, i8 = W(_e)``, Cee = W(iX)`
  position: relative;
  color: ${(t) => t.$hasError ? t.theme.colors.danger600 : t.theme.colors.neutral600};
  cursor: pointer;
  z-index: 0;

  ${(t) => t.$variant === "simple" ? Ie`
        padding-block: ${(e) => e.theme.spaces[4]};
        padding-inline: ${(e) => e.theme.spaces[4]};

        & > ${i8} {
          line-height: 1.2rem;
        }

        &[data-state='active'] {
          color: ${t.$hasError ? t.theme.colors.danger600 : t.theme.colors.primary700};

          & > ${r8} {
            opacity: 1;
          }
        }
      ` : Ie`
        padding-block: ${(e) => e.theme.spaces[3]};
        padding-inline: ${(e) => e.theme.spaces[3]};
        flex: 1;
        background-color: ${(e) => e.theme.colors.neutral100};
        border-bottom: solid 1px ${(e) => e.theme.colors.neutral150};

        &:not([data-state='active']) + &:not([data-state='active']) {
          border-left: solid 1px ${(e) => e.theme.colors.neutral150};
        }

        &[data-state='active'] {
          padding-block: ${(e) => e.theme.spaces[4]};
          padding-inline: ${(e) => e.theme.spaces[4]};
          color: ${t.$hasError ? t.theme.colors.danger600 : t.theme.colors.primary700};
          border-top-right-radius: ${(e) => e.theme.borderRadius};
          border-top-left-radius: ${(e) => e.theme.borderRadius};
          background-color: ${(e) => e.theme.colors.neutral0};
          border-bottom: solid 1px ${(e) => e.theme.colors.neutral0};
          box-shadow: ${t.theme.shadows.tableShadow};
          z-index: 1;
        }
      `}

  &[data-disabled] {
    cursor: not-allowed;
    color: ${(t) => t.theme.colors.neutral400};
  }
`;
C.forwardRef((t, e) => {
  const { variant: n } = um("Content");
  return /* @__PURE__ */ m($ee, { $variant: n, ref: e, ...t });
});
const $ee = W(oX)`
  ${(t) => t.$variant === "simple" ? Ie`` : Ie`
        position: relative;
        z-index: 1;
        background-color: ${(e) => e.theme.colors.neutral0};
      `}
`, See = W($e)`
  overflow: hidden;
  border: 1px solid ${({ theme: t }) => t.colors.neutral150};
`, Aee = W(XJ)`
  width: 100%;
  white-space: nowrap;
`, kee = W($e)`
  &:before {
    // TODO: make sure to add a token for this weird stuff
    background: linear-gradient(90deg, #c0c0cf 0%, rgba(0, 0, 0, 0) 100%);
    opacity: 0.2;
    position: absolute;
    height: 100%;
    content: ${({ $overflowing: t }) => t === "both" || t === "left" ? "''" : void 0};
    box-shadow: ${({ theme: t }) => t.shadows.tableShadow};
    width: ${({ theme: t }) => t.spaces[2]};
    left: 0;
  }

  &:after {
    // TODO: make sure to add a token for this weird stuff
    background: linear-gradient(270deg, #c0c0cf 0%, rgba(0, 0, 0, 0) 100%);
    opacity: 0.2;
    position: absolute;
    height: 100%;
    content: ${({ $overflowing: t }) => t === "both" || t === "right" ? "''" : void 0};
    box-shadow: ${({ theme: t }) => t.shadows.tableShadow};
    width: ${({ theme: t }) => t.spaces[2]};
    right: 0;
    top: 0;
  }
`, Mee = W($e)`
  overflow-x: auto;
`, hne = C.forwardRef(({ footer: t, ...e }, n) => {
  const r = C.useRef(null), [i, o] = C.useState(), s = (a) => {
    const c = a.target.scrollWidth - a.target.clientWidth;
    if (a.target.scrollLeft === 0) {
      o("right");
      return;
    }
    if (a.target.scrollLeft === c) {
      o("left");
      return;
    }
    a.target.scrollLeft > 0 && o("both");
  };
  return C.useEffect(() => {
    r.current.scrollWidth > r.current.clientWidth && o("right");
  }, []), /* @__PURE__ */ ae(See, { shadow: "tableShadow", hasRadius: !0, background: "neutral0", children: [
    /* @__PURE__ */ m(kee, { $overflowing: i, position: "relative", children: /* @__PURE__ */ m(Mee, { ref: r, onScroll: s, paddingLeft: 6, paddingRight: 6, children: /* @__PURE__ */ m(Aee, { ref: n, ...e }) }) }),
    t
  ] });
}), Tee = W(JJ)`
  & tr:last-of-type {
    border-bottom: none;
  }
`, fne = ({ children: t, ...e }) => /* @__PURE__ */ m(Tee, { ...e, children: t }), Ree = W(QJ)`
  border-bottom: 1px solid ${({ theme: t }) => t.colors.neutral150};
`, dne = ({ children: t, ...e }) => /* @__PURE__ */ m(Ree, { ...e, children: t }), Eee = W(eee)`
  border-bottom: 1px solid ${({ theme: t }) => t.colors.neutral150};

  & td,
  & th {
    padding: ${({ theme: t }) => t.spaces[4]};
  }

  & td:first-of-type,
  & th:first-of-type {
    padding: 0 ${({ theme: t }) => t.spaces[1]};
  }

  // Resetting padding values and fixing a height
  th {
    padding-top: 0;
    padding-bottom: 0;
    height: 5.6rem;
  }
`, gne = (t) => /* @__PURE__ */ m(Eee, { ...t }), o8 = W(t8)`
  vertical-align: middle;
  text-align: left;
  outline-offset: -4px;

  /**
  * Hack to make sure the checkbox looks aligned
  */
  input {
    vertical-align: sub;
  }
`, pne = C.forwardRef(({ children: t, action: e, ...n }, r) => /* @__PURE__ */ m(o8, { color: "neutral600", as: ZJ, ref: r, ...n, children: /* @__PURE__ */ ae(ge, { children: [
  t,
  e
] }) })), mne = C.forwardRef(({ children: t, ...e }, n) => /* @__PURE__ */ m(o8, { color: "neutral800", ref: n, ...e, children: t }));
W($e)`
  height: 2.4rem;
  width: 2.4rem;
  border-radius: 50%;
  display: flex;
  justify-content: center;
  align-items: center;

  svg {
    height: 1rem;
    width: 1rem;
  }

  svg path {
    fill: ${({ theme: t }) => t.colors.primary600};
  }
`;
W($e)`
  border-radius: 0 0 ${({ theme: t }) => t.borderRadius} ${({ theme: t }) => t.borderRadius};
  display: block;
  width: 100%;
  border: none;
`;
gn(
  ({ children: t, startIcon: e, endIcon: n, disabled: r = !1, loading: i = !1, ...o }, s) => {
    const a = r || i;
    return /* @__PURE__ */ ae(
      Iee,
      {
        ref: s,
        disabled: a,
        "aria-disabled": a,
        tag: "button",
        type: "button",
        gap: 2,
        ...o,
        children: [
          i ? /* @__PURE__ */ m(Dee, { "aria-hidden": !0, children: /* @__PURE__ */ m(Hx, {}) }) : e,
          /* @__PURE__ */ m(_e, { variant: "pi", children: t }),
          n
        ]
      }
    );
  }
);
const Oee = tn`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(359deg);
  }
`, Dee = W.span`
  display: flex;
  animation: ${Oee} 2s infinite linear;
  will-change: transform;
`, Iee = W(ge)`
  border: none;
  background-color: transparent;
  color: ${(t) => t.theme.colors.primary600};
  cursor: pointer;

  &[aria-disabled='true'] {
    pointer-events: none;
    color: ${(t) => t.theme.colors.neutral600};
  }

  ${hf}
`, _ee = C.forwardRef((t, e) => /* @__PURE__ */ m(gf, { ref: e, ...t }));
_ee.displayName = "TextInput";
C.forwardRef(
  ({ disabled: t, hasError: e, id: n, name: r, required: i, ...o }, s) => {
    const { error: a, ...c } = kn("Textarea"), h = !!a || e, f = c.id ?? n, d = c.name ?? r, p = c.required || i;
    let v;
    return a ? v = `${f}-error` : c.hint && (v = `${f}-hint`), /* @__PURE__ */ m(Lee, { borderColor: h ? "danger600" : "neutral200", $hasError: h, hasRadius: !0, children: /* @__PURE__ */ m(
      Bee,
      {
        "aria-invalid": h,
        "aria-required": p,
        tag: "textarea",
        background: t ? "neutral150" : "neutral0",
        color: t ? "neutral600" : "neutral800",
        disabled: t,
        fontSize: 2,
        hasRadius: !0,
        ref: s,
        lineHeight: 4,
        padding: 4,
        width: "100%",
        height: "100%",
        id: f,
        name: d,
        "aria-describedby": v,
        ...o
      }
    ) });
  }
);
const Lee = W($e)`
  height: 10.5rem;
  ${Qi()}
`, Bee = W($e)`
  border: none;
  resize: none;

  ::placeholder {
    color: ${({ theme: t }) => t.colors.neutral500};
    font-size: ${({ theme: t }) => t.fontSizes[2]};
    color: ${({ theme: t }) => t.colors.neutral500};
    opacity: 1;
  }

  &:focus-within {
    outline: none;
  }

  &:disabled {
    cursor: not-allowed;
  }
`, vne = C.forwardRef(
  ({
    offLabel: t,
    onLabel: e,
    disabled: n,
    hasError: r,
    required: i,
    id: o,
    name: s,
    checked: a,
    onChange: c,
    ...h
  }, f) => {
    const [d = !1, p] = Or({
      prop: a
    }), v = d !== null && !d, { error: w, ...b } = kn("Toggle"), y = !!w || r, $ = b.id ?? o, A = b.name ?? s, k = b.required || i;
    let T;
    return w ? T = `${$}-error` : b.hint && (T = `${$}-hint`), /* @__PURE__ */ ae(
      Nee,
      {
        position: "relative",
        hasRadius: !0,
        padding: 1,
        background: n ? "neutral150" : "neutral100",
        borderStyle: "solid",
        borderWidth: "1px",
        borderColor: "neutral200",
        wrap: "wrap",
        cursor: n ? "not-allowed" : "pointer",
        $hasError: y,
        children: [
          /* @__PURE__ */ m(
            Uw,
            {
              hasRadius: !0,
              flex: "1 1 50%",
              paddingTop: 2,
              paddingBottom: 2,
              paddingLeft: 3,
              paddingRight: 3,
              justifyContent: "center",
              background: n && v ? "neutral200" : v ? "neutral0" : "transparent",
              borderColor: n && v ? "neutral300" : v ? "neutral200" : n ? "neutral150" : "neutral100",
              children: /* @__PURE__ */ m(
                _e,
                {
                  variant: "pi",
                  fontWeight: "bold",
                  textTransform: "uppercase",
                  textColor: n ? "neutral700" : v ? "danger700" : "neutral600",
                  children: t
                }
              )
            }
          ),
          /* @__PURE__ */ m(
            Uw,
            {
              hasRadius: !0,
              flex: "1 1 50%",
              paddingLeft: 3,
              paddingRight: 3,
              justifyContent: "center",
              background: n && d ? "neutral200" : d ? "neutral0" : "transparent",
              borderColor: n && d ? "neutral300" : d ? "neutral200" : n ? "neutral150" : "neutral100",
              children: /* @__PURE__ */ m(
                _e,
                {
                  variant: "pi",
                  fontWeight: "bold",
                  textTransform: "uppercase",
                  textColor: n ? "neutral700" : d ? "primary600" : "neutral600",
                  children: e
                }
              )
            }
          ),
          /* @__PURE__ */ m(
            Fee,
            {
              ...h,
              id: $,
              name: A,
              ref: f,
              onChange: (R) => {
                p(R.currentTarget.checked), c?.(R);
              },
              type: "checkbox",
              "aria-required": k,
              disabled: n,
              "aria-disabled": n,
              checked: !!d,
              "aria-describedby": T
            }
          )
        ]
      }
    );
  }
), Nee = W(ge)`
  ${Qi()}
`, Uw = W(ge)`
  padding-block: 0.6rem;
`, Fee = W.input`
  height: 100%;
  left: 0;
  opacity: 0;
  position: absolute;
  top: 0;
  z-index: 0;
  width: 100%;
`, Vee = gn((t, e) => {
  const { gap: n = 0, gridCols: r = 12, ...i } = t;
  return /* @__PURE__ */ m(Hee, { ref: e, $gap: n, $gridCols: r, ...i });
}), Hee = W($e)`
  display: grid;
  grid-template-columns: repeat(${({ $gridCols: t }) => t}, 1fr);
  ${({ theme: t, $gap: e }) => uf({ gap: e }, t)}
`, Pee = gn(
  ({ col: t, s: e, xs: n, m: r, ...i }, o) => /* @__PURE__ */ m(Wee, { ref: o, $col: t, $s: e, $xs: n, $m: r, ...i })
), Wee = W(ge)`
  grid-column: span ${({ $xs: t }) => t ?? 12};
  max-width: 100%;

  ${({ theme: t }) => t.breakpoints.small} {
    grid-column: span ${({ $s: t, $xs: e }) => t ?? e ?? 12};
  }

  ${({ theme: t }) => t.breakpoints.medium} {
    grid-column: span ${({ $m: t, $s: e, $xs: n }) => t ?? e ?? n ?? 12};
  }

  ${({ theme: t }) => t.breakpoints.large} {
    grid-column: span ${({ $col: t, $m: e, $s: n, $xs: r }) => t ?? e ?? n ?? r ?? 12};
  }
`, bne = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Item: Pee,
  Root: Vee
}, Symbol.toStringTag, { value: "Module" })), wne = ({ onEscape: t, restoreFocus: e = !0, skipAutoFocus: n = !1, ...r }) => {
  const i = C.useRef(null);
  return C.useEffect(() => {
    let s = null;
    return e && (s = document.activeElement), () => {
      s && s.focus();
    };
  }, [e]), C.useEffect(() => {
    if (!i.current || n)
      return;
    const s = go(i.current);
    s.length > 0 ? s[0].focus() : console.warn(
      "[FocusTrap]: it seems there are no focusable elements in the focus trap tree. Make sure there s at least one."
    );
  }, [n]), /* @__PURE__ */ m("div", { ref: i, onKeyDown: (s) => {
    if (s.key === Bt.ESCAPE && t) {
      t();
      return;
    }
    if (s.key !== Bt.TAB)
      return;
    const a = go(i.current);
    if (a.length > 0) {
      const c = a[0], h = a[a.length - 1];
      s.shiftKey ? c === document.activeElement && (s.preventDefault(), h.focus()) : h === document.activeElement && (s.preventDefault(), c.focus());
    }
  }, ...r });
};
W(ge)`
    &>* {
        width: 100%;
    }
`;
const zee = "strapi-plugin-comments", Uee = {
  displayName: "Comments"
}, Kee = 576, qee = ({ width: t = 24, height: e = 24 }) => /* @__PURE__ */ m("svg", { viewBox: `0 0 ${t} ${e}`, xmlns: "http://www.w3.org/2000/svg", height: `${e}px`, children: /* @__PURE__ */ m("g", { style: { transform: `scale(${t / Kee})` }, fill: "currentColor", children: /* @__PURE__ */ m("path", { d: "M416 192c0-88.4-93.1-160-208-160S0 103.6 0 192c0 34.3 14.1 65.9 38 92-13.4 30.2-35.5 54.2-35.8 54.5-2.2 2.3-2.8 5.7-1.5 8.7S4.8 352 8 352c36.6 0 66.9-12.3 88.7-25 32.2 15.7 70.3 25 111.3 25 114.9 0 208-71.6 208-160zm122 220c23.9-26 38-57.7 38-92 0-66.9-53.5-124.2-129.3-148.1.9 6.6 1.3 13.3 1.3 20.1 0 105.9-107.7 192-240 192-10.8 0-21.3-.8-31.7-1.9C207.8 439.6 281.8 480 368 480c41 0 79.1-9.2 111.3-25 21.8 12.7 52.1 25 88.7 25 3.2 0 6.1-1.9 7.3-4.8 1.3-2.9.7-6.3-1.5-8.7-.3-.3-22.4-24.2-35.8-54.5z" }) }) }), Gee = /* @__PURE__ */ m(qee, {}), Yee = () => Gee, en = {
  render: (t) => `plugin::comments.${t}`,
  comments: {
    read: "comments-read",
    moderate: "comments-moderate"
  },
  reports: {
    read: "reports-read",
    review: "reports-review"
  },
  settings: {
    read: "settings-read",
    change: "settings-change"
  }
}, Kw = {
  access: [
    { action: en.render(en.comments.read), subject: null },
    { action: en.render(en.reports.read), subject: null },
    // { action: 'plugin::comments.discover.read', subject: null },
    { action: en.render(en.settings.read), subject: null }
  ],
  // discover: [{ action: 'plugin::comments.discover.read', subject: null }],
  moderate: [
    {
      action: en.render(en.comments.moderate),
      subject: null
    }
  ],
  reports: [
    { action: en.render(en.reports.read), subject: null }
  ],
  reportsReview: [
    { action: en.render(en.reports.review), subject: null }
  ],
  settings: [
    { action: en.render(en.settings.read), subject: null }
  ],
  settingsChange: [
    { action: en.render(en.settings.change), subject: null }
  ]
}, Ei = zee.replace(/^strapi-plugin-/i, ""), qw = {
  en: () => import("./en-BtJqEJGe.mjs"),
  fr: () => import("./fr-n-k7Rsq9.mjs"),
  "pt-BR": () => import("./pt-BR-Bx1qSZ0Z.mjs"),
  tr: () => import("./tr-CloK8CbW.mjs"),
  ru: () => import("./ru-BuUj7OWH.mjs"),
  "zh-Hans": () => import("./zh-Hans-Isi-yCnI.mjs"),
  pl: () => import("./pl-_wkGtdQj.mjs")
}, { displayName: Gw } = Uee, xne = {
  register(t) {
    t.addMenuLink({
      to: `/plugins/${Ei}`,
      badgeContent: 1,
      icon: Yee,
      intlLabel: {
        id: `${Ei}.plugin.name`,
        defaultMessage: Gw
      },
      Component: () => import("./index-Cy3CcAb6.mjs"),
      permissions: Kw.access
    }), t.createSettingSection(
      {
        id: Ei,
        intlLabel: {
          id: `${Ei}.plugin.section`,
          defaultMessage: `${Gw} plugin`
        }
      },
      [
        {
          intlLabel: {
            id: `${Ei}.plugin.section.item`,
            defaultMessage: "Configuration"
          },
          id: "comments",
          to: `/settings/${Ei}`,
          Component: () => import("./index-E6FY3Rjk.mjs"),
          permissions: Kw.settings
        }
      ]
    );
  },
  registerTrads: async function({ locales: t = [] }) {
    return Promise.all(
      t.map(async (e) => e in qw ? qw[e]().then(({ default: r }) => ({
        data: Hv(N0(r), Ei),
        locale: e
      })) : {
        data: Hv(N0({}), Ei),
        locale: e
      })
    );
  }
};
export {
  bne as $,
  ate as A,
  $e as B,
  sm as C,
  pJ as D,
  fte as E,
  ge as F,
  bte as G,
  hne as H,
  Lo as I,
  dne as J,
  gne as K,
  pne as L,
  nne as M,
  fne as N,
  pte as O,
  V$ as P,
  yte as Q,
  ute as R,
  one as S,
  _e as T,
  vte as U,
  wte as V,
  jte as W,
  R$ as X,
  JZ as Y,
  cZ as Z,
  rte as _,
  sne as a,
  mne as a0,
  SZ as a1,
  Zte as a2,
  mte as a3,
  ine as a4,
  cee as a5,
  Gte as a6,
  une as a7,
  vne as a8,
  nte as a9,
  Yte as aa,
  Kte as ab,
  Ra as ac,
  tne as ad,
  Qte as ae,
  VZ as af,
  Kw as ag,
  lt as ah,
  xl as ai,
  ene as aj,
  _N as ak,
  xne as al,
  cne as b,
  lne as c,
  ane as d,
  dg as e,
  ste as f,
  Vo as g,
  x$ as h,
  Xte as i,
  Ute as j,
  wne as k,
  qte as l,
  lte as m,
  cte as n,
  Jte as o,
  Ei as p,
  Fw as q,
  Vw as r,
  ite as s,
  hte as t,
  Cte as u,
  dte as v,
  rne as w,
  xte as x,
  ote as y,
  gte as z
};
